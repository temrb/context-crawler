[
  {
    "title": "Getting Started: Metadata and OG images | Next.js",
    "url": "https://nextjs.org/docs/app/getting-started/metadata-and-og-images",
    "html": "App Router\nGetting Started\nMetadata and OG images\nCopy page\nMetadata and OG images\n\nThe Metadata APIs can be used to define your application metadata for improved SEO and web shareability and include:\n\nThe static metadata object\nThe dynamic generateMetadata function\nSpecial file conventions that can be used to add static or dynamically generated favicons and OG images.\n\nWith all the options above, Next.js will automatically generate the relevant <head> tags for your page, which can be inspected in the browser's developer tools.\n\nThe metadata object and generateMetadata function exports are only supported in Server Components.\n\nDefault fields\n\nThere are two default meta tags that are always added even if a route doesn't define metadata:\n\nThe meta charset tag\n sets the character encoding for the website.\nThe meta viewport tag\n sets the viewport width and scale for the website to adjust for different devices.\n<meta charset=\"utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\nThe other metadata fields can be defined with the Metadata object (for static metadata) or the generateMetadata function (for generated metadata).\n\nStatic metadata\n\nTo define static metadata, export a Metadata object from a static layout.js or page.js file. For example, to add a title and description to the blog route:\n\napp/blog/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Metadata } from 'next'\n \nexport const metadata: Metadata = {\n  title: 'My Blog',\n  description: '...',\n}\n \nexport default function Layout() {}\n\nYou can view a full list of available options, in the generateMetadata documentation.\n\nGenerated metadata\n\nYou can use generateMetadata function to fetch metadata that depends on data. For example, to fetch the title and description for a specific blog post:\n\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport type { Metadata, ResolvingMetadata } from 'next'\n \ntype Props = {\n  params: Promise<{ slug: string }>\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}\n \nexport async function generateMetadata(\n  { params, searchParams }: Props,\n  parent: ResolvingMetadata\n): Promise<Metadata> {\n  const slug = (await params).slug\n \n  // fetch post information\n  const post = await fetch(`https://api.vercel.app/blog/${slug}`).then((res) =>\n    res.json()\n  )\n \n  return {\n    title: post.title,\n    description: post.description,\n  }\n}\n \nexport default function Page({ params, searchParams }: Props) {}\nStreaming metadata\n\nFor dynamically rendered pages, Next.js streams metadata separately, injecting it into the HTML once generateMetadata resolves, without blocking UI rendering.\n\nStreaming metadata improves perceived performance by allowing visual content to stream first.\n\nStreaming metadata is disabled for bots and crawlers that expect metadata to be in the <head> tag (e.g. Twitterbot, Slackbot, Bingbot). These are detected by using the User Agent header from the incoming request.\n\nYou can customize or disable streaming metadata completely, with the htmlLimitedBots option in your Next.js config file.\n\nStatically rendered pages donâ€™t use streaming since metadata is resolved at build time.\n\nLearn more about streaming metadata.\n\nMemoizing data requests\n\nThere may be cases where you need to fetch the same data for metadata and the page itself. To avoid duplicate requests, you can use React's cache function\n to memoize the return value and only fetch the data once. For example, to fetch the blog post information for both the metadata and the page:\n\napp/lib/data.ts\nTypeScript\nJavaScript\nTypeScript\nimport { cache } from 'react'\nimport { db } from '@/app/lib/db'\n \n// getPost will be used twice, but execute only once\nexport const getPost = cache(async (slug: string) => {\n  const res = await db.query.posts.findFirst({ where: eq(posts.slug, slug) })\n  return res\n})\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { getPost } from '@/app/lib/data'\n \nexport async function generateMetadata({\n  params,\n}: {\n  params: { slug: string }\n}) {\n  const post = await getPost(params.slug)\n  return {\n    title: post.title,\n    description: post.description,\n  }\n}\n \nexport default async function Page({ params }: { params: { slug: string } }) {\n  const post = await getPost(params.slug)\n  return <div>{post.title}</div>\n}\nFile-based metadata\n\nThe following special files are available for metadata:\n\nfavicon.ico, apple-icon.jpg, and icon.jpg\nopengraph-image.jpg and twitter-image.jpg\nrobots.txt\nsitemap.xml\n\nYou can use these for static metadata, or you can programmatically generate these files with code.\n\nFavicons\n\nFavicons are small icons that represent your site in bookmarks and search results. To add a favicon to your application, create a favicon.ico and add to the root of the app folder.\n\nYou can also programmatically generate favicons using code. See the favicon docs for more information.\n\nStatic Open Graph images\n\nOpen Graph (OG) images are images that represent your site in social media. To add a static OG image to your application, create a opengraph-image.png file in the root of the app folder.\n\nYou can also add OG images for specific routes by creating a opengraph-image.png deeper down the folder structure. For example, to create an OG image specific to the /blog route, add a opengraph-image.jpg file inside the blog folder.\n\nThe more specific image will take precedence over any OG images above it in the folder structure.\n\nOther image formats such as jpeg, png, and gif are also supported. See the Open Graph Image docs for more information.\n\nGenerated Open Graph images\n\nThe ImageResponse constructor allows you to generate dynamic images using JSX and CSS. This is useful for OG images that depend on data.\n\nFor example, to generate a unique OG image for each blog post, add a opengraph-image.tsx file inside the blog folder, and import the ImageResponse constructor from next/og:\n\napp/blog/[slug]/opengraph-image.tsx\nTypeScript\nJavaScript\nTypeScript\nimport { ImageResponse } from 'next/og'\nimport { getPost } from '@/app/lib/data'\n \n// Image metadata\nexport const size = {\n  width: 1200,\n  height: 630,\n}\n \nexport const contentType = 'image/png'\n \n// Image generation\nexport default async function Image({ params }: { params: { slug: string } }) {\n  const post = await getPost(params.slug)\n \n  return new ImageResponse(\n    (\n      // ImageResponse JSX element\n      <div\n        style={{\n          fontSize: 128,\n          background: 'white',\n          width: '100%',\n          height: '100%',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n        }}\n      >\n        {post.title}\n      </div>\n    )\n  )\n}\n\nImageResponse supports common CSS properties including flexbox and absolute positioning, custom fonts, text wrapping, centering, and nested images. See the full list of supported CSS properties.\n\nGood to know:\n\nExamples are available in the Vercel OG Playground\n.\nImageResponse uses @vercel/og\n, satori\n, and resvg to convert HTML and CSS into PNG.\nOnly flexbox and a subset of CSS properties are supported. Advanced layouts (e.g. display: grid) will not work.\nAPI Reference\nLearn more about the Metadata APIs mentioned in this page.\ngenerateMetadata\nLearn how to add Metadata to your Next.js application for improved search engine optimization (SEO) and web shareability.\ngenerateViewport\nAPI Reference for the generateViewport function.\nImageResponse\nAPI Reference for the ImageResponse constructor.\nMetadata Files\nAPI documentation for the metadata file conventions.\nfavicon, icon, and apple-icon\nAPI Reference for the Favicon, Icon and Apple Icon file conventions.\nopengraph-image and twitter-image\nAPI Reference for the Open Graph Image and Twitter Image file conventions.\nrobots.txt\nAPI Reference for robots.txt file.\nsitemap.xml\nAPI Reference for the sitemap.xml file.\nhtmlLimitedBots\nSpecify a list of user agents that should receive blocking metadata.\nPrevious\nFont Optimization\nNext\nRoute Handlers\n\nWas this helpful?\n\nsupported.\nSend"
  }
]
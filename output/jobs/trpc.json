[
  {
    "title": "tRPC server documentation | tRPC",
    "url": "https://trpc.io/docs/server/introduction",
    "html": "📄️ Define Routers\n\nTo begin building your tRPC-based API, you'll first need to define your router. Once you've mastered the fundamentals, you can customize your routers for more advanced use cases.\n\n📄️ Define Procedures\n\nA procedure is a function which is exposed to the client, it can be one of:\n\n📄️ Input & Output Validators\n\ntRPC procedures may define validation logic for their input and/or output, and validators are also used to infer the types of inputs and outputs (using the Standard Schema interface if available, or custom interfaces for supported validators if not). We have first class support for many popular validators, and you can integrate validators which we don't directly support.\n\n📄️ Non-JSON Inputs (FormData, File, Blob)\n\nIn addition to JSON-serializable data, tRPC can use FormData, File, and other Binary types as procedure inputs\n\n📄️ Merging Routers\n\nWriting all API-code in your code in the same file is not a great idea. It's easy to merge routers with other routers.\n\n📄️ Context\n\nYour context holds data that all of your tRPC procedures will have access to, and is a great place to put things like database connections or authentication information.\n\n📄️ Middlewares\n\nYou are able to add middleware(s) to a procedure with the t.procedure.use() method. The middleware(s) will wrap the invocation of the procedure and must pass through its return value.\n\n🗃️ Hosting tRPC with Adapters\n\n6 items\n\n📄️ Server Side Calls\n\nYou may need to call your procedure(s) directly from the same server they're hosted in, createCallerFactory() can be used to achieve this. This is useful for server-side calls and for integration testing of your tRPC procedures.\n\n📄️ Authorization\n\nThe createContext function is called for each incoming request, so here you can add contextual information about the calling user from the request object.\n\n📄️ Error Handling\n\nWhenever an error occurs in a procedure, tRPC responds to the client with an object that includes an \"error\" property. This property contains all the information that you need to handle the error in the client.\n\n📄️ Error Formatting\n\nThe error formatting in your router will be inferred all the way to your client (&&nbsp;React&nbsp;components)\n\n📄️ Data Transformers\n\nYou are able to serialize the response data & input args. The transformers need to be added both to the server and the client.\n\n📄️ Metadata\n\nProcedure metadata allows you to add an optional procedure specific meta property which will be available in all middleware function parameters.\n\n📄️ Response Caching\n\nThe below examples uses Vercel's edge caching to serve data to your users as fast as possible.\n\n📄️ Subscriptions\n\nIntroduction\n\n📄️ WebSockets\n\nYou can use WebSockets for all or some of the communication with your server, see wsLink for how to set it up on the client."
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/introduction#__docusaurus_skipToContent_fallback",
    "html": "📄️ Define Routers\n\nTo begin building your tRPC-based API, you'll first need to define your router. Once you've mastered the fundamentals, you can customize your routers for more advanced use cases.\n\n📄️ Define Procedures\n\nA procedure is a function which is exposed to the client, it can be one of:\n\n📄️ Input & Output Validators\n\ntRPC procedures may define validation logic for their input and/or output, and validators are also used to infer the types of inputs and outputs (using the Standard Schema interface if available, or custom interfaces for supported validators if not). We have first class support for many popular validators, and you can integrate validators which we don't directly support.\n\n📄️ Non-JSON Inputs (FormData, File, Blob)\n\nIn addition to JSON-serializable data, tRPC can use FormData, File, and other Binary types as procedure inputs\n\n📄️ Merging Routers\n\nWriting all API-code in your code in the same file is not a great idea. It's easy to merge routers with other routers.\n\n📄️ Context\n\nYour context holds data that all of your tRPC procedures will have access to, and is a great place to put things like database connections or authentication information.\n\n📄️ Middlewares\n\nYou are able to add middleware(s) to a procedure with the t.procedure.use() method. The middleware(s) will wrap the invocation of the procedure and must pass through its return value.\n\n🗃️ Hosting tRPC with Adapters\n\n6 items\n\n📄️ Server Side Calls\n\nYou may need to call your procedure(s) directly from the same server they're hosted in, createCallerFactory() can be used to achieve this. This is useful for server-side calls and for integration testing of your tRPC procedures.\n\n📄️ Authorization\n\nThe createContext function is called for each incoming request, so here you can add contextual information about the calling user from the request object.\n\n📄️ Error Handling\n\nWhenever an error occurs in a procedure, tRPC responds to the client with an object that includes an \"error\" property. This property contains all the information that you need to handle the error in the client.\n\n📄️ Error Formatting\n\nThe error formatting in your router will be inferred all the way to your client (&&nbsp;React&nbsp;components)\n\n📄️ Data Transformers\n\nYou are able to serialize the response data & input args. The transformers need to be added both to the server and the client.\n\n📄️ Metadata\n\nProcedure metadata allows you to add an optional procedure specific meta property which will be available in all middleware function parameters.\n\n📄️ Response Caching\n\nThe below examples uses Vercel's edge caching to serve data to your users as fast as possible.\n\n📄️ Subscriptions\n\nIntroduction\n\n📄️ WebSockets\n\nYou can use WebSockets for all or some of the communication with your server, see wsLink for how to set it up on the client."
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/routers",
    "html": "Backend Usage\nDefine Routers\nVersion: 11.x\nDefine Routers\n\nTo begin building your tRPC-based API, you'll first need to define your router. Once you've mastered the fundamentals, you can customize your routers for more advanced use cases.\n\nInitialize tRPC​\n\nYou should initialize tRPC exactly once per application. Multiple instances of tRPC will cause issues.\n\nserver/trpc.ts\nimport { initTRPC } from '@trpc/server';\n \n// You can use any variable name you like.\n// We use t to keep things simple.\nconst t = initTRPC.create();\n \nexport const router = t.router;\nexport const publicProcedure = t.procedure;\nCopy\n\nYou'll notice we are exporting certain methods of the t variable here rather than t itself. This is to establish a certain set of procedures that we will use idiomatically in our codebase.\n\nDefining a router​\n\nNext, let's define a router with a procedure to use in our application. We have now created an API \"endpoint\".\n\nIn order for these endpoints to be exposed to the frontend, your Adapter should be configured with your appRouter instance.\n\nserver/_app.ts\nimport { publicProcedure, router } from './trpc';\n \nconst appRouter = router({\n  greeting: publicProcedure.query(() => 'hello tRPC v10!'),\n});\n \n// Export only the type of a router!\n// This prevents us from importing server code on the client.\nexport type AppRouter = typeof appRouter;\nCopy\nAdvanced usage​\n\nWhen initializing your router, tRPC allows you to:\n\nSetup request contexts\nAssign metadata to procedures\nFormat and handle errors\nTransform data as needed\nCustomize the runtime configuration\n\nYou can use method chaining to customize your t-object on initialization. For example:\n\nconst t = initTRPC.context<Context>().meta<Meta>().create({\n  /* [...] */\n});\nCopy\nRuntime Configuration​\nexport interface RootConfig<TTypes extends RootTypes> {\n  /**\n   * Use a data transformer\n   * @see https://trpc.io/docs/v11/data-transformers\n   */\n  transformer: TTypes['transformer'];\n  /**\n   * Use custom error formatting\n   * @see https://trpc.io/docs/v11/error-formatting\n   */\n  errorFormatter: ErrorFormatter<TTypes['ctx'], any>;\n  /**\n   * Allow `@trpc/server` to run in non-server environments\n   * @warning **Use with caution**, this should likely mainly be used within testing.\n   * @default false\n   */\n  allowOutsideOfServer: boolean;\n  /**\n   * Is this a server environment?\n   * @warning **Use with caution**, this should likely mainly be used within testing.\n   * @default typeof window === 'undefined' || 'Deno' in window || process.env.NODE_ENV === 'test'\n   */\n  isServer: boolean;\n  /**\n   * Is this development?\n   * Will be used to decide if the API should return stack traces\n   * @default process.env.NODE_ENV !== 'production'\n   */\n  isDev: boolean;\n}\nCopy\nEdit this page"
  },
  {
    "title": "Define Procedures | tRPC",
    "url": "https://trpc.io/docs/server/procedures",
    "html": "Backend Usage\nDefine Procedures\nVersion: 11.x\nDefine Procedures\n\nA procedure is a function which is exposed to the client, it can be one of:\n\na Query - used to fetch data, generally does not change any data\na Mutation - used to send data, often for create/update/delete purposes\na Subscription - you might not need this, and we have dedicated documentation\n\nProcedures in tRPC are very flexible primitives to create backend functions. They use an immutable builder pattern, which means you can create reusable base procedures that share functionality among multiple procedures.\n\nWriting procedures​\n\nThe t object you create during tRPC setup returns an initial t.procedure which all other procedures are built on:\n\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n \nconst t = initTRPC.context<{ signGuestBook: () => Promise<void> }>().create();\n \nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n \nconst appRouter = router({\n  // Queries are the best place to fetch data\n  hello: publicProcedure.query(() => {\n    return {\n      message: 'hello world',\n    };\n  }),\n \n  // Mutations are the best place to do things like updating a database\n  goodbye: publicProcedure.mutation(async (opts) => {\n    await opts.ctx.signGuestBook();\n \n    return {\n      message: 'goodbye!',\n    };\n  }),\n});\nCopy\nReusable \"Base Procedures\"​\n\nAs a general pattern we recommend you rename and export t.procedure as publicProcedure, which then makes room for you to create other named procedures for specific use cases and export those too. This pattern is called \"base procedures\" and is a key pattern for code and behaviour re-use in tRPC; every application is likely to need it.\n\nIn the below code, we're using reusable base procedures to build common use-cases for our app - we're making a reusable base procedures for logged in users (authedProcedure) & another base procedure that takes an organizationId and validates that a user is part of that organization.\n\nThis is a simplified example; in practice you may want to use some combination of Headers, Context, Middleware, and Metadata, to authenticate and authorize your users.\n\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport { z } from 'zod';\n \ntype Organization = {\n  id: string;\n  name: string;\n};\ntype Membership = {\n  role: 'ADMIN' | 'MEMBER';\n  Organization: Organization;\n};\ntype User = {\n  id: string;\n  memberships: Membership[];\n};\ntype Context = {\n  /**\n   * User is nullable\n   */\n  user: User | null;\n};\n \nconst t = initTRPC.context<Context>().create();\n \nexport const publicProcedure = t.procedure;\n \n// procedure that asserts that the user is logged in\nexport const authedProcedure = t.procedure.use(async function isAuthed(opts) {\n  const { ctx } = opts;\n  // `ctx.user` is nullable\n  if (!ctx.user) {\n            \n(property) user: User | null\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n \n  return opts.next({\n    ctx: {\n      // ✅ user value is known to be non-null now\n      user: ctx.user,\n    },\n  });\n});\n \n// procedure that a user is a member of a specific organization\nexport const organizationProcedure = authedProcedure\n  .input(z.object({ organizationId: z.string() }))\n  .use(function isMemberOfOrganization(opts) {\n    const membership = opts.ctx.user.memberships.find(\n      (m) => m.Organization.id === opts.input.organizationId,\n    );\n    if (!membership) {\n      throw new TRPCError({\n        code: 'FORBIDDEN',\n      });\n    }\n    return opts.next({\n      ctx: {\n        Organization: membership.Organization,\n      },\n    });\n  });\n \nexport const appRouter = t.router({\n  whoami: authedProcedure.query(async (opts) => {\n    // user is non-nullable here\n    const { ctx } = opts;\n            \nconst ctx: {\n    user: User;\n}\n    return ctx.user;\n  }),\n  addMember: organizationProcedure\n    .input(\n      z.object({\n        email: z.string().email(),\n      }),\n    )\n    .mutation((opts) => {\n      // ctx contains the non-nullable user & the organization being queried\n      const { ctx } = opts;\n              \nconst ctx: {\n    user: User;\n    Organization: Organization;\n}\n \n      // input includes the validated email of the user being invited & the validated organizationId\n      const { input } = opts;\n               \nconst input: {\n    organizationId: string;\n    email: string;\n}\n \n      return '...';\n    }),\n});\nCopy\nInferring the options type of a \"Base Procedure\"​\n\nIn addition to being able to infer the input and output types of a procedure, you can also infer the options type of a specific procedure builder (or base procedure) using inferProcedureBuilderResolverOptions.\n\nThis type helper is useful for declaring a type to a function's parameters. Like for example, separating the procedure's handler (main execution code) from its definition at the router, or for creating a helper function that works with multiple procedures.\n\nasync function getMembersOfOrganization(\n  opts: inferProcedureBuilderResolverOptions<typeof organizationProcedure>,\n) {\n  // input and ctx are now correctly typed!\n  const { ctx, input } = opts;\n \n  return await prisma.user.findMany({\n    where: {\n      membership: {\n        organizationId: ctx.Organization.id,\n      },\n    },\n  });\n}\nexport const appRouter = t.router({\n  listMembers: organizationProcedure.query(async (opts) => {\n    // use helper function!\n    const members = await getMembersOfOrganization(opts);\n \n    return members;\n  }),\n});\nCopy\nSubscriptions​\n\nFor information on subscriptions, see our subscriptions guide.\n\nEdit this page"
  },
  {
    "title": "Input & Output Validators | tRPC",
    "url": "https://trpc.io/docs/server/validators",
    "html": "Backend Usage\nInput & Output Validators\nVersion: 11.x\nInput & Output Validators\n\ntRPC procedures may define validation logic for their input and/or output, and validators are also used to infer the types of inputs and outputs (using the Standard Schema interface if available, or custom interfaces for supported validators if not). We have first class support for many popular validators, and you can integrate validators which we don't directly support.\n\nInput Validators​\n\nBy defining an input validator, tRPC can check that a procedure call is correct and return a validation error if not.\n\nTo set up an input validator, use the procedure.input() method:\n\n// Our examples use Zod by default, but usage with other libraries is identical\nimport { z } from 'zod';\n \nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\n \nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(\n      z.object({\n        name: z.string(),\n      }),\n    )\n    .query((opts) => {\n      const name = opts.input.name;\n             \nconst name: string\n      return {\n        greeting: `Hello ${opts.input.name}`,\n      };\n    }),\n});\nCopy\nInput Merging​\n\n.input() can be stacked to build more complex types, which is particularly useful when you want to utilise some common input to a collection of procedures in a middleware.\n\nconst baseProcedure = t.procedure\n  .input(z.object({ townName: z.string() }))\n  .use((opts) => {\n    const input = opts.input;\n           \nconst input: {\n    townName: string;\n}\n \n    console.log(`Handling request with user from: ${input.townName}`);\n \n    return opts.next();\n  });\n \nexport const appRouter = t.router({\n  hello: baseProcedure\n    .input(\n      z.object({\n        name: z.string(),\n      }),\n    )\n    .query((opts) => {\n      const input = opts.input;\n             \nconst input: {\n    townName: string;\n    name: string;\n}\n      return {\n        greeting: `Hello ${input.name}, my friend from ${input.townName}`,\n      };\n    }),\n});\nCopy\nOutput Validators​\n\nValidating outputs is not always as important as defining inputs, since tRPC gives you automatic type-safety by inferring the return type of your procedures. Some reasons to define an output validator include:\n\nChecking that data returned from untrusted sources is correct\nEnsure that you are not returning more data to the client than necessary\nINFO\n\nIf output validation fails, the server will respond with an INTERNAL_SERVER_ERROR.\n\nimport { z } from 'zod';\n \nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\n \nexport const appRouter = t.router({\n  hello: publicProcedure\n    .output(\n      z.object({\n        greeting: z.string(),\n      }),\n    )\n    .query((opts) => {\n      return {\n        gre,\n           \ngreeting\n      };\n    }),\n});\nCopy\nOutput validation of subscriptions​\n\nSince subscriptions are async iterators, you can use the same validation techniques as above.\n\nHave a look at the subscriptions guide for more information.\n\nThe most basic validator: a function​\n\nYou can define a validator without any 3rd party dependencies, with a function.\n\nINFO\n\nWe don't recommend making a custom validator unless you have a specific need, but it's important to understand that there's no magic here - it's just typescript!\n\nIn most cases we recommend you use a validation library\n\nimport { initTRPC } from '@trpc/server';\n \nexport const t = initTRPC.create();\n \nconst publicProcedure = t.procedure;\n \nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input((value): string => {\n      if (typeof value === 'string') {\n        return value;\n      }\n      throw new Error('Input is not a string');\n    })\n    .output((value): string => {\n      if (typeof value === 'string') {\n        return value;\n      }\n      throw new Error('Output is not a string');\n    })\n    .query((opts) => {\n      const { input } = opts;\n               \nconst input: string\n      return `hello ${input}`;\n    }),\n});\n \nexport type AppRouter = typeof appRouter;\nCopy\nLibrary integrations​\n\ntRPC works out of the box with a number of popular validation and parsing libraries, including any library conforming to Standard Schema. The below are some examples of usage with validators which we officially maintain support for.\n\nWith Zod​\n\nZod is our default recommendation, it has a strong ecosystem which makes it a great choice to use in multiple parts of your codebase. If you have no opinion of your own and want a powerful library which won't limit future needs, Zod is a great choice.\n\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n \nexport const t = initTRPC.create();\n \nconst publicProcedure = t.procedure;\n \nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(\n      z.object({\n        name: z.string(),\n      }),\n    )\n    .output(\n      z.object({\n        greeting: z.string(),\n      }),\n    )\n    .query(({ input }) => {\n               \n(parameter) input: {\n    name: string;\n}\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\n \nexport type AppRouter = typeof appRouter;\nCopy\nWith Yup​\nimport { initTRPC } from '@trpc/server';\nimport * as yup from 'yup';\n \nexport const t = initTRPC.create();\n \nconst publicProcedure = t.procedure;\n \nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(\n      yup.object({\n        name: yup.string().required(),\n      }),\n    )\n    .output(\n      yup.object({\n        greeting: yup.string().required(),\n      }),\n    )\n    .query(({ input }) => {\n               \n(parameter) input: {\n    name: string;\n}\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\n \nexport type AppRouter = typeof appRouter;\nCopy\nWith Superstruct​\nimport { initTRPC } from '@trpc/server';\nimport { object, string } from 'superstruct';\n \nexport const t = initTRPC.create();\n \nconst publicProcedure = t.procedure;\n \nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(object({ name: string() }))\n    .output(object({ greeting: string() }))\n    .query(({ input }) => {\n               \n(parameter) input: {\n    name: string;\n}\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\n \nexport type AppRouter = typeof appRouter;\nCopy\nWith scale-ts​\nimport { initTRPC } from '@trpc/server';\nimport * as $ from 'scale-codec';\n \nexport const t = initTRPC.create();\n \nconst publicProcedure = t.procedure;\n \nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input($.object($.field('name', $.str)))\n    .output($.object($.field('greeting', $.str)))\n    .query(({ input }) => {\n               \n(parameter) input: {\n    readonly name: string;\n}\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\n \nexport type AppRouter = typeof appRouter;\nCopy\nWith Typia​\nimport { initTRPC } from '@trpc/server';\nimport typia from 'typia';\nimport { v4 } from 'uuid';\nimport { IBbsArticle } from '../structures/IBbsArticle';\nconst t = initTRPC.create();\nconst publicProcedure = t.procedure;\nexport const appRouter = t.router({\n  store: publicProcedure\n    .input(typia.createAssert<IBbsArticle.IStore>())\n    .output(typia.createAssert<IBbsArticle>())\n    .query(({ input }) => {\n      return {\n        id: v4(),\n        writer: input.writer,\n        title: input.title,\n        body: input.body,\n        created_at: new Date().toString(),\n      };\n    }),\n});\nexport type AppRouter = typeof appRouter;\nCopy\nWith ArkType​\nimport { initTRPC } from '@trpc/server';\nimport { type } from 'arktype';\nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\nexport const appRouter = t.router({\n  hello: publicProcedure.input(type({ name: 'string' })).query((opts) => {\n    return {\n      greeting: `hello ${opts.input.name}`,\n    };\n  }),\n});\nexport type AppRouter = typeof appRouter;\nCopy\nWith effect​\nimport { initTRPC } from '@trpc/server';\nimport { Schema } from 'effect';\nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(Schema.standardSchemaV1(Schema.Struct({ name: Schema.String })))\n    .output(Schema.standardSchemaV1(Schema.Struct({ greeting: Schema.String })))\n    .query(({ input }) => {\n      //      ^?\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\nexport type AppRouter = typeof appRouter;\nCopy\nWith Valibot​\nimport { initTRPC } from '@trpc/server';\nimport * as v from 'valibot';\n \nexport const t = initTRPC.create();\n \nconst publicProcedure = t.procedure;\n \nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(v.object({ name: v.string() }))\n    .output(v.object({ greeting: v.string() }))\n    .query(({ input }) => {\n               \n(parameter) input: {\n    name: string;\n}\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\n \nexport type AppRouter = typeof appRouter;\nCopy\nWith @robolex/sure​\n\nYou're able to define your own Error types and error throwing function if necessary. As a convenience @robolex/sure provides sure/src/err.ts:\n\n// sure/src/err.ts\nexport const err = (schema) => (input) => {\n  const [good, result] = schema(input);\n  if (good) return result;\n  throw result;\n};\nCopy\nimport { err, object, string } from '@robolex/sure';\nimport { initTRPC } from '@trpc/server';\nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(\n      err(\n        object({\n          name: string,\n        }),\n      ),\n    )\n    .output(\n      err(\n        object({\n          greeting: string,\n        }),\n      ),\n    )\n    .query(({ input }) => {\n      //      ^?\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\nexport type AppRouter = typeof appRouter;\nCopy\nWith TypeBox​\nimport { Type } from '@sinclair/typebox';\nimport { initTRPC } from '@trpc/server';\nimport { wrap } from '@typeschema/typebox';\nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(wrap(Type.Object({ name: Type.String() })))\n    .output(wrap(Type.Object({ greeting: Type.String() })))\n    .query(({ input }) => {\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\nexport type AppRouter = typeof appRouter;\nCopy\nContributing your own Validator Library​\n\nIf you work on a validator library which supports tRPC usage, please feel free to open a PR for this page with equivalent usage to the other examples here, and a link to your docs.\n\nIntegration with tRPC in most cases is as simple as meeting one of several existing type interfaces. Conforming to Standard Schema is recommended, but in some cases we may accept a PR to add a new supported interface. Feel free to open an issue for discussion. You can check the existing supported interfaces and functions for parsing/validation in code.\n\nEdit this page"
  },
  {
    "title": "Non-JSON Content Types | tRPC",
    "url": "https://trpc.io/docs/server/non-json-content-types",
    "html": "Backend Usage\nNon-JSON Inputs (FormData, File, Blob)\nVersion: 11.x\nNon-JSON Content Types\n\nIn addition to JSON-serializable data, tRPC can use FormData, File, and other Binary types as procedure inputs\n\nClient Setup​\nINFO\n\nWhile tRPC natively supports several non-json serializable types, your client may need a little link configuration to support them depending on your setup.\n\nhttpLink supports non-json content types out the box, if you're only using this then your existing setup should work immediately\n\nimport { httpLink } from '@trpc/client';\ntrpc.createClient({\n  links: [\n    httpLink({\n      url: 'http://localhost:2022',\n    }),\n  ],\n});\nCopy\n\nHowever, not all links support these new content types, if you're using httpBatchLink or httpBatchStreamLink you will need to include a splitLink and check which link to use depending on the content\n\nimport {\n  httpBatchLink,\n  httpLink,\n  isNonJsonSerializable,\n  splitLink,\n} from '@trpc/client';\ntrpc.createClient({\n  links: [\n    splitLink({\n      condition: (op) => isNonJsonSerializable(op.input),\n      true: httpLink({\n        url,\n      }),\n      false: httpBatchLink({\n        url,\n      }),\n    }),\n  ],\n});\nCopy\n\nIf you are using transformer in your tRPC server, typescript requires that your tRPC client link defines transformer as well.\nUse this example as base:\n\nimport {\n  httpBatchLink,\n  httpLink,\n  isNonJsonSerializable,\n  splitLink,\n} from '@trpc/client';\nimport superjson from 'superjson';\ntrpc.createClient({\n  links: [\n    splitLink({\n      condition: (op) => isNonJsonSerializable(op.input),\n      true: httpLink({\n        url,\n        transformer: {\n          // request - convert data before sending to the tRPC server\n          serialize: (data) => data,\n          // response - convert the tRPC response before using it in client\n          deserialize: superjson.deserialize, // or your other transformer\n        },\n      }),\n      false: httpBatchLink({\n        url,\n        transformers: superjson, // or your other transformer\n      }),\n    }),\n  ],\n});\nCopy\nServer Usage​\nINFO\n\nWhen a request is handled by tRPC, it takes care of parsing the request body based on the Content-Type header of the request.\nIf you encounter errors like Failed to parse body as XXX, make sure that your server (e.g., Express, Next.js) isn't parsing the request body before tRPC handles it.\n\n// Example in express\n// incorrect\nconst app = express();\napp.use(express.json()); // this try to parse body before tRPC.\napp.post('/express/hello', (req,res) => {/* ... */ }); // normal express route handler\napp.use('/trpc', trpcExpress.createExpressMiddleware({ /* ... */}))// tRPC fails to parse body\n// correct\nconst app = express();\napp.use('/express', express.json()); // do it only in \"/express/*\" path\napp.post('/express/hello', (req,res) => {/* ... */ });\napp.use('/trpc', trpcExpress.createExpressMiddleware({ /* ... */}))// tRPC can parse body\nCopy\nFormData Input​\n\nFormData is natively supported, and for more advanced usage you could also combine this with a library like zod-form-data to validate inputs in a type-safe way.\n\nimport { z } from 'zod';\n \nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\n \nexport const appRouter = t.router({\n  hello: publicProcedure.input(z.instanceof(FormData)).mutation((opts) => {\n    const data = opts.input;\n           \nconst data: FormData\n    return {\n      greeting: `Hello ${data.get('name')}`,\n    };\n  }),\n});\nCopy\n\nFor a more advanced code sample you can see our example project here\n\nFile and other Binary Type Inputs​\n\ntRPC converts many octet content types to a ReadableStream which can be consumed in a procedure. Currently these are Blob Uint8Array and File.\n\nimport { octetInputParser } from '@trpc/server/http';\n \nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\n \nexport const appRouter = t.router({\n  upload: publicProcedure.input(octetInputParser).mutation((opts) => {\n    const data = opts.input;\n           \nconst data: ReadableStream<any>\n    return {\n      valid: true,\n    };\n  }),\n});\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/merging-routers",
    "html": "Backend Usage\nMerging Routers\nVersion: 11.x\nMerging Routers\n\nWriting all API-code in your code in the same file is not a great idea. It's easy to merge routers with other routers.\n\nDefining an inline sub-router​\n\nWhen you define an inline sub-router, you can represent your router as a plain object.\n\nIn the below example, nested1 and nested2 are equal:\n\nserver/_app.ts\nimport * as trpc from '@trpc/server';\nimport { publicProcedure, router } from './trpc';\n \nconst appRouter = router({\n  // Shorthand plain object for creating a sub-router\n  nested1: {\n    proc: publicProcedure.query(() => '...'),\n  },\n  // Equivalent of:\n  nested2: router({\n    proc : publicProcedure.query(() => '...'),\n  }),\n});\nCopy\nMerging with child routers​\nserver.ts\n// @filename: trpc.ts\nimport { initTRPC } from '@trpc/server';\nconst t = initTRPC.create();\n \n \n \nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n \n// @filename: routers/_app.ts\nimport { router } from '../trpc';\nimport { z } from 'zod';\n \nimport { userRouter } from './user';\nimport { postRouter } from './post';\n \nconst appRouter = router({\n  user: userRouter, // put procedures under \"user\" namespace\n  post: postRouter, // put procedures under \"post\" namespace\n});\n \n// You can then access the merged route with\n// http://localhost:3000/trpc/<NAMESPACE>.<PROCEDURE>\n \nexport type AppRouter = typeof appRouter;\n \n \n// @filename: routers/post.ts\nimport { router, publicProcedure } from '../trpc';\nimport { z } from 'zod';\nexport const postRouter = router({\n  create: publicProcedure\n    .input(\n      z.object({\n        title: z.string(),\n      }),\n    )\n    .mutation((opts) => {\n      const { input } = opts;\n               \nconst input: {\n    title: string;\n}\n      // [...]\n    }),\n  list: publicProcedure.query(() => {\n    // ...\n    return [];\n  }),\n});\n \n// @filename: routers/user.ts\nimport { router, publicProcedure } from '../trpc';\nimport { z } from 'zod';\nexport const userRouter = router({\n  list: publicProcedure.query(() => {\n    // [..]\n    return [];\n  }),\n});\n \nCopy\nMerging with t.mergeRouters​\n\nIf you prefer having all procedures flat in one single namespace, you can instead use t.mergeRouters\n\nserver.ts\n// @filename: trpc.ts\nimport { initTRPC } from '@trpc/server';\nconst t = initTRPC.create();\n \n \nexport const router = t.router;\nexport const publicProcedure = t.procedure;\nexport const mergeRouters = t.mergeRouters;\n \n// @filename: routers/_app.ts\nimport { router, publicProcedure, mergeRouters } from '../trpc';\nimport { z } from 'zod';\n \nimport { userRouter } from './user';\nimport { postRouter } from './post';\n \nconst appRouter = mergeRouters(userRouter, postRouter)\n \nexport type AppRouter = typeof appRouter;\n \n// @filename: routers/post.ts\nimport { router, publicProcedure } from '../trpc';\nimport { z } from 'zod';\nexport const postRouter = router({\n  postCreate: publicProcedure\n    .input(\n      z.object({\n        title: z.string(),\n      }),\n    )\n    .mutation((opts) => {\n      const { input } = opts;\n               \nconst input: {\n    title: string;\n}\n      // [...]\n    }),\n  postList: publicProcedure.query(() => {\n    // ...\n    return [];\n  }),\n});\n \n \n// @filename: routers/user.ts\nimport { router, publicProcedure } from '../trpc';\nimport { z } from 'zod';\nexport const userRouter = router({\n  userList: publicProcedure.query(() => {\n    // [..]\n    return [];\n  }),\n});\n \nCopy\nDynamically load routers​\n\nYou can use the lazy function to dynamically load your routers. This can be useful to reduce cold starts of your application.\n\nThere's no difference in how you use the router after it's been lazy loaded vs. how you use a normal router.\n\nExample code of lazy loading a router:\n\n// @filename: routers/_app.ts\nimport { lazy } from '@trpc/server';\nimport { router } from '../trpc';\n \nexport const appRouter = router({\n  // Option 1: Short-hand lazy load the greeting router if you have exactly 1 export and it is the router\n  greeting: lazy(() => import('./greeting.js')),\n  // Option 2: Alternative way to lazy load if you have more than 1 export\n  user: lazy(() => import('./user.js').then((m) => m.userRouter)),\n});\nexport type AppRouter = typeof appRouter;\n \n// ----------------------------------------------------\n// @filename: routers/greeting.ts\nimport { router, publicProcedure } from '../trpc';\nexport const greetingRouter = router({\n  hello: publicProcedure.query(() => 'world'),\n});\n \n// ----------------------------------------------------\n// @filename: routers/user.ts\nimport { router, publicProcedure } from '../trpc';\n \nexport const userRouter = router({\n  list: publicProcedure.query(() => ['John', 'Jane', 'Jim']),\n});\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/context",
    "html": "Backend Usage\nContext\nVersion: 11.x\nContext\n\nYour context holds data that all of your tRPC procedures will have access to, and is a great place to put things like database connections or authentication information.\n\nSetting up the context is done in 2 steps, defining the type during initialization and then creating the runtime context for each request.\n\nDefining the context type​\n\nWhen initializing tRPC using initTRPC, you should pipe .context<TContext>() to the initTRPC builder function before calling .create(). The type TContext can either be inferred from a function's return type or be explicitly defined.\n\nThis will make sure your context is properly typed in your procedures and middlewares.\n\nimport { initTRPC } from '@trpc/server';\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getSession } from 'next-auth/react';\n \nexport const createContext = async (opts: CreateNextContextOptions) => {\n  const session = await getSession({ req: opts.req });\n \n  return {\n    session,\n  };\n};\n \nexport type Context = Awaited<ReturnType<typeof createContext>>;\nconst t = initTRPC.context<Context>().create();\n \nt.procedure.use((opts) => {\n  opts.ctx;\n       \n(property) ctx: {\n    session: Session | null;\n}\n \n  return opts.next();\n});\nCopy\nCreating the context​\n\nThe createContext() function must be passed to the handler that is mounting your appRouter, which may be via HTTP, a server-side call or our server-side helpers.\n\ncreateContext() is called for each invocation of tRPC, so batched requests will share a context.\n\n// 1. HTTP request\nimport { createHTTPHandler } from '@trpc/server/adapters/standalone';\nimport { createContext } from './context';\nimport { appRouter } from './router';\nconst handler = createHTTPHandler({\n  router: appRouter,\n  createContext,\n});\nCopy\n// 2. Server-side call\nimport { createContext } from './context';\nimport { createCaller } from './router';\nconst caller = createCaller(await createContext());\nCopy\n// 3. servers-side helpers\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport { createContext } from './context';\nimport { appRouter } from './router';\nconst helpers = createServerSideHelpers({\n  router: appRouter,\n  ctx: await createContext(),\n});\nCopy\nExample code​\n// -------------------------------------------------\n// @filename: context.ts\n// -------------------------------------------------\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getSession } from 'next-auth/react';\n \n/**\n * Creates context for an incoming request\n * @see https://trpc.io/docs/v11/context\n */\nexport async function createContext(opts: CreateNextContextOptions) {\n  const session = await getSession({ req: opts.req });\n \n  return {\n    session,\n  };\n}\n \nexport type Context = Awaited<ReturnType<typeof createContext>>;\n \n// -------------------------------------------------\n// @filename: trpc.ts\n// -------------------------------------------------\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport { Context } from './context';\n \nconst t = initTRPC.context<Context>().create();\n \n \nexport const router = t.router;\n \n/**\n * Unprotected procedure\n */\nexport const publicProcedure = t.procedure;\n \n/**\n * Protected procedure\n */\nexport const protectedProcedure = t.procedure.use(function isAuthed(opts) {\n  if (!opts.ctx.session?.user?.email) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n    });\n  }\n  return opts.next({\n    ctx: {\n      // Infers the `session` as non-nullable\n      session: opts.ctx.session,\n    },\n  });\n});\nCopy\nInner and outer context​\n\nIn some scenarios it could make sense to split up your context into \"inner\" and \"outer\" functions.\n\nInner context is where you define context which doesn’t depend on the request, e.g. your database connection. You can use this function for integration testing or server-side helpers, where you don’t have a request object. Whatever is defined here will always be available in your procedures.\n\nOuter context is where you define context which depends on the request, e.g. for the user's session. Whatever is defined here is only available for procedures that are called via HTTP.\n\nExample for inner & outer context​\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getSessionFromCookie, type Session } from './auth';\n/**\n * Defines your inner context shape.\n * Add fields here that the inner context brings.\n */\ninterface CreateInnerContextOptions extends Partial<CreateNextContextOptions> {\n  session: Session | null;\n}\n/**\n * Inner context. Will always be available in your procedures, in contrast to the outer context.\n *\n * Also useful for:\n * - testing, so you don't have to mock Next.js' `req`/`res`\n * - tRPC's `createServerSideHelpers` where we don't have `req`/`res`\n *\n * @see https://trpc.io/docs/v11/context#inner-and-outer-context\n */\nexport async function createContextInner(opts?: CreateInnerContextOptions) {\n  return {\n    prisma,\n    session: opts.session,\n  };\n}\n/**\n * Outer context. Used in the routers and will e.g. bring `req` & `res` to the context as \"not `undefined`\".\n *\n * @see https://trpc.io/docs/v11/context#inner-and-outer-context\n */\nexport async function createContext(opts: CreateNextContextOptions) {\n  const session = getSessionFromCookie(opts.req);\n  const contextInner = await createContextInner({ session });\n  return {\n    ...contextInner,\n    req: opts.req,\n    res: opts.res,\n  };\n}\nexport type Context = Awaited<ReturnType<typeof createContextInner>>;\n// The usage in your router is the same as the example above.\nCopy\n\nIt is important to infer your Context from the inner context, as only what is defined there is really always available in your procedures.\n\nIf you don't want to check req or res for undefined in your procedures all the time, you could build a small reusable procedure for that:\n\nexport const apiProcedure = publicProcedure.use((opts) => {\n  if (!opts.ctx.req || !opts.ctx.res) {\n    throw new Error('You are missing `req` or `res` in your call.');\n  }\n  return opts.next({\n    ctx: {\n      // We overwrite the context with the truthy `req` & `res`, which will also overwrite the types used in your procedure.\n      req: opts.ctx.req,\n      res: opts.ctx.res,\n    },\n  });\n});\nCopy\nLimiting Batch Size​\n\nYou can use the context to limit the number of requests that can be batched together.\n\nimport { TRPCError } from '@trpc/server';\nimport type { CreateHTTPContextOptions } from '@trpc/server/adapters/standalone';\n \nconst MAX_BATCH_SIZE = 10;\n \n// Create a context that checks batch size\nexport async function createContext(opts: CreateHTTPContextOptions) {\n  if (opts.info.calls.length > MAX_BATCH_SIZE) {\n    throw new TRPCError({\n      code: 'TOO_MANY_REQUESTS',\n      message: `Batch size limit of ${MAX_BATCH_SIZE} exceeded`,\n    });\n  }\n  return {};\n}\nCopy\n\nThis context will throw a TOO_MANY_REQUESTS error if a client tries to batch more than 10 requests together. You can adjust the MAX_BATCH_SIZE constant to match your needs.\n\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/middlewares",
    "html": "Backend Usage\nMiddlewares\nVersion: 11.x\nMiddlewares\n\nYou are able to add middleware(s) to a procedure with the t.procedure.use() method. The middleware(s) will wrap the invocation of the procedure and must pass through its return value.\n\nAuthorization​\n\nIn the example below, any call to a adminProcedure will ensure that the user is an \"admin\" before executing.\n\nimport { TRPCError, initTRPC } from '@trpc/server';\n \ninterface Context {\n  user?: {\n    id: string;\n    isAdmin: boolean;\n    // [..]\n  };\n}\n \nconst t = initTRPC.context<Context>().create();\nexport const publicProcedure = t.procedure;\nexport const router = t.router;\n \nexport const adminProcedure = publicProcedure.use(async (opts) => {\n  const { ctx } = opts;\n  if (!ctx.user?.isAdmin) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n  return opts.next({\n    ctx: {\n      user: ctx.user,\n    },\n  });\n});\nCopy\nimport { adminProcedure, publicProcedure, router } from './trpc';\n \nconst adminRouter = router({\n  secretPlace: adminProcedure.query(() => 'a key'),\n});\n \nexport const appRouter = router({\n  foo: publicProcedure.query(() => 'bar'),\n  admin: adminRouter,\n});\nCopy\nTIP\n\nSee Error Handling to learn more about the TRPCError thrown in the above example.\n\nLogging​\n\nIn the example below timings for queries are logged automatically.\n\nexport const loggedProcedure = publicProcedure.use(async (opts) => {\n  const start = Date.now();\n \n  const result = await opts.next();\n \n  const durationMs = Date.now() - start;\n  const meta = { path: opts.path, type: opts.type, durationMs };\n \n  result.ok\n    ? console.log('OK request timing:', meta)\n    : console.error('Non-OK request timing', meta);\n \n  return result;\n});\nCopy\nimport { loggedProcedure, router } from './trpc';\n \nexport const appRouter = router({\n  foo: loggedProcedure.query(() => 'bar'),\n  abc: loggedProcedure.query(() => 'def'),\n});\nCopy\nContext Extension​\n\n\"Context Extension\" enables middlewares to dynamically add and override keys on a base procedure's context in a typesafe manner.\n\nBelow we have an example of a middleware that changes properties of a context, the changes are then available to all chained consumers, such as other middlewares and procedures:\n\ntype Context = {\n  // user is nullable\n  user?: {\n    id: string;\n  };\n};\n \nconst protectedProcedure = publicProcedure.use(async function isAuthed(opts) {\n  const { ctx } = opts;\n  // `ctx.user` is nullable\n  if (!ctx.user) {\n            \n(property) user: {\n    id: string;\n} | undefined\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n \n  return opts.next({\n    ctx: {\n      // ✅ user value is known to be non-null now\n      user: ctx.user,\n       \n(property) user: {\n    id: string;\n}\n    },\n  });\n});\n \nprotectedProcedure.query((opts) => {\n  const { ctx } = opts;\n  return ctx.user;\n         \nconst ctx: {\n    user: {\n        id: string;\n    };\n}\n});\nCopy\nUsing .concat() to create reusable middlewares and plugins​\nTIP\nCreating middlewares using t.middleware has the limitation that the Context type is tied to the Context type of the tRPC instance.\nCreating middlewares with experimental_standaloneMiddleware() has the limitation that you cannot define input parsers and similar tied to your module.\n\ntRPC has an API called .concat() which allows you to independently define a partial procedure that can be used with any tRPC instance that matches the context and metadata of the plugin.\n\nThis helper primarily targets creating plugins and libraries with tRPC.\n\n// ------------------------------------------------\n// 🧩🧩🧩 a library creating a reusable plugin 🧩🧩🧩\n// @filename: myPlugin.ts\n \nimport { initTRPC, TRPCError } from '@trpc/server';\n \nexport function createMyPlugin() {\n  // When creating a plugin for tRPC, you use the same API as creating any other tRPC-app\n  // this is the plugin's root `t`-object\n  const t = initTRPC\n    .context<{\n      // the procedure using the plugin will need to extend this context\n    }>()\n    .meta<{\n      // the base `initTRPC`-object of the application using this needs to extend this meta\n    }>()\n    .create();\n \n  return {\n    // you can also add `.input()` if you want your plugin to do input validation\n    pluginProc: t.procedure.use((opts) => {\n      return opts.next({\n        ctx: {\n          fromPlugin: 'hello from myPlugin' as const,\n        },\n      });\n    }),\n  };\n}\n// ------------------------------------\n// 🚀🚀🚀 the app using the plugin 🚀🚀🚀\n// @filename: app.ts\nimport { createMyPlugin } from './myPlugin';\nimport { initTRPC, TRPCError } from '@trpc/server';\n \n \n// the app's root `t`-object\nconst t = initTRPC\n  .context<{\n    // ...\n  }>()\n  .create();\n \n \nexport const publicProcedure = t.procedure;\nexport const router = t.router;\n \n// initialize the plugin (a real-world example would likely take options here)\nconst plugin = createMyPlugin();\n \n// create a base procedure using the plugin\nconst procedureWithPlugin = publicProcedure\n  .concat(\n    plugin.pluginProc,\n  )\n  .use(opts => {\n    const { ctx } = opts;\n            \nconst ctx: {\n    fromPlugin: \"hello from myPlugin\";\n}\n    return opts.next()\n  })\n \n \nexport const appRouter = router({\n  hello: procedureWithPlugin.query(opts => {\n    return opts.ctx.fromPlugin;\n  })\n})\nCopy\nExtending middlewares​\nINFO\n\nWe have prefixed this as unstable_ as it's a new API, but you're safe to use it! Read more.\n\nWe have a powerful feature called .pipe() which allows you to extend middlewares in a typesafe manner.\n\nBelow we have an example of a middleware that extends a base middleware(foo). Like the context extension example above, piping middlewares will change properties of the context, and procedures will receive the new context value.\n\nconst fooMiddleware = t.middleware((opts) => {\n  return opts.next({\n    ctx: {\n      foo: 'foo' as const,\n    },\n  });\n});\n \nconst barMiddleware = fooMiddleware.unstable_pipe((opts) => {\n  const { ctx } = opts;\n  ctx.foo;\n      \n(property) foo: \"foo\"\n  return opts.next({\n    ctx: {\n      bar: 'bar' as const,\n    },\n  });\n});\n \nconst barProcedure = publicProcedure.use(barMiddleware);\nbarProcedure.query((opts) => {\n  const { ctx } = opts;\n  return ctx.bar;\n         \nconst ctx: {\n    foo: \"foo\";\n    bar: \"bar\";\n}\n});\nCopy\n\nBeware that the order in which you pipe your middlewares matter and that the context must overlap. An example of a forbidden pipe is shown below. Here, the fooMiddleware overrides the ctx.a while barMiddleware still expects the root context from the initialization in initTRPC - so piping fooMiddleware with barMiddleware would not work, while piping barMiddleware with fooMiddleware does work.\n\nimport { initTRPC } from '@trpc/server';\n \nconst t = initTRPC\n  .context<{\n    a: {\n      b: 'a';\n    };\n  }>()\n  .create();\n \nconst fooMiddleware = t.middleware((opts) => {\n  const { ctx } = opts;\n  ctx.a; // 👈 fooMiddleware expects `ctx.a` to be an object\n     \n(property) a: {\n    b: \"a\";\n}\n  return opts.next({\n    ctx: {\n      a: 'a' as const, // 👈 `ctx.a` is no longer an object\n    },\n  });\n});\n \nconst barMiddleware = t.middleware((opts) => {\n  const { ctx } = opts;\n  ctx.a; // 👈 barMiddleware expects `ctx.a` to be an object\n     \n(property) a: {\n    b: \"a\";\n}\n  return opts.next({\n    ctx: {\n      foo: 'foo' as const,\n    },\n  });\n});\n \n// ❌ `ctx.a` does not overlap from `fooMiddleware` to `barMiddleware`\nfooMiddleware.unstable_pipe(barMiddleware);\n \n// ✅ `ctx.a` overlaps from `barMiddleware` and `fooMiddleware`\nbarMiddleware.unstable_pipe(fooMiddleware);\nCopy\nExperimental: standalone middlewares​\nINFO\n\nThis has been deprecated in favor of .concat()\n\ntRPC has an experimental API called experimental_standaloneMiddleware which allows you to independently define a middleware that can be used with any tRPC instance. Creating middlewares using t.middleware has the limitation that the Context type is tied to the Context type of the tRPC instance. This means that you cannot use the same middleware with multiple tRPC instances that have different Context types.\n\nUsing experimental_standaloneMiddleware you can create a middleware that explicitly defines its requirements, i.e. the Context, Input and Meta types:\n\nimport {\n  experimental_standaloneMiddleware,\n  initTRPC,\n  TRPCError,\n} from '@trpc/server';\nimport * as z from 'zod';\n \nconst projectAccessMiddleware = experimental_standaloneMiddleware<{\n  ctx: { allowedProjects: string[] }; // defaults to 'object' if not defined\n  input: { projectId: string }; // defaults to 'unknown' if not defined\n  // 'meta', not defined here, defaults to 'object | undefined'\n}>().create((opts) => {\n  if (!opts.ctx.allowedProjects.includes(opts.input.projectId)) {\n    throw new TRPCError({\n      code: 'FORBIDDEN',\n      message: 'Not allowed',\n    });\n  }\n \n  return opts.next();\n});\n \nconst t1 = initTRPC\n  .context<{\n    allowedProjects: string[];\n  }>()\n  .create();\n \n// ✅ `ctx.allowedProjects` satisfies \"string[]\" and `input.projectId` satisfies \"string\"\nconst accessControlledProcedure = t1.procedure\n  .input(z.object({ projectId: z.string() }))\n  .use(projectAccessMiddleware);\n \n// ❌ `ctx.allowedProjects` satisfies \"string[]\" but `input.projectId` does not satisfy \"string\"\nconst accessControlledProcedure2 = t1.procedure\n  .input(z.object({ projectId: z.number() }))\n  .use(projectAccessMiddleware);\n \n// ❌ `ctx.allowedProjects` does not satisfy \"string[]\" even though `input.projectId` satisfies \"string\"\nconst t2 = initTRPC\n  .context<{\n    allowedProjects: number[];\n  }>()\n  .create();\n \nconst accessControlledProcedure3 = t2.procedure\n  .input(z.object({ projectId: z.string() }))\n  .use(projectAccessMiddleware);\nCopy\n\nHere is an example with multiple standalone middlewares:\n\nimport { experimental_standaloneMiddleware, initTRPC } from '@trpc/server';\nimport * as z from 'zod';\n \nconst t = initTRPC.create();\nconst schemaA = z.object({ valueA: z.string() });\nconst schemaB = z.object({ valueB: z.string() });\n \nconst valueAUppercaserMiddleware = experimental_standaloneMiddleware<{\n  input: z.infer<typeof schemaA>;\n}>().create((opts) => {\n  return opts.next({\n    ctx: { valueAUppercase: opts.input.valueA.toUpperCase() },\n  });\n});\n \nconst valueBUppercaserMiddleware = experimental_standaloneMiddleware<{\n  input: z.infer<typeof schemaB>;\n}>().create((opts) => {\n  return opts.next({\n    ctx: { valueBUppercase: opts.input.valueB.toUpperCase() },\n  });\n});\n \nconst combinedInputThatSatisfiesBothMiddlewares = z.object({\n  valueA: z.string(),\n  valueB: z.string(),\n  extraProp: z.string(),\n});\n \nt.procedure\n  .input(combinedInputThatSatisfiesBothMiddlewares)\n  .use(valueAUppercaserMiddleware)\n  .use(valueBUppercaserMiddleware)\n  .query(\n    ({\n      input: { valueA, valueB, extraProp },\n      ctx: { valueAUppercase, valueBUppercase },\n    }) =>\n      `valueA: ${valueA}, valueB: ${valueB}, extraProp: ${extraProp}, valueAUppercase: ${valueAUppercase}, valueBUppercase: ${valueBUppercase}`,\n  );\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/adapters",
    "html": "Backend Usage\nHosting tRPC with Adapters\nVersion: 11.x\nAdapters\n\ntRPC is not a server on its own, and must therefore be served using other hosts, such as a simple Node.js HTTP Server, Express, or even Next.js. Most tRPC features are the same no matter which backend you choose. Adapters act as the glue between the host system and your tRPC API.\n\nAdapters typically follow some common conventions, allowing you to set up context creation via createContext, and globally handle errors via onError, but importantly allow you to choose an appropriate host for your application.\n\nWe support many modes of hosting an API, which you will find documented here.\n\nFor serverful APIs, you might want our Standalone adapter, or use the Express or Fastify adapters to hook into your existing APIs\nYou might want a serverless solution and choose AWS Lambda, or Fetch for edge runtimes\nYou might have a full-stack framework and want a full integration like Next.js, or you could use the Fetch adapter with Next.js, Astro, Remix, or SolidStart\nTIP\n\nFor local development or serverful infrastructure, the simplest Adapter to use is the Standalone Adapter, which can be used to run a standard Node.js HTTP Server. We recommend this when you need to get started quickly and have no existing HTTP Server to integrate with. Swapping out later is trivial if your needs change.\n\nEdit this page"
  },
  {
    "title": "Server Side Calls | tRPC",
    "url": "https://trpc.io/docs/server/server-side-calls",
    "html": "Backend Usage\nServer Side Calls\nVersion: 11.x\nServer Side Calls\n\nYou may need to call your procedure(s) directly from the same server they're hosted in, createCallerFactory() can be used to achieve this. This is useful for server-side calls and for integration testing of your tRPC procedures.\n\nINFO\n\ncreateCaller should not be used to call procedures from within other procedures. This creates overhead by (potentially) creating context again, executing all middlewares, and validating the input - all of which were already done by the current procedure. Instead, you should extract the shared logic into a separate function and call that from within the procedures, like so:\n\nCreate caller​\n\nWith the t.createCallerFactory-function you can create a server-side caller of any router. You first call createCallerFactory with an argument of the router you want to call, then this returns a function where you can pass in a Context for the following procedure calls.\n\nBasic example​\n\nWe create the router with a query to list posts and a mutation to add posts, and then we a call each method.\n\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n \ntype Context = {\n  foo: string;\n};\n \nconst t = initTRPC.context<Context>().create();\n \nconst publicProcedure = t.procedure;\nconst { createCallerFactory, router } = t;\n \ninterface Post {\n  id: string;\n  title: string;\n}\nconst posts: Post[] = [\n  {\n    id: '1',\n    title: 'Hello world',\n  },\n];\nconst appRouter = router({\n  post: router({\n    add: publicProcedure\n      .input(\n        z.object({\n          title: z.string().min(2),\n        }),\n      )\n      .mutation((opts) => {\n        const post: Post = {\n          ...opts.input,\n          id: `${Math.random()}`,\n        };\n        posts.push(post);\n        return post;\n      }),\n    list: publicProcedure.query(() => posts),\n  }),\n});\n \n// 1. create a caller-function for your router\nconst createCaller = createCallerFactory(appRouter);\n \n// 2. create a caller using your `Context`\nconst caller = createCaller({\n  foo: 'bar',\n});\n \n// 3. use the caller to add and list posts\nconst addedPost = await caller.post.add({\n  title: 'How to make server-side call in tRPC',\n});\n \nconst postList = await caller.post.list();\n         \nconst postList: Post[]\nCopy\nExample usage in an integration test​\n\nTaken from https://github.com/trpc/examples-next-prisma-starter/blob/main/src/server/routers/post.test.ts\n\nimport { inferProcedureInput } from '@trpc/server';\nimport { createContextInner } from '../context';\nimport { AppRouter, createCaller } from './_app';\ntest('add and get post', async () => {\n  const ctx = await createContextInner({});\n  const caller = createCaller(ctx);\n  const input: inferProcedureInput<AppRouter['post']['add']> = {\n    text: 'hello test',\n    title: 'hello test',\n  };\n  const post = await caller.post.add(input);\n  const byId = await caller.post.byId({ id: post.id });\n  expect(byId).toMatchObject(input);\n});\nCopy\nrouter.createCaller()​\n\nWith the router.createCaller({}) function (first argument is Context) we retrieve an instance of RouterCaller.\n\nInput query example​\n\nWe create the router with an input query, and then we call the asynchronous greeting procedure to get the result.\n\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n \nconst t = initTRPC.create();\n \nconst router = t.router({\n  // Create procedure at path 'greeting'\n  greeting: t.procedure\n    .input(z.object({ name: z.string() }))\n    .query((opts) => `Hello ${opts.input.name}`),\n});\n \nconst caller = router.createCaller({});\nconst result = await caller.greeting({ name: 'tRPC' });\n        \nconst result: string\nCopy\nMutation example​\n\nWe create the router with a mutation, and then we call the asynchronous post procedure to get the result.\n\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n \nconst posts = ['One', 'Two', 'Three'];\n \nconst t = initTRPC.create();\nconst router = t.router({\n  post: t.router({\n    add: t.procedure.input(z.string()).mutation((opts) => {\n      posts.push(opts.input);\n      return posts;\n    }),\n  }),\n});\n \nconst caller = router.createCaller({});\nconst result = await caller.post.add('Four');\n        \nconst result: string[]\nCopy\nContext with middleware example​\n\nWe create a middleware to check the context before executing the secret procedure. Below are two examples: the former fails because the context doesn't fit the middleware logic, and the latter works correctly.\n\n\n\nINFO\n\nMiddlewares are performed before any procedure(s) are called.\n\n\n\nimport { initTRPC, TRPCError } from '@trpc/server';\n \ntype Context = {\n  user?: {\n    id: string;\n  };\n};\nconst t = initTRPC.context<Context>().create();\n \nconst protectedProcedure = t.procedure.use((opts) => {\n  const { ctx } = opts;\n  if (!ctx.user) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'You are not authorized',\n    });\n  }\n \n  return opts.next({\n    ctx: {\n      // Infers that the `user` is non-nullable\n      user: ctx.user,\n    },\n  });\n});\n \nconst router = t.router({\n  secret: protectedProcedure.query((opts) => opts.ctx.user),\n});\n \n{\n  // ❌ this will return an error because there isn't the right context param\n  const caller = router.createCaller({});\n \n  const result = await caller.secret();\n}\n \n{\n  // ✅ this will work because user property is present inside context param\n  const authorizedCaller = router.createCaller({\n    user: {\n      id: 'KATT',\n    },\n  });\n  const result = await authorizedCaller.secret();\n          \nconst result: {\n    id: string;\n}\n}\nCopy\nExample for a Next.js API endpoint​\nTIP\n\nThis example shows how to use the caller in a Next.js API endpoint. tRPC creates API endpoints for you already, so this file is only meant to show how to call a procedure from another, custom endpoint.\n\nimport { TRPCError } from '@trpc/server';\nimport { getHTTPStatusCodeFromError } from '@trpc/server/http';\nimport { appRouter } from '~/server/routers/_app';\nimport type { NextApiRequest, NextApiResponse } from 'next';\n \ntype ResponseData = {\n  data?: {\n    postTitle: string;\n  };\n  error?: {\n    message: string;\n  };\n};\n \nexport default async (\n  req: NextApiRequest,\n  res: NextApiResponse<ResponseData>,\n) => {\n  /** We want to simulate an error, so we pick a post ID that does not exist in the database. */\n  const postId = `this-id-does-not-exist-${Math.random()}`;\n \n  const caller = appRouter.createCaller({});\n \n  try {\n    // the server-side call\n    const postResult = await caller.post.byId({ id: postId });\n \n    res.status(200).json({ data: { postTitle: postResult.title } });\n  } catch (cause) {\n    // If this a tRPC error, we can extract additional information.\n    if (cause instanceof TRPCError) {\n      // We can get the specific HTTP status code coming from tRPC (e.g. 404 for `NOT_FOUND`).\n      const httpStatusCode = getHTTPStatusCodeFromError(cause);\n \n      res.status(httpStatusCode).json({ error: { message: cause.message } });\n      return;\n    }\n \n    // This is not a tRPC error, so we don't have specific information.\n    res.status(500).json({\n      error: { message: `Error while accessing post with ID ${postId}` },\n    });\n  }\n};\nCopy\nError handling​\n\nThe createFactoryCaller and the createCaller function can take an error handler through the onError option. This can be used to throw errors that are not wrapped in a TRPCError, or respond to errors in some other way. Any handler passed to createCallerFactory will be called before the handler passed to createCaller. The handler is called with the same arguments as an error formatter would be, except for the shape field:\n\n{\n  ctx: unknown; // The request context\n  error: TRPCError; // The TRPCError that was thrown\n  path: string | undefined; // The path of the procedure that threw the error\n  input: unknown; // The input that was passed to the procedure\n  type: 'query' | 'mutation' | 'subscription' | 'unknown'; // The type of the procedure that threw the error\n}\nCopy\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n \nconst t = initTRPC\n  .context<{\n    foo?: 'bar';\n  }>()\n  .create();\n \nconst router = t.router({\n  greeting: t.procedure.input(z.object({ name: z.string() })).query((opts) => {\n    if (opts.input.name === 'invalid') {\n      throw new Error('Invalid name');\n    }\n \n    return `Hello ${opts.input.name}`;\n  }),\n});\n \nconst caller = router.createCaller(\n  {\n    /* context */\n  },\n  {\n    onError: (opts) => {\n      console.error('An error occurred:', opts.error);\n    },\n  },\n);\n \n// The following will log \"An error occurred: Error: Invalid name\", and then throw a plain error\n//  with the message \"This is a custom error\"\nawait caller.greeting({ name: 'invalid' });\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/authorization",
    "html": "Backend Usage\nAuthorization\nVersion: 11.x\nAuthorization\n\nThe createContext function is called for each incoming request, so here you can add contextual information about the calling user from the request object.\n\nCreate context from request headers​\nserver/context.ts\nimport * as trpcNext from '@trpc/server/adapters/next';\nimport { decodeAndVerifyJwtToken } from './somewhere/in/your/app/utils';\nexport async function createContext({\n  req,\n  res,\n}: trpcNext.CreateNextContextOptions) {\n  // Create your context based on the request object\n  // Will be available as `ctx` in all your resolvers\n  // This is just an example of something you might want to do in your ctx fn\n  async function getUserFromHeader() {\n    if (req.headers.authorization) {\n      const user = await decodeAndVerifyJwtToken(\n        req.headers.authorization.split(' ')[1],\n      );\n      return user;\n    }\n    return null;\n  }\n  const user = await getUserFromHeader();\n  return {\n    user,\n  };\n}\nexport type Context = Awaited<ReturnType<typeof createContext>>;\nCopy\nOption 1: Authorize using resolver​\nserver/routers/_app.ts\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport type { Context } from '../context';\nexport const t = initTRPC.context<Context>().create();\nconst appRouter = t.router({\n  // open for anyone\n  hello: t.procedure\n    .input(z.string().nullish())\n    .query((opts) => `hello ${opts.input ?? opts.ctx.user?.name ?? 'world'}`),\n  // checked in resolver\n  secret: t.procedure.query((opts) => {\n    if (!opts.ctx.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n    return {\n      secret: 'sauce',\n    };\n  }),\n});\nCopy\nOption 2: Authorize using middleware​\nserver/routers/_app.ts\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport type { Context } from '../context';\nexport const t = initTRPC.context<Context>().create();\n// you can reuse this for any procedure\nexport const protectedProcedure = t.procedure.use(\n  async function isAuthed(opts) {\n    const { ctx } = opts;\n    // `ctx.user` is nullable\n    if (!ctx.user) {\n      //     ^?\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n    return opts.next({\n      ctx: {\n        // ✅ user value is known to be non-null now\n        user: ctx.user,\n        // ^?\n      },\n    });\n  },\n);\nt.router({\n  // this is accessible for everyone\n  hello: t.procedure\n    .input(z.string().nullish())\n    .query((opts) => `hello ${opts.input ?? opts.ctx.user?.name ?? 'world'}`),\n  admin: t.router({\n    // this is accessible only to admins\n    secret: protectedProcedure.query((opts) => {\n      return {\n        secret: 'sauce',\n      };\n    }),\n  }),\n});\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/error-handling",
    "html": "Backend Usage\nError Handling\nVersion: 11.x\nError Handling\n\nWhenever an error occurs in a procedure, tRPC responds to the client with an object that includes an \"error\" property. This property contains all the information that you need to handle the error in the client.\n\nHere's an example error response caused by a bad request input:\n\n{\n  \"id\": null,\n  \"error\": {\n    \"message\": \"\\\"password\\\" must be at least 4 characters\",\n    \"code\": -32600,\n    \"data\": {\n      \"code\": \"BAD_REQUEST\",\n      \"httpStatus\": 400,\n      \"stack\": \"...\",\n      \"path\": \"user.changepassword\"\n    }\n  }\n}\nCopy\n\nNote: the returned stack trace is only available in the development environment.\n\nError codes​\n\ntRPC defines a list of error codes that each represent a different type of error and response with a different HTTP code.\n\nCode\tDescription\tHTTP code\nBAD_REQUEST\tThe server cannot or will not process the request due to something that is perceived to be a client error.\t400\nUNAUTHORIZED\tThe client request has not been completed because it lacks valid authentication credentials for the requested resource.\t401\nPAYMENT_REQUIRED\tThe client request requires payment to access the requested resource.\t402\nFORBIDDEN\tThe server was unauthorized to access a required data source, such as a REST API.\t403\nNOT_FOUND\tThe server cannot find the requested resource.\t404\nMETHOD_NOT_SUPPORTED\tThe server knows the request method, but the target resource doesn't support this method.\t405\nTIMEOUT\tThe server would like to shut down this unused connection.\t408\nCONFLICT\tThe server request resource conflict with the current state of the target resource.\t409\nPRECONDITION_FAILED\tAccess to the target resource has been denied.\t412\nPAYLOAD_TOO_LARGE\tRequest entity is larger than limits defined by server.\t413\nUNSUPPORTED_MEDIA_TYPE\tThe server refuses to accept the request because the payload format is in an unsupported format.\t415\nUNPROCESSABLE_CONTENT\tThe server understands the request method, and the request entity is correct, but the server was unable to process it.\t422\nPRECONDITION_REQUIRED\tThe server cannot process the request because a required precondition header (such as If-Match) is missing. When a precondition header does not match the server-side state, the response should be 412 Precondition Failed.\t428\nTOO_MANY_REQUESTS\tThe rate limit has been exceeded or too many requests are being sent to the server.\t429\nCLIENT_CLOSED_REQUEST\tAccess to the resource has been denied.\t499\nINTERNAL_SERVER_ERROR\tAn unspecified error occurred.\t500\nNOT_IMPLEMENTED\tThe server does not support the functionality required to fulfill the request.\t501\nBAD_GATEWAY\tThe server received an invalid response from the upstream server.\t502\nSERVICE_UNAVAILABLE\tThe server is not ready to handle the request.\t503\nGATEWAY_TIMEOUT\tThe server did not get a response in time from the upstream server that it needed in order to complete the request.\t504\n\ntRPC exposes a helper function, getHTTPStatusCodeFromError, to help you extract the HTTP code from the error:\n\nimport { getHTTPStatusCodeFromError } from '@trpc/server/http';\n \n// Example error you might get if your input validation fails\nconst error: TRPCError = {\n  name: 'TRPCError',\n  code: 'BAD_REQUEST',\n  message: '\"password\" must be at least 4 characters',\n};\n \nif (error instanceof TRPCError) {\n  const httpCode = getHTTPStatusCodeFromError(error);\n  console.log(httpCode); // 400\n}\nCopy\nTIP\n\nThere's a full example of how this could be used in a Next.js API endpoint in the Server Side Calls docs.\n\nThrowing errors​\n\ntRPC provides an error subclass, TRPCError, which you can use to represent an error that occurred inside a procedure.\n\nFor example, throwing this error:\n\nserver.ts\nimport { initTRPC, TRPCError } from '@trpc/server';\nconst t = initTRPC.create();\nconst appRouter = t.router({\n  hello: t.procedure.query(() => {\n    throw new TRPCError({\n      code: 'INTERNAL_SERVER_ERROR',\n      message: 'An unexpected error occurred, please try again later.',\n      // optional: pass the original error to retain stack trace\n      cause: theError,\n    });\n  }),\n});\n// [...]\nCopy\n\nResults to the following response:\n\n{\n  \"id\": null,\n  \"error\": {\n    \"message\": \"An unexpected error occurred, please try again later.\",\n    \"code\": -32603,\n    \"data\": {\n      \"code\": \"INTERNAL_SERVER_ERROR\",\n      \"httpStatus\": 500,\n      \"stack\": \"...\",\n      \"path\": \"hello\"\n    }\n  }\n}\nCopy\nHandling errors​\n\nAll errors that occur in a procedure go through the onError method before being sent to the client. Here you can handle errors (To change errors see error formatting).\n\npages/api/trpc/[trpc].ts\nexport default trpcNext.createNextApiHandler({\n  // ...\n  onError(opts) {\n    const { error, type, path, input, ctx, req } = opts;\n    console.error('Error:', error);\n    if (error.code === 'INTERNAL_SERVER_ERROR') {\n      // send to bug reporting\n    }\n  },\n});\nCopy\n\nThe onError parameter is an object that contains all information about the error and the context it occurs in:\n\n{\n  error: TRPCError; // the original error\n  type: 'query' | 'mutation' | 'subscription' | 'unknown';\n  path: string | undefined; // path of the procedure that was triggered\n  input: unknown;\n  ctx: Context | undefined;\n  req: BaseRequest; // request object\n}\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/error-formatting",
    "html": "Backend Usage\nError Formatting\nVersion: 11.x\nError Formatting\n\nThe error formatting in your router will be inferred all the way to your client (& React components)\n\nUsage example highlighted​\nAdding custom formatting​\nserver.ts\nimport { initTRPC } from '@trpc/server';\nexport const t = initTRPC.context<Context>().create({\n  errorFormatter(opts) {\n    const { shape, error } = opts;\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.code === 'BAD_REQUEST' && error.cause instanceof ZodError\n            ? error.cause.flatten()\n            : null,\n      },\n    };\n  },\n});\nCopy\nUsage in React​\ncomponents/MyComponent.tsx\nexport function MyComponent() {\n  const mutation = trpc.addPost.useMutation();\n  useEffect(() => {\n    mutation.mutate({ title: 'example' });\n  }, []);\n  if (mutation.error?.data?.zodError) {\n    // zodError will be inferred\n    return (\n      <pre>Error: {JSON.stringify(mutation.error.data.zodError, null, 2)}</pre>\n    );\n  }\n  return <>[...]</>;\n}\nCopy\nAll properties sent to errorFormatter()​\n\nSince v8.x tRPC is compliant with JSON-RPC 2.0\n\n{\n  error: TRPCError;\n  type: ProcedureType | 'unknown';\n  path: string | undefined;\n  input: unknown;\n  ctx: undefined | TContext;\n  shape: DefaultErrorShape; // the default error shape\n}\nCopy\n\nDefaultErrorShape:\n\ntype DefaultErrorData = {\n  code: TRPC_ERROR_CODE_KEY;\n  httpStatus: number;\n  /**\n   * Path to the procedure that threw the error\n   */\n  path?: string;\n  /**\n   * Stack trace of the error (only in development)\n   */\n  stack?: string;\n};\ninterface DefaultErrorShape {\n  message: string;\n  code: TRPC_ERROR_CODE_NUMBER;\n  data: DefaultErrorData;\n}\nCopy\nEdit this page"
  },
  {
    "title": "Data Transformers | tRPC",
    "url": "https://trpc.io/docs/server/data-transformers",
    "html": "Backend Usage\nData Transformers\nVersion: 11.x\nData Transformers\n\nYou are able to serialize the response data & input args. The transformers need to be added both to the server and the client.\n\nUsing superjson​\n\nSuperJSON allows us to transparently use, e.g., standard Date/Map/Sets over the wire between the server and client. That is, you can return any of these types from your API-resolver and use them in the client without having to recreate the objects from JSON.\n\nHow to​\n1. Install​\nyarn add superjson\nCopy\n2. Add to your initTRPC​\nrouters/router/_app.ts\nimport { initTRPC } from '@trpc/server';\nimport superjson from 'superjson';\nexport const t = initTRPC.create({\n  transformer: superjson,\n});\nCopy\n3. Add to httpLink(), wsLink(), etc​\n\nTypeScript will guide you to where you need to add transformer as soon as you've added it on the initTRPC-object\n\ncreateTRPCClient():\n\nsrc/app/_trpc/client.ts\nimport { createTRPCClient } from '@trpc/client';\nimport type { AppRouter } from '~/server/routers/_app';\nimport superjson from 'superjson';\nexport const client = createTRPCClient<AppRouter>({\n  links: [\n    httpLink({\n      url: 'http://localhost:3000',\n      transformer: superjson,\n    }),\n  ],\n});\nCopy\nUsing devalue​\n\nDevalue works like superjson, but focus in performance and compact payloads, but at the cost of a less human readable body.\n\nHow to​\n1. Install​\nyarn add superjson devalue\nCopy\n2. Add to utils/trpc.ts​\n\nHere we use parse and stringify as they mitigate XSS.\n\nutils/trpc.ts\nimport { parse, stringify } from 'devalue';\n// [...]\nexport const transformer = {\n  deserialize: (object: any) => parse(object),\n  serialize: (object: any) => stringify(object),\n};\nCopy\n3. Add to your initTRPC​\nserver/routers/_app.ts\nimport { initTRPC } from '@trpc/server';\nimport { transformer } from '../../utils/trpc';\nexport const t = initTRPC.create({\n  transformer,\n});\nCopy\n4. Add to httpLink(), wsLink(), etc​\n\nTypeScript will guide you to where you need to add transformer as soon as you've added it on the initTRPC-object\n\ncreateTRPCClient():\n\nsrc/app/_trpc/client.ts\nimport { createTRPCClient } from '@trpc/client';\nimport type { AppRouter } from '~/server/routers/_app';\nimport { transformer } from '../../utils/trpc';\nexport const client = createTRPCClient<AppRouter>({\n  links: [\n    httpLink({\n      url: 'http://localhost:3000',\n      transformer,\n    }),\n  ],\n});\nCopy\nDifferent transformers for upload and download​\n\nIf a transformer should only be used for one direction or different transformers should be used for upload and download (e.g., for performance reasons), you can provide individual transformers for upload and download. Make sure you use the same combined transformer everywhere.\n\nDataTransformer interface​\nexport interface DataTransformer {\n  serialize(object: any): any;\n  deserialize(object: any): any;\n}\ninterface InputDataTransformer extends DataTransformer {\n  /**\n   * This function runs **on the client** before sending the data to the server.\n   */\n  serialize(object: any): any;\n  /**\n   * This function runs **on the server** to transform the data before it is passed to the resolver\n   */\n  deserialize(object: any): any;\n}\ninterface OutputDataTransformer extends DataTransformer {\n  /**\n   * This function runs **on the server** before sending the data to the client.\n   */\n  serialize(object: any): any;\n  /**\n   * This function runs **only on the client** to transform the data sent from the server.\n   */\n  deserialize(object: any): any;\n}\nexport interface CombinedDataTransformer {\n  /**\n   * Specify how the data sent from the client to the server should be transformed.\n   */\n  input: InputDataTransformer;\n  /**\n   * Specify how the data sent from the server to the client should be transformed.\n   */\n  output: OutputDataTransformer;\n}\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/metadata",
    "html": "Backend Usage\nMetadata\nVersion: 11.x\nMetadata\n\nProcedure metadata allows you to add an optional procedure specific meta property which will be available in all middleware function parameters.\n\nTIP\n\nUse metadata together with trpc-openapi if you want to expose REST-compatible endpoints for your application.\n\nCreate router with typed metadata​\nimport { initTRPC } from '@trpc/server';\n// [...]\ninterface Meta {\n  authRequired: boolean;\n}\nexport const t = initTRPC.context<Context>().meta<Meta>().create();\nexport const appRouter = t.router({\n  // [...]\n});\nCopy\nExample with per route authentication settings​\nserver.ts\nimport { initTRPC } from '@trpc/server';\n// [...]\ninterface Meta {\n  authRequired: boolean;\n}\nexport const t = initTRPC.context<Context>().meta<Meta>().create();\nexport const authedProcedure = t.procedure.use(async (opts) => {\n  const { meta, next, ctx } = opts;\n  // only check authorization if enabled\n  if (meta?.authRequired && !ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n  return next();\n});\nexport const appRouter = t.router({\n  hello: authedProcedure.meta({ authRequired: false }).query(() => {\n    return {\n      greeting: 'hello world',\n    };\n  }),\n  protectedHello: authedProcedure.meta({ authRequired: true }).query(() => {\n    return {\n      greeting: 'hello-world',\n    };\n  }),\n});\nCopy\nDefault meta, chaining, and shallow merging​\n\nYou can set default values for your meta type, and if you chain meta on top of a base procedure it will be shallow merged.\n\nimport { initTRPC } from '@trpc/server';\ninterface Meta {\n  authRequired: boolean;\n  role?: 'user' | 'admin'\n}\nexport const t = initTRPC\n  .context<Context>()\n  .meta<Meta>()\n  .create({\n    // Set a default value\n    defaultMeta: { authRequired: false }\n  });\nconst publicProcedure = t.procedure\n// ^ Default Meta: { authRequired: false }\nconst authProcedure = publicProcedure\n  .use(authMiddleware)\n  .meta({\n    authRequired: true;\n    role: 'user'\n  });\n// ^ Meta: { authRequired: true, role: 'user' }\nconst adminProcedure = authProcedure\n  .meta({\n    role: 'admin'\n  });\n// ^ Meta: { authRequired: true, role: 'admin' }\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/caching",
    "html": "Backend Usage\nResponse Caching\nVersion: 11.x\nResponse Caching\n\nThe below examples uses Vercel's edge caching to serve data to your users as fast as possible.\n\nINFO\n\nAlways be careful with caching - especially if you handle personal information.\n\n \nSince batching is enabled by default, it's recommended to set your cache headers in the responseMeta function and make sure that there are not any concurrent calls that may include personal data - or to omit cache headers completely if there is an auth header or cookie.\n\n \nYou can also use a splitLink to split your public requests and those that should be private and uncached.\n\nApp Caching​\n\nIf you turn on SSR in your app, you might discover that your app loads slowly on, for instance, Vercel, but you can actually statically render your whole app without using SSG; read this Twitter thread for more insights.\n\nExample code​\nutils/trpc.tsx\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport type { AppRouter } from '../server/routers/_app';\nexport const trpc = createTRPCNext<AppRouter>({\n  config(config) {\n    if (typeof window !== 'undefined') {\n      return {\n        links: [\n          httpBatchLink({\n            url: '/api/trpc',\n          }),\n        ],\n      };\n    }\n    const url = process.env.VERCEL_URL\n      ? `https://${process.env.VERCEL_URL}/api/trpc`\n      : 'http://localhost:3000/api/trpc';\n    return {\n      links: {\n        http: httpBatchLink({\n          url,\n        }),\n      },\n    };\n  },\n  ssr: true,\n  responseMeta(opts) {\n    const { clientErrors } = opts;\n    if (clientErrors.length) {\n      // propagate http first error from API calls\n      return {\n        status: clientErrors[0].data?.httpStatus ?? 500,\n      };\n    }\n    // cache request for 1 day + revalidate once every second\n    const ONE_DAY_IN_SECONDS = 60 * 60 * 24;\n    return {\n      headers: new Headers([\n        [\n          'cache-control',\n          `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,\n        ],\n      ]),\n    };\n  },\n});\nCopy\nAPI Response caching​\n\nSince all queries are normal HTTP GETs, we can use normal HTTP headers to cache responses, make the responses snappy, give your database a rest, and easily scale your API to gazillions of users.\n\nUsing responseMeta to cache responses​\n\nAssuming you're deploying your API somewhere that can handle stale-while-revalidate cache headers like Vercel.\n\nserver.ts\nimport { initTRPC } from '@trpc/server';\nimport * as trpcNext from '@trpc/server/adapters/next';\nexport const createContext = async ({\n  req,\n  res,\n}: trpcNext.CreateNextContextOptions) => {\n  return {\n    req,\n    res,\n    prisma,\n  };\n};\ntype Context = Awaited<ReturnType<typeof createContext>>;\nexport const t = initTRPC.context<Context>().create();\nconst waitFor = async (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\nexport const appRouter = t.router({\n  public: t.router({\n    slowQueryCached: t.procedure.query(async (opts) => {\n      await waitFor(5000); // wait for 5s\n      return {\n        lastUpdated: new Date().toJSON(),\n      };\n    }),\n  }),\n});\n// Exporting type _type_ AppRouter only exposes types that can be used for inference\n// https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export\nexport type AppRouter = typeof appRouter;\n// export API handler\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  responseMeta(opts) {\n    const { ctx, paths, errors, type } = opts;\n    // assuming you have all your public routes with the keyword `public` in them\n    const allPublic = paths && paths.every((path) => path.includes('public'));\n    // checking that no procedures errored\n    const allOk = errors.length === 0;\n    // checking we're doing a query request\n    const isQuery = type === 'query';\n    if (ctx?.res && allPublic && allOk && isQuery) {\n      // cache request for 1 day + revalidate once every second\n      const ONE_DAY_IN_SECONDS = 60 * 60 * 24;\n      return {\n        headers: new Headers([\n          [\n            'cache-control',\n            `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,\n          ],\n        ]),\n      };\n    }\n    return {};\n  },\n});\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/subscriptions",
    "html": "Backend Usage\nSubscriptions\nVersion: 11.x\nSubscriptions\nIntroduction​\n\nSubscriptions are a type of real-time event stream between the client and server. Use subscriptions when you need to push real-time updates to the client.\n\nWith tRPC's subscriptions, the client establishes and maintains a persistent connection to the server plus automatically attempts to reconnect and recover gracefully if disconnected with the help of tracked() events.\n\nWebSockets or Server-sent Events?​\n\nYou can either use WebSockets or Server-sent Events (SSE) to setup real-time subscriptions in tRPC.\n\nFor WebSockets, see the WebSockets page\nFor SSE, see the httpSubscriptionLink\n\nIf you are unsure which one to use, we recommend using SSE for subscriptions as it's easier to setup and don't require setting up a WebSocket server.\n\nReference projects​\nType\tExample Type\tLink\nWebSockets\tBare-minimum Node.js WebSockets example\t/examples/standalone-server\nSSE\tFull-stack SSE implementation\tgithub.com/trpc/examples-next-sse-chat\nWebSockets\tFull-stack WebSockets implementation\tgithub.com/trpc/examples-next-prisma-websockets-starter\nBasic example​\nTIP\n\nFor a full example, see our full-stack SSE example.\n\nserver.ts\nimport { initTRPC } from '@trpc/server';\nconst t = initTRPC.create();\nconst ee = new EventEmitter();\nexport const appRouter = router({\n  onPostAdd: publicProcedure.subscription(async function* (opts) {\n    // listen for new events\n    for await (const [data] of on(ee, 'add', {\n      // Passing the AbortSignal from the request automatically cancels the event emitter when the request is aborted\n      signal: opts.signal,\n    })) {\n      const post = data as Post;\n      yield post;\n    }\n  }),\n});\nCopy\nAutomatic tracking of id using tracked() (recommended)​\n\nIf you yield an event using our tracked()-helper and include an id, the client will automatically reconnect when it gets disconnected and send the last known ID.\n\nYou can send an initial lastEventId when initializing the subscription and it will be automatically updated as the browser receives data.\n\nFor SSE, this is part of the EventSource-spec and will be propagated through lastEventId in your .input().\nFor WebSockets, our wsLink will automatically send the last known ID and update it as the browser receives data.\nTIP\n\nIf you're fetching data based on the lastEventId, and capturing all events is critical, make sure you setup the event listener before fetching events from your database as is done in our full-stack SSE example, this can prevent newly emitted events being ignored while yield'ing the original batch based on lastEventId.\n\nimport EventEmitter, { on } from 'events';\nimport type { Post } from '@prisma/client';\nimport { tracked } from '@trpc/server';\nimport { z } from 'zod';\nimport { publicProcedure, router } from '../trpc';\nconst ee = new EventEmitter();\nexport const subRouter = router({\n  onPostAdd: publicProcedure\n    .input(\n      z\n        .object({\n          // lastEventId is the last event id that the client has received\n          // On the first call, it will be whatever was passed in the initial setup\n          // If the client reconnects, it will be the last event id that the client received\n          lastEventId: z.string().nullish(),\n        })\n        .optional(),\n    )\n    .subscription(async function* (opts) {\n      // We start by subscribing to the ee so that we don't miss any new events while fetching\n      const iterable = ee.toIterable('add', {\n        // Passing the AbortSignal from the request automatically cancels the event emitter when the request is aborted\n        signal: opts.signal,\n      });\n      if (opts.input.lastEventId) {\n        // [...] get the posts since the last event id and yield them\n        // const items = await db.post.findMany({ ... })\n        // for (const item of items) {\n        //   yield tracked(item.id, item);\n        // }\n      }\n      // listen for new events\n      for await (const [data] of on(ee, 'add', {\n        signal: opts.signal,\n      })) {\n        const post = data as Post;\n        // tracking the post id ensures the client can reconnect at any time and get the latest events this id\n        yield tracked(post.id, post);\n      }\n    }),\n});\nCopy\nPull data in a loop​\n\nThis recipe is useful when you want to periodically check for new data from a source like a database and push it to the client.\n\nserver.ts\nimport type { Post } from '@prisma/client';\nimport { tracked } from '@trpc/server';\nimport { z } from 'zod';\nimport { publicProcedure, router } from '../trpc';\nexport const subRouter = router({\n  onPostAdd: publicProcedure\n    .input(\n      z.object({\n        // lastEventId is the last event id that the client has received\n        // On the first call, it will be whatever was passed in the initial setup\n        // If the client reconnects, it will be the last event id that the client received\n        // The id is the createdAt of the post\n        lastEventId: z.coerce.date().nullish(),\n      }),\n    )\n    .subscription(async function* (opts) {\n      // `opts.signal` is an AbortSignal that will be aborted when the client disconnects.\n      let lastEventId = opts.input?.lastEventId ?? null;\n      // We use a `while` loop that checks `!opts.signal.aborted`\n      while (!opts.signal!.aborted) {\n        const posts = await db.post.findMany({\n          // If we have a `lastEventId`, we only fetch posts created after it.\n          where: lastEventId\n            ? {\n                createdAt: {\n                  gt: lastEventId,\n                },\n              }\n            : undefined,\n          orderBy: {\n            createdAt: 'asc',\n          },\n        });\n        for (const post of posts) {\n          // `tracked` is a helper that sends an `id` with each event.\n          // This allows the client to resume from the last received event upon reconnection.\n          yield tracked(post.createdAt.toJSON(), post);\n          lastEventId = post.createdAt;\n        }\n        // Wait for a bit before polling again to avoid hammering the database.\n        await sleep(1_000);\n      }\n    }),\n});\nCopy\nStopping a subscription from the server​\n\nIf you need to stop a subscription from the server, simply return in the generator function.\n\nimport { publicProcedure, router } from '../trpc';\nexport const subRouter = router({\n  onPostAdd: publicProcedure\n    .input(\n      z.object({\n        lastEventId: z.string().coerce.number().min(0).optional(),\n      }),\n    )\n    .subscription(async function* (opts) {\n      let index = opts.input.lastEventId ?? 0;\n      while (!opts.signal!.aborted) {\n        const idx = index++;\n        if (idx > 100) {\n          // With this, the subscription will stop and the client will disconnect\n          return;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 10));\n      }\n    }\n  }),\n});\nCopy\n\nOn the client, you just .unsubscribe() the subscription.\n\nCleanup of side effects​\n\nIf you need to clean up any side-effects of your subscription you can use the try...finally pattern, as trpc invokes the .return() of the Generator Instance when the subscription stops for any reason.\n\nimport EventEmitter, { on } from 'events';\nimport type { Post } from '@prisma/client';\nimport { z } from 'zod';\nimport { publicProcedure, router } from '../trpc';\nconst ee = new EventEmitter();\nexport const subRouter = router({\n  onPostAdd: publicProcedure.subscription(async function* (opts) {\n    let timeout;\n    try {\n      for await (const [data] of on(ee, 'add', {\n        signal: opts.signal,\n      })) {\n        timeout = setTimeout(() => console.log('Pretend like this is useful'));\n        const post = data as Post;\n        yield post;\n      }\n    } finally {\n      if (timeout) clearTimeout(timeout);\n    }\n  }),\n});\nCopy\nError handling​\n\nThrowing an error in a generator function propagates to trpc's onError() on the backend.\n\nIf the error thrown is a 5xx error, the client will automatically attempt to reconnect based on the last event id that is tracked using tracked(). For other errors, the subscription will be cancelled and propagate to the onError() callback.\n\nOutput validation​\n\nSince subscriptions are async iterators, you have to go through the iterator to validate the output.\n\nExample with zod​\nzAsyncIterable.ts\nimport type { TrackedEnvelope } from '@trpc/server';\nimport { isTrackedEnvelope, tracked } from '@trpc/server';\nimport { z } from 'zod';\nfunction isAsyncIterable<TValue, TReturn = unknown>(\n  value: unknown,\n): value is AsyncIterable<TValue, TReturn> {\n  return !!value && typeof value === 'object' && Symbol.asyncIterator in value;\n}\nconst trackedEnvelopeSchema =\n  z.custom<TrackedEnvelope<unknown>>(isTrackedEnvelope);\n/**\n * A Zod schema helper designed specifically for validating async iterables. This schema ensures that:\n * 1. The value being validated is an async iterable.\n * 2. Each item yielded by the async iterable conforms to a specified type.\n * 3. The return value of the async iterable, if any, also conforms to a specified type.\n */\nexport function zAsyncIterable<\n  TYieldIn,\n  TYieldOut,\n  TReturnIn = void,\n  TReturnOut = void,\n  Tracked extends boolean = false,\n>(opts: {\n  /**\n   * Validate the value yielded by the async generator\n   */\n  yield: z.ZodType<TYieldIn, any, TYieldOut>;\n  /**\n   * Validate the return value of the async generator\n   * @remark not applicable for subscriptions\n   */\n  return?: z.ZodType<TReturnIn, any, TReturnOut>;\n  /**\n   * Whether if the yielded values are tracked\n   * @remark only applicable for subscriptions\n   */\n  tracked?: Tracked;\n}) {\n  return z\n    .custom<\n      AsyncIterable<\n        Tracked extends true ? TrackedEnvelope<TYieldIn> : TYieldIn,\n        TReturnIn\n      >\n    >((val) => isAsyncIterable(val))\n    .transform(async function* (iter) {\n      const iterator = iter[Symbol.asyncIterator]();\n      try {\n        let next;\n        while ((next = await iterator.next()) && !next.done) {\n          if (opts.tracked) {\n            const [id, data] = trackedEnvelopeSchema.parse(next.value);\n            yield tracked(id, await opts.yield.parseAsync(data));\n            continue;\n          }\n          yield opts.yield.parseAsync(next.value);\n        }\n        if (opts.return) {\n          return await opts.return.parseAsync(next.value);\n        }\n        return;\n      } finally {\n        await iterator.return?.();\n      }\n    }) as z.ZodType<\n    AsyncIterable<\n      Tracked extends true ? TrackedEnvelope<TYieldIn> : TYieldIn,\n      TReturnIn,\n      unknown\n    >,\n    any,\n    AsyncIterable<\n      Tracked extends true ? TrackedEnvelope<TYieldOut> : TYieldOut,\n      TReturnOut,\n      unknown\n    >\n  >;\n}\nCopy\n\nNow you can use this helper to validate the output of your subscription procedures:\n\n_app.ts\nimport { publicProcedure, router } from '../trpc';\nimport { zAsyncIterable } from './zAsyncIterable';\nexport const appRouter = router({\n  mySubscription: publicProcedure\n    .input(\n      z.object({\n        lastEventId: z.coerce.number().min(0).optional(),\n      }),\n    )\n    .output(\n      zAsyncIterable({\n        yield: z.object({\n          count: z.number(),\n        }),\n        tracked: true,\n      }),\n    )\n    .subscription(async function* (opts) {\n      let index = opts.input.lastEventId ?? 0;\n      while (true) {\n        index++;\n        yield tracked(index, {\n          count: index,\n        });\n        await new Promise((resolve) => setTimeout(resolve, 1000));\n      }\n    }),\n});\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/websockets",
    "html": "Backend Usage\nWebSockets\nVersion: 11.x\nWebSockets\n\nYou can use WebSockets for all or some of the communication with your server, see wsLink for how to set it up on the client.\n\nTIP\n\nThe document here outlines the specific details of using WebSockets. For general usage of subscriptions, see our subscriptions guide.\n\nCreating a WebSocket-server​\nyarn add ws\nCopy\nserver/wsServer.ts\nimport { applyWSSHandler } from '@trpc/server/adapters/ws';\nimport ws from 'ws';\nimport { appRouter } from './routers/app';\nimport { createContext } from './trpc';\nconst wss = new ws.Server({\n  port: 3001,\n});\nconst handler = applyWSSHandler({\n  wss,\n  router: appRouter,\n  createContext,\n  // Enable heartbeat messages to keep connection open (disabled by default)\n  keepAlive: {\n    enabled: true,\n    // server ping message interval in milliseconds\n    pingMs: 30000,\n    // connection is terminated if pong message is not received in this many milliseconds\n    pongWaitMs: 5000,\n  },\n});\nwss.on('connection', (ws) => {\n  console.log(`➕➕ Connection (${wss.clients.size})`);\n  ws.once('close', () => {\n    console.log(`➖➖ Connection (${wss.clients.size})`);\n  });\n});\nconsole.log('✅ WebSocket Server listening on ws://localhost:3001');\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM');\n  handler.broadcastReconnectNotification();\n  wss.close();\n});\nCopy\nSetting TRPCClient to use WebSockets​\nTIP\n\nYou can use Links to route queries and/or mutations to HTTP transport and subscriptions over WebSockets.\n\nclient.ts\nimport { createTRPCClient, createWSClient, wsLink } from '@trpc/client';\nimport type { AppRouter } from '../path/to/server/trpc';\n// create persistent WebSocket connection\nconst wsClient = createWSClient({\n  url: `ws://localhost:3001`,\n});\n// configure TRPCClient to use WebSockets transport\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    wsLink({\n      client: wsClient,\n    }),\n  ],\n});\nCopy\nAuthentication / connection params​\nTIP\n\nIf you're doing a web application, you can ignore this section as the cookies are sent as part of the request.\n\nIn order to authenticate with WebSockets, you can define connectionParams to createWSClient. This will be sent as the first message when the client establishes a WebSocket connection.\n\nserver/context.ts\nimport type { CreateWSSContextFnOptions } from '@trpc/server/adapters/ws';\n \nexport const createContext = async (opts: CreateWSSContextFnOptions) => {\n  const token = opts.info.connectionParams?.token;\n         \nconst token: string | undefined\n \n  // [... authenticate]\n \n  return {};\n};\n \nexport type Context = Awaited<ReturnType<typeof createContext>>;\nCopy\nclient/trpc.ts\nimport { createTRPCClient, createWSClient, wsLink } from '@trpc/client';\nimport type { AppRouter } from '~/server/routers/_app';\nconst wsClient = createWSClient({\n  url: `ws://localhost:3000`,\n  connectionParams: async () => {\n    return {\n      token: 'supersecret',\n    };\n  },\n});\nexport const trpc = createTRPCClient<AppRouter>({\n  links: [wsLink({ client: wsClient, transformer: superjson })],\n});\nCopy\nAutomatic tracking of id using tracked() (recommended)​\n\nIf you yield an event using our tracked()-helper and include an id, the client will automatically reconnect when it gets disconnected and send the last known ID when reconnecting as part of the lastEventId-input.\n\nYou can send an initial lastEventId when initializing the subscription and it will be automatically updated as the browser receives data.\n\nINFO\n\nIf you're fetching data based on the lastEventId, and capturing all events is critical, you may want to use ReadableStream's or a similar pattern as an intermediary as is done in our full-stack SSE example to prevent newly emitted events being ignored while yield'ing the original batch based on lastEventId.\n\nimport EventEmitter, { on } from 'events';\nimport { tracked } from '@trpc/server';\nimport { z } from 'zod';\nimport { publicProcedure, router } from '../trpc';\nconst ee = new EventEmitter();\nexport const subRouter = router({\n  onPostAdd: publicProcedure\n    .input(\n      z\n        .object({\n          // lastEventId is the last event id that the client has received\n          // On the first call, it will be whatever was passed in the initial setup\n          // If the client reconnects, it will be the last event id that the client received\n          lastEventId: z.string().nullish(),\n        })\n        .optional(),\n    )\n    .subscription(async function* (opts) {\n      if (opts.input.lastEventId) {\n        // [...] get the posts since the last event id and yield them\n      }\n      // listen for new events\n      for await (const [data] of on(ee, 'add', {\n        // Passing the AbortSignal from the request automatically cancels the event emitter when the subscription is aborted\n        signal: opts.signal,\n      })) {\n        const post = data as Post;\n        // tracking the post id ensures the client can reconnect at any time and get the latest events this id\n        yield tracked(post.id, post);\n      }\n    }),\n});\nCopy\nWebSockets RPC Specification​\n\nYou can read more details by drilling into the TypeScript definitions:\n\n/packages/server/src/unstable-core-do-not-import/rpc/envelopes.ts\n/packages/server/src/unstable-core-do-not-import/rpc/codes.ts.\nquery / mutation​\nRequest​\n{\n  id: number | string;\n  jsonrpc?: '2.0'; // optional\n  method: 'query' | 'mutation';\n  params: {\n    path: string;\n    input?: unknown; // <-- pass input of procedure, serialized by transformer\n  };\n}\nCopy\nResponse​\n\n... below, or an error.\n\n{\n  id: number | string;\n  jsonrpc?: '2.0'; // only defined if included in request\n  result: {\n    type: 'data'; // always 'data' for mutation / queries\n    data: TOutput; // output from procedure\n  }\n}\nCopy\nsubscription / subscription.stop​\nStart a subscription​\n{\n  id: number | string;\n  jsonrpc?: '2.0';\n  method: 'subscription';\n  params: {\n    path: string;\n    input?: unknown; // <-- pass input of procedure, serialized by transformer\n  };\n}\nCopy\nTo cancel a subscription, call subscription.stop​\n{\n  id: number | string; // <-- id of your created subscription\n  jsonrpc?: '2.0';\n  method: 'subscription.stop';\n}\nCopy\nSubscription response shape​\n\n... below, or an error.\n\n{\n  id: number | string;\n  jsonrpc?: '2.0';\n  result: (\n    | {\n        type: 'data';\n        data: TData; // subscription emitted data\n      }\n    | {\n        type: 'started'; // subscription started\n      }\n    | {\n        type: 'stopped'; // subscription stopped\n      }\n  )\n}\nCopy\nConnection params​\n\nIf the connection is initialized with ?connectionParams=1, the first message has to be connection params.\n\n{\n  data: Record<string, string> | null;\n  method: 'connectionParams';\n}\nCopy\nErrors​\n\nSee https://www.jsonrpc.org/specification#error_object or Error Formatting.\n\nNotifications from Server to Client​\n{ id: null, type: 'reconnect' }​\n\nTells clients to reconnect before shutting down the server. Invoked by wssHandler.broadcastReconnectNotification().\n\nEdit this page"
  },
  {
    "title": "Standalone Adapter | tRPC",
    "url": "https://trpc.io/docs/server/adapters/standalone",
    "html": "Backend Usage\nHosting tRPC with Adapters\nStandalone\nVersion: 11.x\nStandalone Adapter\n\ntRPC's Standalone Adapter is the simplest way to get a new project working. It's ideal for local development, and for server-based production environments. In essence it's just a wrapper around the standard Node.js HTTP Server with the normal options related to tRPC.\n\nIf you have an existing API deployment like Express, Fastify, or Next.js, which you want to integrate tRPC into, you should have a look at their respective adapters. Likewise if you have a preference to host on serverless or edge compute, we have adapters like AWS Lambda and Fetch which may fit your needs.\n\nIt's also not uncommon, where the deployed adapter is hard to run on local machines, to have 2 entry-points in your application. You could use the Standalone Adapter for local development, and a different adapter when deployed.\n\nExample app​\nDescription\tLinks\nStandalone tRPC Server\t\nStackBlitz\nSource\n\nStandalone tRPC Server with CORS handling\t\nStackBlitz\nSource\nSetting up a Standalone tRPC Server​\n1. Implement your App Router​\n\nImplement your tRPC router. For example:\n\nappRouter.ts\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\nexport const t = initTRPC.create();\nexport const appRouter = t.router({\n  getUser: t.procedure.input(z.string()).query((opts) => {\n    return { id: opts.input, name: 'Bilbo' };\n  }),\n  createUser: t.procedure\n    .input(z.object({ name: z.string().min(5) }))\n    .mutation(async (opts) => {\n      // use your ORM of choice\n      return await UserModel.create({\n        data: opts.input,\n      });\n    }),\n});\n// export type definition of API\nexport type AppRouter = typeof appRouter;\nCopy\n\nFor more information you can look at the quickstart guide\n\n2. Use the Standalone adapter​\n\nThe Standalone adapter runs a simple Node.js HTTP server.\n\nserver.ts\nimport { initTRPC } from '@trpc/server';\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\nimport { appRouter } from './appRouter.ts';\ncreateHTTPServer({\n  router: appRouter,\n  createContext() {\n    console.log('context 3');\n    return {};\n  },\n  // basePath: '/trpc/', // optional, defaults to '/'\n}).listen(2022);\nCopy\nHandling CORS & OPTIONS​\n\nBy default the standalone server will not respond to HTTP OPTIONS requests, or set any CORS headers.\n\nIf you're not hosting in an environment which can handle this for you, like during local development, you may need to handle it.\n\n1. Install cors​\n\nYou can add support yourself with the popular cors package\n\nyarn add cors\nyarn add -D @types/cors\nCopy\n\nFor full information on how to configure this package, check the docs\n\n2. Configure the Standalone server​\n\nThis example just throws open CORS to any request, which is useful for development, but you can and should configure it more strictly in a production environment.\n\nserver.ts\nimport { initTRPC } from '@trpc/server';\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\nimport cors from 'cors';\ncreateHTTPServer({\n  middleware: cors(),\n  router: appRouter,\n  createContext() {\n    console.log('context 3');\n    return {};\n  },\n}).listen(3333);\nCopy\n\nThe middleware option will accept any function which resembles a connect/node.js middleware, so it can be used for more than cors handling if you wish. It is, however, intended to be a simple escape hatch and as such won't on its own allow you to compose multiple middlewares together. If you want to do this then you could:\n\nUse an alternate adapter with more comprehensive middleware support, like the Express adapter\nUse a solution to compose middlewares such as connect\nExtend the Standalone createHTTPHandler with a custom http server (see below)\nAdding a handler to an Custom HTTP server​\n\ncreateHTTPServer is returning an instance of Node's built-in http.Server(https://nodejs.org/api/http.html#class-httpserver), which means that you have an access to all it's properties and APIs. However, if createHTTPServer isn't enough for your usecase, you can also use the standalone adapter's createHTTPHandler function to create your own HTTP server. For instance:\n\nserver.ts\nimport { createServer } from 'http';\nimport { initTRPC } from '@trpc/server';\nimport { createHTTPHandler } from '@trpc/server/adapters/standalone';\nconst handler = createHTTPHandler({\n  router: appRouter,\n  createContext() {\n    return {};\n  },\n});\ncreateServer((req, res) => {\n  /**\n   * Handle the request however you like,\n   * just call the tRPC handler when you're ready\n   */\n  handler(req, res);\n}).listen(3001);\nCopy\nCustom base path to handle requests under​\n\nThe Standalone adapter also supports a basePath option, which will slice the basePath from the beginning of the request path.\n\nserver.ts\nimport { createServer } from 'http';\nimport { initTRPC } from '@trpc/server';\nimport { createHTTPHandler } from '@trpc/server/adapters/standalone';\nconst handler = createHTTPHandler({\n  router: appRouter,\n  basePath: '/trpc/',\n});\ncreateServer((req, res) => {\n  if (req.url?.startsWith('/trpc/')) {\n    return handler(req, res);\n  }\n  // [... insert your custom logic here ...]\n  res.statusCode = 404;\n  res.end('Not Found');\n}).listen(3001);\nCopy\nHTTP2​\n\nThe Standalone adapter also supports HTTP/2.\n\nserver.ts\nimport http2 from 'http2';\nimport { createHTTP2Handler } from '@trpc/server/adapters/standalone';\nimport { appRouter } from './_app.ts';\nimport { createContext } from './context.ts';\nconst handler = createHTTP2Handler({\n  router: appRouter,\n  createContext,\n  // basePath: '/trpc/', // optional, defaults to '/'\n});\nconst server = http2.createSecureServer(\n  {\n    key: '...',\n    cert: '...',\n  },\n  (req, res) => {\n    /**\n     * Handle the request however you like,\n     * just call the tRPC handler when you're ready\n     */\n    handler(req, res);\n  },\n);\nserver.listen(3001);\nCopy\ncontext.ts\nimport { CreateHTTP2ContextOptions } from '@trpc/server/adapters/standalone';\n \nexport async function createContext(opts: CreateHTTP2ContextOptions) {\n  opts.req;\n       \n(property) req: http2.Http2ServerRequest\n  opts.res;\n       \n(property) res: http2.Http2ServerResponse\n \n  opts.info;\n        \n(property) info: TRPCRequestInfo\n  return {};\n}\n \nexport type Context = Awaited<ReturnType<typeof createContext>>;\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/adapters/express",
    "html": "Backend Usage\nHosting tRPC with Adapters\nExpress\nVersion: 11.x\nExpress Adapter\nExample app​\nDescription\tLinks\nExpress server & procedure calls with Node.js.\t\nCodeSandbox\nSource\nHow to add tRPC to existing Express project​\n1. Install deps​\nyarn add @trpc/server zod\nCopy\n\nZod isn't a required dependency, but it's used in the sample router below.\n\n2. Create a tRPC router​\n\nImplement your tRPC router. A sample router is given below:\n\nserver.ts\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\nexport const t = initTRPC.create();\nexport const appRouter = t.router({\n  getUser: t.procedure.input(z.string()).query((opts) => {\n    opts.input; // string\n    return { id: opts.input, name: 'Bilbo' };\n  }),\n  createUser: t.procedure\n    .input(z.object({ name: z.string().min(5) }))\n    .mutation(async (opts) => {\n      // use your ORM of choice\n      return await UserModel.create({\n        data: opts.input,\n      });\n    }),\n});\n// export type definition of API\nexport type AppRouter = typeof appRouter;\nCopy\n\nIf your router file starts getting too big, split your router into several subrouters each implemented in its own file. Then merge them into a single root appRouter.\n\n3. Use the Express adapter​\n\ntRPC includes an adapter for Express out of the box. This adapter lets you convert your tRPC router into an Express middleware.\n\nserver.ts\nimport { initTRPC } from '@trpc/server';\nimport * as trpcExpress from '@trpc/server/adapters/express';\nimport express from 'express';\n// created for each request\nconst createContext = ({\n  req,\n  res,\n}: trpcExpress.CreateExpressContextOptions) => ({}); // no context\ntype Context = Awaited<ReturnType<typeof createContext>>;\nconst t = initTRPC.context<Context>().create();\nconst appRouter = t.router({\n  // [...]\n});\nconst app = express();\napp.use(\n  '/trpc',\n  trpcExpress.createExpressMiddleware({\n    router: appRouter,\n    createContext,\n  }),\n);\napp.listen(4000);\nCopy\n\nYour endpoints are now available via HTTP!\n\nEndpoint\tHTTP URI\ngetUser\tGET http://localhost:4000/trpc/getUser?input=INPUT\n\nwhere INPUT is a URI-encoded JSON string.\ncreateUser\tPOST http://localhost:4000/trpc/createUser\n\nwith req.body of type {name: string}\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/adapters/fastify",
    "html": "Backend Usage\nHosting tRPC with Adapters\nFastify\nVersion: 11.x\nFastify Adapter\nExample app​\n\nThe best way to start with the Fastify adapter is to take a look at the example application.\n\nDescription\tLinks\n\nFastify server with WebSocket\nSimple tRPC client in node\n\t\nCodeSandbox\nSource\nHow to use tRPC with Fastify​\nInstall dependencies​\nyarn add @trpc/server fastify zod\nCopy\n\nZod isn't a required dependency, but it's used in the sample router below.\n\nCreate the router​\n\nFirst of all you need a router to handle your queries, mutations and subscriptions.\n\nA sample router is given below, save it in a file named router.ts.\n\nrouter.ts\n\nIf your router file starts getting too big, split your router into several subrouters each implemented in its own file. Then merge them into a single root appRouter.\n\nCreate the context​\n\nThen you need a context that will be created for each request.\n\nA sample context is given below, save it in a file named context.ts:\n\ncontext.ts\nCreate Fastify server​\n\ntRPC includes an adapter for Fastify out of the box. This adapter lets you convert your tRPC router into a Fastify plugin. In order to prevent errors during large batch requests, make sure to set the maxParamLength Fastify option to a suitable value, as shown.\n\nTIP\n\nDue to limitations in Fastify's plugin system and type inference, there might be some issues getting for example onError typed correctly. You can add a satisfies FastifyTRPCPluginOptions<AppRouter>['trpcOptions'] to help TypeScript out and get the correct types.\n\nserver.ts\nimport {\n  fastifyTRPCPlugin,\n  FastifyTRPCPluginOptions,\n} from '@trpc/server/adapters/fastify';\nimport fastify from 'fastify';\nimport { createContext } from './context';\nimport { appRouter, type AppRouter } from './router';\nconst server = fastify({\n  routerOptions: {\n    maxParamLength: 5000,\n  },\n});\nserver.register(fastifyTRPCPlugin, {\n  prefix: '/trpc',\n  trpcOptions: {\n    router: appRouter,\n    createContext,\n    onError({ path, error }) {\n      // report to error monitoring\n      console.error(`Error in tRPC handler on path '${path}':`, error);\n    },\n  } satisfies FastifyTRPCPluginOptions<AppRouter>['trpcOptions'],\n});\n(async () => {\n  try {\n    await server.listen({ port: 3000 });\n  } catch (err) {\n    server.log.error(err);\n    process.exit(1);\n  }\n})();\nCopy\n\nYour endpoints are now available via HTTP!\n\nEndpoint\tHTTP URI\ngetUser\tGET http://localhost:3000/trpc/getUserById?input=INPUT\n\nwhere INPUT is a URI-encoded JSON string.\ncreateUser\tPOST http://localhost:3000/trpc/createUser\n\nwith req.body of type User\nEnable WebSockets​\n\nThe Fastify adapter supports WebSockets via the @fastify/websocket plugin. All you have to do in addition to the above steps is install the dependency, add some subscriptions to your router and activate the useWSS option in the plugin. The minimum Fastify version required for @fastify/websocket is 3.11.0.\n\nInstall dependencies​\nyarn add @fastify/websocket\nCopy\nImport and register @fastify/websocket​\nimport ws from '@fastify/websocket';\nserver.register(ws);\nCopy\nAdd some subscriptions​\n\nEdit the router.ts file created in the previous steps and add the following code:\n\nrouter.ts\nimport { initTRPC } from '@trpc/server';\nimport { observable } from '@trpc/server/observable';\nconst t = initTRPC.create();\nexport const appRouter = t.router({\n  randomNumber: t.procedure.subscription(async function* () {\n    while (true) {\n      yield { randomNumber: Math.random() };\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n    }\n  }),\n});\nCopy\nActivate the useWSS option​\nserver.ts\nserver.register(fastifyTRPCPlugin, {\n  useWSS: true,\n  // Enable heartbeat messages to keep connection open (disabled by default)\n  keepAlive: {\n    enabled: true,\n    // server ping message interval in milliseconds\n    pingMs: 30000,\n    // connection is terminated if pong message is not received in this many milliseconds\n    pongWaitMs: 5000,\n  },\n  // ...\n});\nCopy\n\nIt's alright, you can subscribe to the topic randomNumber and you should receive a random number every second 🚀.\n\nFastify plugin options​\nname\ttype\toptional\tdefault\tdescription\nprefix\tstring\ttrue\t\"/trpc\"\t\nuseWSS\tboolean\ttrue\tfalse\t\ntrpcOptions\tNodeHTTPHandlerOptions\tfalse\tn/a\t\nEdit this page"
  },
  {
    "title": "Next.js Adapter | tRPC",
    "url": "https://trpc.io/docs/server/adapters/nextjs",
    "html": "Backend Usage\nHosting tRPC with Adapters\nNext.js\nVersion: 11.x\nNext.js Adapter\nTIP\n\ntRPC's support for Next.js is far more expansive than just an adapter. This page covers a brief summary of how to set up the adapter, but complete documentation is available here\n\nExample app​\nDescription\tLinks\nNext.js Minimal Starter\t\nCodeSandbox\nSource\nNext.js example​\n\nServing your tRPC router in a Next.js project is straight-forward. Just create an API handler in pages/api/trpc/[trpc].ts as shown below:\n\npages/api/trpc/[trpc].ts\nimport { createNextApiHandler } from '@trpc/server/adapters/next';\nimport { createContext } from '../../../server/trpc/context';\nimport { appRouter } from '../../../server/trpc/router/_app';\n// @link https://nextjs.org/docs/api-routes/introduction\nexport default createNextApiHandler({\n  router: appRouter,\n  createContext,\n});\nCopy\nHandling CORS, and other Advanced usage​\n\nWhile you can usually just \"set and forget\" the API Handler as shown above, sometimes you might want to modify it further.\n\nThe API handler created by createNextApiHandler and equivalents in other frameworks is just a function that takes req and res objects. This means you can also modify those objects before passing them to the handler, for example to enable CORS.\n\npages/api/trpc/[trpc].ts\nimport { createNextApiHandler } from '@trpc/server/adapters/next';\nimport { createContext } from '../../../server/trpc/context';\nimport { appRouter } from '../../../server/trpc/router/_app';\n// create the API handler, but don't return it yet\nconst nextApiHandler = createNextApiHandler({\n  router: appRouter,\n  createContext,\n});\n// @link https://nextjs.org/docs/api-routes/introduction\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse,\n) {\n  // We can use the response object to enable CORS\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  res.setHeader('Access-Control-Request-Method', '*');\n  res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');\n  res.setHeader('Access-Control-Allow-Headers', '*');\n  // If you need to make authenticated CORS calls then\n  // remove what is above and uncomment the below code\n  // Allow-Origin has to be set to the requesting domain that you want to send the credentials back to\n  // res.setHeader('Access-Control-Allow-Origin', 'http://example:6006');\n  // res.setHeader('Access-Control-Request-Method', '*');\n  // res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');\n  // res.setHeader('Access-Control-Allow-Headers', 'content-type');\n  // res.setHeader('Referrer-Policy', 'no-referrer');\n  // res.setHeader('Access-Control-Allow-Credentials', 'true');\n  if (req.method === 'OPTIONS') {\n    res.writeHead(200);\n    return res.end();\n  }\n  // finally pass the request on to the tRPC handler\n  return nextApiHandler(req, res);\n}\nCopy\nRoute Handlers​\n\nIf you're trying out the Next.js App Router and want to use route handlers, you can do so by using the fetch adapter, as they build on web standard Request and Response objects:\n\napp/api/trpc/[trpc]/route.ts\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { appRouter } from '~/server/api/router';\nfunction handler(req: Request) {\n  return fetchRequestHandler({\n    endpoint: '/api/trpc',\n    req,\n    router: appRouter,\n    createContext: () => ({ ... })\n  });\n}\nexport { handler as GET, handler as POST };\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/adapters/aws-lambda",
    "html": "Backend Usage\nHosting tRPC with Adapters\nAWS Lambda + API Gateway\nVersion: 11.x\nAWS Lambda + API Gateway Adapter\nAWS Lambda adapter​\n\nThe AWS Lambda adapter is supported for API Gateway REST API(v1) and HTTP API(v2), and Lambda Function URL use cases.\n\nhttpBatchLink requires the router to work on a single API Gateway Resource (as shown in the example). If you'd like to have a Resource per procedure, you can use the httpLink instead (more info).\n\nExample app​\nDescription\tLinks\nAPI Gateway with NodeJS client.\t\nSource\nHow to add tRPC​\n1. Install deps​\nyarn add @trpc/server\nCopy\n2. Create a tRPC router​\n\nImplement your tRPC router. A sample router is given below:\n\nserver.ts\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\nexport const t = initTRPC.create();\nconst appRouter = t.router({\n  getUser: t.procedure.input(z.string()).query((opts) => {\n    opts.input; // string\n    return { id: opts.input, name: 'Bilbo' };\n  }),\n});\n// export type definition of API\nexport type AppRouter = typeof appRouter;\nCopy\n3. Use the Amazon API Gateway adapter​\n\ntRPC includes an adapter for API Gateway out of the box. This adapter lets you run your routes through the API Gateway handler.\n\nserver.ts\nimport { CreateAWSLambdaContextOptions, awsLambdaRequestHandler } from '@trpc/server/adapters/aws-lambda';\nconst appRouter = /* ... */;\n// created for each request\nconst createContext = ({\n  event,\n  context,\n}: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2>) => ({}) // no context\ntype Context = Awaited<ReturnType<typeof createContext>>;\nexport const handler = awsLambdaRequestHandler({\n  router: appRouter,\n  createContext,\n})\nCopy\n\nBuild & deploy your code, now use your API Gateway URL to call your function.\n\nEndpoint\tHTTP URI\ngetUser\tGET https://<execution-api-link>/getUser?input=INPUT\n\nwhere INPUT is a URI-encoded JSON string.\nA word about payload format version​\n\nAPI Gateway has two different event data formats when it invokes a Lambda. For REST APIs they should be version \"1.0\"(APIGatewayProxyEvent), but you can choose which for HTTP APIs by stating either version \"1.0\" or \"2.0\".\n\nVersion 1.0: APIGatewayProxyEvent\nVersion 2.0: APIGatewayProxyEventV2\n\nTo infer what version you might have, supply the context as following:\n\nfunction createContext({\n  event,\n  context,\n}: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>) {\n  ...\n}\n// CreateAWSLambdaContextOptions<APIGatewayProxyEvent> or CreateAWSLambdaContextOptions<APIGatewayProxyEventV2>\nCopy\n\nRead more here about payload format version\n\nAWS Lambda Response Streaming Adapter​\n\nAWS Lambda supports streaming responses to clients.\n\nResponse streaming is only supported for Lambda Function URLs. You can not use API Gateway to stream responses. Read more here about response streaming.\n\nExample app​\nDescription\tLinks\nLambda Function URL with NodeJS client.\t\nSource\nResponse Streaming​\n\nThe signature of a streaming handler is different from the default handler. The streaming handler additonally receives a writable stream parameter, responseStream, besides the default node handler parameters, event and context. To indicate that Lambda should stream your responses, you must wrap your function handler with the awslambda.streamifyResponse() decorator.\n\nNote that the awslambda namespace is automatically provided by the Lambda execution environment. You can import the types from @types/aws-lambda to augment the global namespace with the awslambda namespace.\n\nserver.ts\nimport { awsLambdaStreamingRequestHandler } from '@trpc/server/adapters/aws-lambda';\nimport type { StreamifyHandler } from 'aws-lambda';\nconst appRouter = router({\n  iterable: publicProcedure.query(async function* () {\n    for (let i = 0; i < 10; i++) {\n      await new Promise((resolve) => setTimeout(resolve, 500));\n      yield i;\n    }\n  }),\n});\nexport const handler = awslambda.streamifyResponse(\n  awsLambdaStreamingRequestHandler({\n    router: appRouter,\n    /* ... */\n  }),\n);\nCopy\nEdit this page"
  },
  {
    "title": "Fetch / Edge Runtimes Adapter | tRPC",
    "url": "https://trpc.io/docs/server/adapters/fetch",
    "html": "Backend Usage\nHosting tRPC with Adapters\nFetch / Edge Runtimes\nVersion: 11.x\nFetch / Edge Runtimes Adapter\n\nYou can create a tRPC server within any edge runtime that follow the WinterCG, specifically the Minimum Common Web Platform API specification.\n\nSome of these runtimes includes, but not limited to:\n\nCloudflare Workers\nDeno Deploy\nVercel Edge Runtime (& Next.js Edge Runtime)\n\nThis also makes it easy to integrate into frameworks that uses the web platform APIs to represent requests and responses, such as:\n\nAstro (SSR mode)\nRemix\nSolidStart\nExample apps​\nDescription\tLinks\nCloudflare Workers example\t\n\nSource\n\n\nDeno Deploy example\t\n\nSource\n\n\nNext.js Edge Runtime example\t\n\nSource\n\n\nVercel Edge Runtime example\t\n\nSource\n\nHow to use tRPC server with an edge runtime​\n\ntRPC provides a fetch adapter that uses the native Request and Response APIs as input and output. The tRPC-specific code is the same across all runtimes, the only difference being how the response is returned.\n\ntRPC includes an adapter for the native Fetch API out of the box. This adapter lets you convert your tRPC router into a Request handler that returns Response objects.\n\nRequired Web APIs​\n\ntRPC server uses the following Fetch APIs:\n\nRequest, Response\nfetch\nHeaders\nURL\n\nIf your runtime supports these APIs, you can use tRPC server.\n\nTIP\n\nFun fact: that also means you can use a tRPC server in your browser!\n\nCommon setup​\nInstall dependencies​\nTIP\n\nYou can skip this step if you use Deno Deploy.\n\nnpm\nyarn\npnpm\nbun\ndeno\nnpm install @trpc/server @trpc/client zod\n\nZod isn't a required dependency, but it's used in the sample router below.\n\nCreate the router​\n\nFirst of all you need a router to handle your queries, mutations and subscriptions.\n\nA sample router is given below, save it in a file named router.ts.\n\nrouter.ts\n\nIf your router file starts getting too big, split your router into several subrouters each implemented in its own file. Then merge them into a single root appRouter.\n\nCreate the context​\n\nThen you need a context that will be created for each request.\n\nA sample context is given below, save it in a file named context.ts:\n\ncontext.ts\nRuntimes-specific setup​\nAstro​\nsrc/pages/trpc/[trpc].ts\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport type { APIRoute } from 'astro';\nimport { createContext } from '../../server/context';\nimport { appRouter } from '../../server/router';\nexport const ALL: APIRoute = (opts) => {\n  return fetchRequestHandler({\n    endpoint: '/trpc',\n    req: opts.request,\n    router: appRouter,\n    createContext,\n  });\n};\nCopy\nCloudflare Worker​\nNOTE\n\nYou need the Wrangler CLI to run Cloudflare Workers.\n\nCreate Cloudflare Worker​\nserver.ts\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { createContext } from './context';\nimport { appRouter } from './router';\nexport default {\n  async fetch(request: Request): Promise<Response> {\n    return fetchRequestHandler({\n      endpoint: '/trpc',\n      req: request,\n      router: appRouter,\n      createContext,\n    });\n  },\n};\nCopy\n\nRun wrangler dev server.ts and your endpoints will be available via HTTP!\n\nEndpoint\tHTTP URI\ngetUser\tGET http://localhost:8787/trpc/getUserById?input=INPUT\n\nwhere INPUT is a URI-encoded JSON string.\ncreateUser\tPOST http://localhost:8787/trpc/createUser\n\nwith req.body of type User\nDeno Oak​\nNOTE\n\nThis assumes you have Deno installed and setup. Refer to their getting started guide for more information.\n\nUpdate the imports in router.ts​\nrouter.ts\nimport { initTRPC } from 'npm:@trpc/server';\nimport { z } from 'npm:zod';\nimport { Context } from './context.ts';\nCopy\nUpdate the imports in context.ts​\ncontext.ts\nimport { FetchCreateContextFnOptions } from 'npm:@trpc/server/adapters/fetch';\nCopy\nUse fetchRequestHandler with Oak in app.ts​\napp.ts\nimport { Application, Router } from 'https://deno.land/x/oak/mod.ts';\nimport { fetchRequestHandler } from 'npm:@trpc/server/adapters/fetch';\nimport { createContext } from './context.ts';\nimport { appRouter } from './router.ts';\nconst app = new Application();\nconst router = new Router();\nrouter.all('/trpc/(.*)', async (ctx) => {\n  const res = await fetchRequestHandler({\n    endpoint: '/trpc',\n    req: new Request(ctx.request.url, {\n      headers: ctx.request.headers,\n      body:\n        ctx.request.method !== 'GET' && ctx.request.method !== 'HEAD'\n          ? ctx.request.body({ type: 'stream' }).value\n          : void 0,\n      method: ctx.request.method,\n    }),\n    router: appRouter,\n    createContext,\n  });\n  ctx.response.status = res.status;\n  ctx.response.headers = res.headers;\n  ctx.response.body = res.body;\n});\napp.use(router.routes());\napp.use(router.allowedMethods());\nawait app.listen({ port: 3000 });\nCopy\nDeno Deploy​\nNOTE\n\nThis assumes you have Deno installed and setup. Refer to their getting started guide for more information.\n\nTIP\n\nSee our example Deno Deploy app for a working example.\n\nUpdate the imports in router.ts​\nrouter.ts\nimport { initTRPC } from 'npm:@trpc/server';\nimport { z } from 'npm:zod';\nimport { Context } from './context.ts';\nCopy\nUpdate the imports in context.ts​\ncontext.ts\nimport { FetchCreateContextFnOptions } from 'npm:@trpc/server/adapters/fetch';\nCopy\nCreate Deno Deploy Function​\nserver.ts\nimport { fetchRequestHandler } from 'npm:@trpc/server/adapters/fetch';\nimport { createContext } from './context.ts';\nimport { appRouter } from './router.ts';\nfunction handler(request) {\n  return fetchRequestHandler({\n    endpoint: '/trpc',\n    req: request,\n    router: appRouter,\n    createContext,\n  });\n}\nDeno.serve(handler);\nCopy\n\nRun deno run --allow-net=:8000 --allow-env ./server.ts and your endpoints will be available via HTTP!\n\nEndpoint\tHTTP URI\ngetUser\tGET http://localhost:8000/trpc/getUserById?input=INPUT\n\nwhere INPUT is a URI-encoded JSON string.\ncreateUser\tPOST http://localhost:8000/trpc/createUser\n\nwith req.body of type User\nNext.js Edge Runtime​\n\nSee a full example here.\n\nRemix​\napp/routes/trpc.$trpc.ts\nimport type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node';\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { createContext } from '~/server/context';\nimport { appRouter } from '~/server/router';\nexport const loader = async (args: LoaderFunctionArgs) => {\n  return handleRequest(args);\n};\nexport const action = async (args: ActionFunctionArgs) => {\n  return handleRequest(args);\n};\nfunction handleRequest(args: LoaderFunctionArgs | ActionFunctionArgs) {\n  return fetchRequestHandler({\n    endpoint: '/trpc',\n    req: args.request,\n    router: appRouter,\n    createContext,\n  });\n}\nCopy\nSolidStart​\nsrc/routes/api/trpc/[trpc].ts\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport type { APIEvent } from 'solid-start';\nimport { createContext } from '../../server/context';\nimport { appRouter } from '../../server/router';\nconst handler = (event: APIEvent) =>\n  fetchRequestHandler({\n    endpoint: '/api/trpc',\n    req: event.request,\n    router: appRouter,\n    createContext,\n  });\nexport { handler as GET, handler as POST };\nCopy\nVercel Edge Runtime​\nNOTE\n\nSee the official Vercel Edge Runtime documentation for more information.\n\nTIP\n\nSee our example Vercel Edge Runtime app for a working example.\n\nInstall dependencies​\nnpm\nyarn\npnpm\nbun\nnpm install -g edge-runtime\nCopy\nCreate Edge Runtime Function​\nserver.ts\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { createContext } from './context';\nimport { appRouter } from './router';\naddEventListener('fetch', (event) => {\n  return event.respondWith(\n    fetchRequestHandler({\n      endpoint: '/trpc',\n      req: event.request,\n      router: appRouter,\n      createContext,\n    }),\n  );\n});\nCopy\n\nRun edge-runtime --listen server.ts --port 3000 and your endpoints will be available via HTTP!\n\nEndpoint\tHTTP URI\ngetUser\tGET http://localhost:3000/trpc/getUserById?input=INPUT\n\nwhere INPUT is a URI-encoded JSON string.\ncreateUser\tPOST http://localhost:3000/trpc/createUser\n\nwith req.body of type User\nEdit this page"
  },
  {
    "title": "tRPC Client | tRPC",
    "url": "https://trpc.io/docs/client/vanilla",
    "html": "Client Usage\nVanilla Client\nVersion: 11.x\ntRPC Client\n\nThe \"Vanilla\" tRPC client can be used to call your API procedures as if they are local functions, enabling a seamless development experience.\n\nimport type { AppRouter } from '../path/to/server/trpc';\nconst bilbo = await client.getUser.query('id_bilbo');\n// => { id: 'id_bilbo', name: 'Bilbo' };\nCopy\nWhen to use the Vanilla Client?​\n\nYou are likely to use this client in two scenarios:\n\nWith a frontend framework for which we don't have an official integration\nWith a separate backend service written in TypeScript.\nWhen NOT to use the Vanilla Client?​\nWhile you can use the client to call procedures from a React component, you should usually use our React Query Integration. It offers many additional features such as the ability to manage loading and error state, caching, and invalidation.\nWe recommend you do not use this client when calling procedures of the same API instance, this is because the invocation has to pass through the network layer. For complete recommendations on invoking a procedure in the current API, you can read more here.\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/vanilla#__docusaurus_skipToContent_fallback",
    "html": "Client Usage\nVanilla Client\nVersion: 11.x\ntRPC Client\n\nThe \"Vanilla\" tRPC client can be used to call your API procedures as if they are local functions, enabling a seamless development experience.\n\nimport type { AppRouter } from '../path/to/server/trpc';\nconst bilbo = await client.getUser.query('id_bilbo');\n// => { id: 'id_bilbo', name: 'Bilbo' };\nCopy\nWhen to use the Vanilla Client?​\n\nYou are likely to use this client in two scenarios:\n\nWith a frontend framework for which we don't have an official integration\nWith a separate backend service written in TypeScript.\nWhen NOT to use the Vanilla Client?​\nWhile you can use the client to call procedures from a React component, you should usually use our React Query Integration. It offers many additional features such as the ability to manage loading and error state, caching, and invalidation.\nWe recommend you do not use this client when calling procedures of the same API instance, this is because the invocation has to pass through the network layer. For complete recommendations on invoking a procedure in the current API, you can read more here.\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/nextjs",
    "html": "Client Usage\nNext.js Integration\nVersion: 11.x\nNext.js Integration\ntRPC ❤️ Next.js​\n\nNext.js makes it easy to build a client and server together in one codebase. tRPC makes it easy to share types between them, ensuring typesafety for your application's data fetching.\n\nOur Next.js integration is built on top of our React Query Integration with some Next.js specific APIs, to handle both client and server side rendering.\n\nWhen using the Next.js integration, you'll get the following features:\n\nServer-side rendering - You can tell tRPC to render your pages on the server, and then hydrate them on the client. This way, you'll avoid an initial loading state, although time to first byte will be blocked by the server. Read more about Server-side rendering.\nStatic site generation - Prefetch queries on the server and generate static HTML files that are ready to be served. Read more about Static site generation.\nAutomatic Provider Wrapping - @trpc/next provides a higher-order component (HOC) that wraps your app with the necessary providers so you don't have to do it yourself.\nTIP\n\nIf you're using tRPC in a new project, consider using one of the example projects for reference: tRPC Example Projects\n\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/tanstack-react-query",
    "html": "📄️ Setup\n\nTanStack React Query setup\n\n📄️ Usage\n\nTanStack React Query usage\n\n📄️ Migrating\n\nMigrating from the classic React Client\n\n📄️ Server Components\n\nThis guide is an overview of how one may use tRPC with a React Server Components (RSC) framework such as Next.js App Router."
  },
  {
    "title": "React Query Integration (Classic) | tRPC",
    "url": "https://trpc.io/docs/client/react",
    "html": "Client Usage\nReact Query Integration (Classic)\nVersion: 11.x\nReact Query Integration (Classic)\nTIP\n\nThese are the docs for our 'Classic' React Query integration, which (while still supported) is not the recommended way to start new tRPC projects with TanStack React Query. We recommend using the new TanStack React Query Integration instead.\n\ntRPC offers a first class integration with React. Under the hood this is simply a wrapper around the very popular @tanstack/react-query, so we recommend that you familiarise yourself with React Query, as their docs go in to much greater depth on its usage.\n\nIf you are using Next.js we recommend using our integration with that instead.\n\n❓ Do I have to use an integration?\nThe tRPC React Query Integration​\n\nThis library enables usage directly within React components\n\npages/IndexPage.tsx\nimport { trpc } from '../utils/trpc';\nexport default function IndexPage() {\n  const helloQuery = trpc.hello.useQuery({ name: 'Bob' });\n  const goodbyeMutation = trpc.goodbye.useMutation();\n  return (\n    <div>\n      <p>{helloQuery.data?.greeting}</p>\n      <button onClick={() => goodbyeMutation.mutate()}>Say Goodbye</button>\n    </div>\n  );\n}\nCopy\nDifferences to vanilla React Query​\n\nThe wrapper abstracts some aspects of React Query for you:\n\nQuery Keys - these are generated and managed by tRPC on your behalf, based on the procedure inputs you provide\nIf you need the query key which tRPC calculates, you can use getQueryKey\nType safe by default - the types you provide in your tRPC Backend also drive the types of your React Query client, providing safety throughout your React app\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/vanilla/setup",
    "html": "Client Usage\nVanilla Client\nSetup\nVersion: 11.x\nSet up a tRPC Client\n1. Install the tRPC Client library​\n\nUse your preferred package manager to install the @trpc/client library, and also install @trpc/server which contains some required types.\n\nnpm\nyarn\npnpm\nbun\ndeno\nnpm install @trpc/server @trpc/client\n2. Import your App Router​\n\nImport your AppRouter type into the client application. This type holds the shape of your entire API.\n\nutils/trpc.ts\nimport type { AppRouter } from '../server/router';\nCopy\nTIP\n\nBy using import type you ensure that the reference will be stripped at compile-time, meaning you don't inadvertently import server-side code into your client. For more information, see the Typescript docs.\n\n3. Initialize the tRPC client​\n\nCreate a tRPC client with the createTRPCClient method, and add a links array with a terminating link pointing at your API. To learn more about tRPC links, click here.\n\nclient.ts\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from '../path/to/server/trpc';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000/trpc',\n      // You can pass any HTTP headers you wish here\n      async headers() {\n        return {\n          authorization: getAuthCookie(),\n        };\n      },\n    }),\n  ],\n});\nCopy\n4. Use the tRPC Client​\n\nUnder the hood this creates a typed JavaScript Proxy which allows you to interact with your tRPC API in a fully type-safe way:\n\nclient.ts\nconst bilbo = await client.getUser.query('id_bilbo');\n// => { id: 'id_bilbo', name: 'Bilbo' };\nconst frodo = await client.createUser.mutate({ name: 'Frodo' });\n// => { id: 'id_frodo', name: 'Frodo' };\nCopy\n\nYou're all set!\n\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/vanilla/infer-types",
    "html": "Client Usage\nVanilla Client\nInferring Types\nVersion: 11.x\nInferring Types\n\nIt is often useful to access the types of your API within your clients. For this purpose, you are able to infer the types contained in your AppRouter.\n\n@trpc/server exports the following helper types to assist with inferring these types from the AppRouter exported by your @trpc/server router:\n\ninferRouterInputs<TRouter>\ninferRouterOutputs<TRouter>\nInferring Input & Output Types​\n\nLet's assume we have this example router:\n\nserver.ts\n// @filename: server.ts\nimport { initTRPC } from '@trpc/server';\nimport { z } from \"zod\";\n \nconst t = initTRPC.create();\n \nconst appRouter = t.router({\n  post: t.router({\n    list: t.procedure\n      .query(() => {\n        // imaginary db call\n        return [{ id: 1, title: 'tRPC is the best!' }];\n    }),\n    byId: t.procedure\n      .input(z.string())\n      .query((opts) => {\n        // imaginary db call\n        return { id: 1, title: 'tRPC is the best!' };\n    }),\n    create: t.procedure\n      .input(z.object({ title: z.string(), text: z.string(), }))\n      .mutation((opts) => {\n        // imaginary db call\n        return { id: 1, ...opts.input };\n    }),\n  }),\n});\n \nexport type AppRouter = typeof appRouter;\nCopy\n\nUsing the helpers, we can infer the types of our router. The following example shows how to infer the types of the post.create procedure:\n\nclient.ts\n// @filename: client.ts\nimport type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';\nimport type { AppRouter } from './server';\n \ntype RouterInput = inferRouterInputs<AppRouter>;\ntype RouterOutput = inferRouterOutputs<AppRouter>;\n \ntype PostCreateInput = RouterInput['post']['create'];\n           \ntype PostCreateInput = {\n    title: string;\n    text: string;\n}\ntype PostCreateOutput = RouterOutput['post']['create'];\n            \ntype PostCreateOutput = {\n    title: string;\n    text: string;\n    id: number;\n}\nCopy\nInfer TRPCClientError types​\n\nIt's also useful to infer the error type for your AppRouter\n\nclient.ts\n// @filename: client.ts\nimport { TRPCClientError } from '@trpc/client';\nimport type { AppRouter } from './server';\nimport { trpc } from './trpc';\n \nexport function isTRPCClientError(\n  cause: unknown,\n): cause is TRPCClientError<AppRouter> {\n  return cause instanceof TRPCClientError;\n}\n \nasync function main() {\n  try {\n    await trpc.post.byId.query('1');\n  } catch (cause) {\n    if (isTRPCClientError(cause)) {\n      // `cause` is now typed as your router's `TRPCClientError`\n      console.log('data', cause.data);\n                                 \n(property) TRPCClientError<BuiltRouter<{ ctx: object; meta: object; errorShape: DefaultErrorShape; transformer: false; }, DecorateCreateRouterOptions<{ post: BuiltRouter<{ ctx: object; meta: object; errorShape: DefaultErrorShape; transformer: false; }, DecorateCreateRouterOptions<...>>; }>>>.data: Maybe<DefaultErrorData>\n    } else {\n      // [...]\n    }\n  }\n}\n \nmain();\nCopy\nEdit this page"
  },
  {
    "title": "Aborting Procedure Calls | tRPC",
    "url": "https://trpc.io/docs/client/vanilla/aborting-procedure-calls",
    "html": "Client Usage\nVanilla Client\nAborting Procedure Calls\nVersion: 11.x\nAborting Procedure Calls\n\ntRPC adheres to the industry standard when it comes to aborting procedures. All you have to do is pass an AbortSignal to the query or mutation options, and call the AbortController instance's abort method if you need to cancel the request.\n\nutils.ts\n// @filename: server.ts\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from './server.ts';\n \nconst proxy = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000/trpc',\n    }),\n  ],\n});\n \n// 1. Create an AbortController instance - this is a standard javascript API\nconst ac = new AbortController();\n \n// 2. Pass the signal to a query or mutation\nconst query = proxy.userById.query('id_bilbo', { signal: ac.signal });\n \n// 3. Cancel the request if needed\nac.abort();\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/links",
    "html": "Client Usage\nLinks\nVersion: 11.x\nLinks Overview\n\nLinks enable you to customize the flow of data between the tRPC Client and Server. A link should do only one thing, which can be either a self-contained modification to a tRPC operation (query, mutation, or subscription) or a side-effect based on the operation (such as logging).\n\nYou can compose links together into an array that you can provide to the tRPC client configuration via the links property, which represents a link chain. This means that the tRPC client will execute the links in the order they are added to the links array when doing a request and will execute them again in reverse when it's handling a response. Here's a visual representation of the link chain:\n\ntRPC Link Diagram. Based on Apollo's.\nNOTE\n\nThe below examples are assuming you use Next.js, but the same as below can be added if you use the vanilla tRPC client\n\nutils/trpc.ts\nimport { httpBatchLink, loggerLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nexport default createTRPCNext<AppRouter>({\n  config() {\n    const url = `http://localhost:3000`;\n    return {\n      links: [\n        loggerLink(),\n        httpBatchLink({\n          url,\n        }),\n      ],\n    };\n  },\n});\nCopy\nCreating a custom link​\n\nA link is a function that follows the TRPCLink type. Each link is composed of three parts:\n\nThe link returns a function that has a parameter with the TRPCClientRuntime type. This argument is passed by tRPC and it is used when creating a terminating link. If you're not creating a terminating link, you can just create a function that has no parameters. In such case, the link should be added to the links array without invoking (links: [..., myLink, httpBatchLink(...)]).\nThe function in step 1 returns another function that receives an object with two properties: op which is the Operation that is being executed by the client, and next which is the function we use to call the next link down the chain.\nThe function in step 2 returns a final function that returns the observable function provided by @trpc/server. The observable accepts a function that receives an observer which helps our link notify the next link up the chain how they should handle the operation result. In this function, we can just return next(op) and leave it as is, or we can subscribe to next, which enables our link to handle the operation result.\nExample​\nutils/customLink.ts\nimport { TRPCLink } from '@trpc/client';\nimport { observable } from '@trpc/server/observable';\nimport type { AppRouter } from '~/server/routers/_app';\nexport const customLink: TRPCLink<AppRouter> = () => {\n  // here we just got initialized in the app - this happens once per app\n  // useful for storing cache for instance\n  return ({ next, op }) => {\n    // this is when passing the result to the next link\n    // each link needs to return an observable which propagates results\n    return observable((observer) => {\n      console.log('performing operation:', op);\n      const unsubscribe = next(op).subscribe({\n        next(value) {\n          console.log('we received value', value);\n          observer.next(value);\n        },\n        error(err) {\n          console.log('we received error', err);\n          observer.error(err);\n        },\n        complete() {\n          observer.complete();\n        },\n      });\n      return unsubscribe;\n    });\n  };\n};\nCopy\nReferences​\n\nIf you need a more real reference for creating your custom link, you can check out some of the built-in links tRPC provides on GitHub.\n\nThe terminating link​\n\nThe terminating link is the last link in a link chain. Instead of calling the next function, the terminating link is responsible for sending your composed tRPC operation to the tRPC server and returning an OperationResultEnvelope.\n\nThe links array that you add to the tRPC client config should have at least one link, and that link should be a terminating link. If links don't have a terminating link at the end of them, the tRPC operation will not be sent to the tRPC server.\n\nhttpBatchLink is the recommended terminating link by tRPC.\n\nhttpLink, wsLink, and localLink are other examples of terminating links.\n\nManaging context​\n\nAs an operation moves along your link chain, it maintains a context that each link can read and modify. This allows links to pass metadata along the chain that other links use in their execution logic.\n\nObtain the current context object and modify it by accessing op.context.\n\nYou can set the context object's initial value for a particular operation by providing the context parameter to the query or useQuery hook (or mutation, subscription, etc.).\n\nFor an example use case, see Disable batching for certain requests.\n\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/headers",
    "html": "Client Usage\nCreate Custom Header\nVersion: 11.x\nCustom header\n\nThe headers option can be customized in the config when using the httpBatchLink or the httpLink.\n\nheaders can be both an object or a function. If it's a function it will get called dynamically for every HTTP request.\n\nutils/trpc.ts\n// Import the router type from your server file\nimport type { AppRouter } from '@/server/routers/app';\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nlet token: string;\nexport function setToken(newToken: string) {\n  /**\n   * You can also save the token to cookies, and initialize from\n   * cookies above.\n   */\n  token = newToken;\n}\nexport const trpc = createTRPCNext<AppRouter>({\n  config(config) {\n    return {\n      links: [\n        httpBatchLink({\n          url: 'http://localhost:3000/api/trpc',\n          /**\n           * Headers will be called on each request.\n           */\n          headers() {\n            return {\n              Authorization: token,\n            };\n          },\n        }),\n      ],\n    };\n  },\n});\nCopy\nExample with auth login​\npages/auth.tsx\nconst loginMut = trpc.auth.login.useMutation({\n  onSuccess(opts) {\n    token = opts.accessToken;\n  },\n});\nCopy\n\nThe token can be whatever you want it to be. It's entirely up to you whether that's just a client-side variable that you update the value of on success or whether you store the token and pull it from local storage.\n\nEdit this page"
  },
  {
    "title": "Send cookies cross-origin | tRPC",
    "url": "https://trpc.io/docs/client/cors",
    "html": "Client Usage\nCORS & Cookies\nVersion: 11.x\nSend cookies cross-origin\n\nIf your API resides on a different origin than your front-end and you wish to send cookies to it, you will need to enable CORS on your server and send cookies with your requests by providing the option {credentials: \"include\"} to fetch.\n\nThe arguments provided to the fetch function used by tRPC can be modified as follow.\n\napp.ts\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'YOUR_SERVER_URL',\n      fetch(url, options) {\n        return fetch(url, {\n          ...options,\n          credentials: 'include',\n        });\n      },\n    }),\n  ],\n});\nCopy\nINFO\n\nYou also need to enable CORS on your server by modifying your adapter, or the HTTP server which fronts your API. The best way to do this varies adapter-by-adapter and based on your hosting infrastructure, and individual adapters generally document this process where applicable.\n\nEdit this page"
  },
  {
    "title": "Starter Projects | tRPC",
    "url": "https://trpc.io/docs/client/nextjs/starter-projects",
    "html": "Client Usage\nNext.js Integration\nStarter Projects\nVersion: 11.x\nStarter Projects\n\nGet started quickly with one of the sample projects! Copy the snippet from Quick start with create-next-app in the below list to clone the project.\n\nDescription\tURL\tLinks\n\n\nNext.js starter with Prisma, E2E testing, & ESLint.\n\n\n\n\nQuick start with create-next-app\n\tnextjs.trpc.io\t\nCodeSandbox\nSource\n\n\n\nzART-stack example (zero-API, TypeScript, React).\n\n\n\n\nMonorepo setup with React Native, Next.js, & Prisma\n\n\n\n\nQuick start with git clone\n\tn/a\t\nSource\n\n\n\nNext.js TodoMVC-example with SSG & Prisma.\n\n\n\n\nQuick start with create-next-app\n\ttodomvc.trpc.io\t\nCodeSandbox\nSource\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/nextjs/setup",
    "html": "Client Usage\nNext.js Integration\nSetup\nVersion: 11.x\nSet up with Next.js Pages Router\nCAUTION\n\nThis guide is for Next.js Pages Router. If you are using Next.js App Router with React Server components, check out the RSC docs\n\nRecommended file structure​\n\nWe recommend a file structure like this one, although it is not enforced by tRPC. This is what you'll see in our examples. The rest of this page will take you through the process of adding tRPC in to this structure.\n\n.\n├── prisma  # <-- if prisma is added\n│   └── [..]\n├── src\n│   ├── pages\n│   │   ├── _app.tsx  # <-- add `withTRPC()`-HOC here\n│   │   ├── api\n│   │   │   └── trpc\n│   │   │       └── [trpc].ts  # <-- tRPC HTTP handler\n│   │   └── [..]\n│   ├── server\n│   │   ├── routers\n│   │   │   ├── _app.ts  # <-- main app router\n│   │   │   ├── post.ts  # <-- sub routers\n│   │   │   └── [..]\n│   │   ├── context.ts   # <-- create app context\n│   │   └── trpc.ts      # <-- procedure helpers\n│   └── utils\n│       └── trpc.ts  # <-- your typesafe tRPC hooks\n└── [..]\nCopy\nAdd tRPC to existing Next.js project​\n1. Install deps​\nnpm\nyarn\npnpm\nbun\ndeno\nnpm install @trpc/server @trpc/client @trpc/react-query @trpc/next @tanstack/react-query@latest zod\n\nThe Next.js integration is actually a combination of our React Query Integration and some Next.js specific integrations.\n\n2. Enable strict mode​\n\nIf you want to use Zod for input validation, make sure you have enabled strict mode in your tsconfig.json:\n\ntsconfig.json\n\"compilerOptions\": {\n+   \"strict\": true\n}\nCopy\n\nIf strict mode is too harsh, you'll at least want to enable strictNullChecks:\n\ntsconfig.json\n\"compilerOptions\": {\n+   \"strictNullChecks\": true\n}\nCopy\n3. Create a tRPC router​\n\nInitialize your tRPC backend in src/server/trpc.ts using the initTRPC function, and create your first router. We're going to make a simple \"hello world\" router and procedure here - but for deeper information on creating your tRPC API you should refer to:\n\nthe Quickstart guide and Backend usage docs for tRPC information\nthe Next.js Adapter docs for mounting tRPC within your Next.js server.\nView sample backend\nNOTE\n\nThe backend above is using the recommended file structure, but you can keep it simple and put everything in an API handler directly if you prefer.\n\n4. Create tRPC hooks​\n\nuse the createTRPCNext function to create a set of strongly-typed hooks from your API's type signature.\n\nutils/trpc.ts\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport type { AppRouter } from '../server/routers/_app';\nfunction getBaseUrl() {\n  if (typeof window !== 'undefined')\n    // browser should use relative path\n    return '';\n  if (process.env.VERCEL_URL)\n    // reference for vercel.com\n    return `https://${process.env.VERCEL_URL}`;\n  if (process.env.RENDER_INTERNAL_HOSTNAME)\n    // reference for render.com\n    return `http://${process.env.RENDER_INTERNAL_HOSTNAME}:${process.env.PORT}`;\n  // assume localhost\n  return `http://localhost:${process.env.PORT ?? 3000}`;\n}\nexport const trpc = createTRPCNext<AppRouter>({\n  config(config) {\n    return {\n      links: [\n        httpBatchLink({\n          /**\n           * If you want to use SSR, you need to use the server's full URL\n           * @see https://trpc.io/docs/v11/ssr\n           **/\n          url: `${getBaseUrl()}/api/trpc`,\n          // You can pass any HTTP headers you wish here\n          async headers() {\n            return {\n              // authorization: getAuthCookie(),\n            };\n          },\n        }),\n      ],\n    };\n  },\n  /**\n   * @see https://trpc.io/docs/v11/ssr\n   **/\n  ssr: false,\n});\nCopy\nNOTE\n\ncreateTRPCNext does not work with the tRPC-v9 interop mode. If you are migrating from v9 using interop, you should continue using the old way of initializing tRPC.\n\n5. Configure _app.tsx​\n\nWrap your root app page in the trpc.withTRPC HOC, similar to this:\n\npages/_app.tsx\nimport type { AppType } from 'next/app';\nimport { trpc } from '../utils/trpc';\nconst MyApp: AppType = ({ Component, pageProps }) => {\n  return <Component {...pageProps} />;\n};\nexport default trpc.withTRPC(MyApp);\nCopy\n6. Make an API request​\n\nYou're all set!\n\nYou can now use the React hooks you have just created to invoke your API. For more detail see the React Query Integration\n\npages/index.tsx\nimport { trpc } from '../utils/trpc';\nexport default function IndexPage() {\n  const hello = trpc.hello.useQuery({ text: 'client' });\n  if (!hello.data) {\n    return <div>Loading...</div>;\n  }\n  return (\n    <div>\n      <p>{hello.data.greeting}</p>\n    </div>\n  );\n}\nCopy\ncreateTRPCNext() options​\nconfig-callback​\n\nThe config-argument is a function that returns an object that configures the tRPC and React Query clients. This function has a ctx input that gives you access to the Next.js req object, among other things. The returned value can contain the following properties:\n\nRequired:\nlinks to customize the flow of data between tRPC Client and the tRPC Server. Read more.\nOptional:\nqueryClientConfig: a configuration object for the React Query QueryClient used internally by the tRPC React hooks: QueryClient docs\nqueryClient: a React Query QueryClient instance\nNote: You can only provide either a queryClient or a queryClientConfig.\ntransformer: a transformer applied to outgoing payloads. Read more about Data Transformers\nabortOnUnmount: determines if in-flight requests will be cancelled on component unmount. This defaults to false.\noverrides: (default: undefined)​\n\nConfigure overrides for React Query's hooks.\n\nssr-boolean (default: false)​\n\nWhether tRPC should await queries when server-side rendering a page. Defaults to false.\n\nresponseMeta-callback​\n\nAbility to set request headers and HTTP status when server-side rendering.\n\nExample​\nutils/trpc.ts\nimport { createTRPCNext } from '@trpc/next';\nimport type { AppRouter } from '../pages/api/trpc/[trpc]';\nexport const trpc = createTRPCNext<AppRouter>({\n  config(config) {\n    /* [...] */\n  },\n});\nCopy\nNext steps​\n\nBrowse the rest of the docs to learn more about things like authorization, middlewares, and error handling.\n\nYou can also find information about queries and mutations now that you're using @trpc/react-query.\n\nEdit this page"
  },
  {
    "title": "Server-Side Rendering | tRPC",
    "url": "https://trpc.io/docs/client/nextjs/ssr",
    "html": "Client Usage\nNext.js Integration\nServer-Side Rendering (SSR)\nVersion: 11.x\nServer-Side Rendering\n\nTo enable SSR just set ssr: true in your createTRPCNext config callback.\n\nINFO\n\nWhen you enable SSR, tRPC will use getInitialProps to prefetch all queries on the server. This results in problems like this when you use getServerSideProps, and solving it is out of our hands.\n\n \nAlternatively, you can leave SSR disabled (the default) and use Server-Side Helpers to prefetch queries in getStaticProps or getServerSideProps.\n\nIn order to execute queries properly during the server-side render step we need to add extra logic inside our config:\n\nAdditionally, consider Response Caching.\n\nutils/trpc.ts\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport { ssrPrepass } from '@trpc/next/ssrPrepass';\nimport superjson from 'superjson';\nimport type { AppRouter } from './api/trpc/[trpc]';\nexport const trpc = createTRPCNext<AppRouter>({\n  ssr: true,\n  ssrPrepass,\n  config(config) {\n    const { ctx } = opts;\n    if (typeof window !== 'undefined') {\n      // during client requests\n      return {\n        links: [\n          httpBatchLink({\n            url: '/api/trpc',\n          }),\n        ],\n      };\n    }\n    return {\n      links: [\n        httpBatchLink({\n          // The server needs to know your app's full url\n          url: `${getBaseUrl()}/api/trpc`,\n          /**\n           * Set custom request headers on every request from tRPC\n           * @see https://trpc.io/docs/v10/header\n           */\n          headers() {\n            if (!ctx?.req?.headers) {\n              return {};\n            }\n            // To use SSR properly, you need to forward client headers to the server\n            // This is so you can pass through things like cookies when we're server-side rendering\n            return {\n              cookie: ctx.req.headers.cookie,\n            };\n          },\n        }),\n      ],\n    };\n  },\n});\nCopy\n\nor, if you want to SSR conditional on a given request, you can pass a callback to ssr. This callback can return a boolean, or a Promise resolving to a boolean:\n\nutils/trpc.ts\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport superjson from 'superjson';\nimport type { AppRouter } from './api/trpc/[trpc]';\nexport const trpc = createTRPCNext<AppRouter>({\n  config(config) {\n    const { ctx } = opts;\n    if (typeof window !== 'undefined') {\n      // during client requests\n      return {\n        links: [\n          httpBatchLink({\n            url: '/api/trpc',\n          }),\n        ],\n      };\n    }\n    return {\n      links: [\n        httpBatchLink({\n          // The server needs to know your app's full url\n          url: `${getBaseUrl()}/api/trpc`,\n          /**\n           * Set custom request headers on every request from tRPC\n           * @see https://trpc.io/docs/v10/header\n           */\n          headers() {\n            if (!ctx?.req?.headers) {\n              return {};\n            }\n            // To use SSR properly, you need to forward client headers to the server\n            // This is so you can pass through things like cookies when we're server-side rendering\n            return {\n              cookie: ctx.req.headers.cookie,\n            };\n          },\n        }),\n      ],\n    };\n  },\n  ssr(opts) {\n    // only SSR if the request is coming from a bot\n    return opts.ctx?.req?.headers['user-agent']?.includes('bot');\n  },\n});\nCopy\npages/_app.tsx\nimport { trpc } from '~/utils/trpc';\nimport type { AppProps } from 'next/app';\nimport React from 'react';\nconst MyApp: AppType = ({ Component, pageProps }: AppProps) => {\n  return <Component {...pageProps} />;\n};\nexport default trpc.withTRPC(MyApp);\nCopy\nFAQ​\nQ: Why do I need to forward the client's headers to the server manually? Why doesn't tRPC automatically do that for me?​\n\nWhile it's rare that you wouldn't want to forward the client's headers to the server when doing SSR, you might want to add things dynamically in the headers. Therefore, tRPC doesn't want to take responsibility for header keys colliding, etc.\n\nQ: Why do I need to delete the connection header when using SSR on Node 18?​\n\nIf you don't remove the connection header, the data fetching will fail with TRPCClientError: fetch failed because connection is a forbidden header name.\n\nQ: Why do I still see network requests being made in the Network tab?​\n\nBy default, @tanstack/react-query (which we use for the data fetching hooks) refetches data on mount and window refocus, even if it's already got initial data via SSR. This ensures data is always up-to-date. See the page on SSG if you'd like to disable this behavior.\n\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/nextjs/ssg",
    "html": "Client Usage\nNext.js Integration\nStatic Site Generation (SSG)\nVersion: 11.x\nStatic Site Generation\nTIP\n\nReference project: https://github.com/trpc/examples-next-prisma-todomvc\n\nStatic site generation requires executing tRPC queries inside getStaticProps on each page.\n\nThis can be done using server-side helpers to prefetch the queries, dehydrate them, and pass it to the page. The queries will then automatically pick up the trpcState and use it as an initial value.\n\nFetch data in getStaticProps​\npages/posts/[id].tsx\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport { prisma } from '~/server/context';\nimport { appRouter } from '~/server/routers/_app';\nimport { trpc } from '~/utils/trpc';\nimport {\n  GetStaticPaths,\n  GetStaticPropsContext,\n  InferGetStaticPropsType,\n} from 'next';\nimport superjson from 'superjson';\nexport async function getStaticProps(\n  context: GetStaticPropsContext<{ id: string }>,\n) {\n  const helpers = createServerSideHelpers({\n    router: appRouter,\n    ctx: {},\n    transformer: superjson, // optional - adds superjson serialization\n  });\n  const id = context.params?.id as string;\n  // prefetch `post.byId`\n  await helpers.post.byId.prefetch({ id });\n  return {\n    props: {\n      trpcState: helpers.dehydrate(),\n      id,\n    },\n    revalidate: 1,\n  };\n}\nexport const getStaticPaths: GetStaticPaths = async () => {\n  const posts = await prisma.post.findMany({\n    select: {\n      id: true,\n    },\n  });\n  return {\n    paths: posts.map((post) => ({\n      params: {\n        id: post.id,\n      },\n    })),\n    // https://nextjs.org/docs/pages/api-reference/functions/get-static-paths#fallback-blocking\n    fallback: 'blocking',\n  };\n};\nexport default function PostViewPage(\n  props: InferGetStaticPropsType<typeof getStaticProps>,\n) {\n  const { id } = props;\n  const postQuery = trpc.post.byId.useQuery({ id });\n  if (postQuery.status !== 'success') {\n    // won't happen since we're using `fallback: \"blocking\"`\n    return <>Loading...</>;\n  }\n  const { data } = postQuery;\n  return (\n    <>\n      <h1>{data.title}</h1>\n      <em>Created {data.createdAt.toLocaleDateString('en-us')}</em>\n      <p>{data.text}</p>\n      <h2>Raw data:</h2>\n      <pre>{JSON.stringify(data, null, 4)}</pre>\n    </>\n  );\n}\nCopy\n\nNote that the default behaviour of react-query is to refetch the data on the client-side when it mounts, so if you want to only fetch the data via getStaticProps, you need to set refetchOnMount and refetchOnWindowFocus to false in the query options.\n\nThis might be preferable if you want to minimize the number of requests to your API, which might be necessary if you're using a third-party rate-limited API for example.\n\nThis can be done per query:\n\nconst data = trpc.example.useQuery(\n  // if your query takes no input, make sure that you don't\n  // accidentally pass the query options as the first argument\n  undefined,\n  { refetchOnMount: false, refetchOnWindowFocus: false },\n);\nCopy\n\nOr globally, if every query across your app should behave the same way:\n\nutils/trpc.ts\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport superjson from 'superjson';\nimport type { AppRouter } from './api/trpc/[trpc]';\nexport const trpc = createTRPCNext<AppRouter>({\n  config(config) {\n    return {\n      links: [\n        httpBatchLink({\n          url: `${getBaseUrl()}/api/trpc`,\n        }),\n      ],\n      // Change options globally\n      queryClientConfig: {\n        defaultOptions: {\n          queries: {\n            refetchOnMount: false,\n            refetchOnWindowFocus: false,\n          },\n        },\n      },\n    },\n  },\n});\nCopy\n\nBe careful with this approach if your app has a mixture of static and dynamic queries.\n\nEdit this page"
  },
  {
    "title": "Server-Side Helpers | tRPC",
    "url": "https://trpc.io/docs/client/nextjs/server-side-helpers",
    "html": "Client Usage\nNext.js Integration\nServer-Side Helpers\nVersion: 11.x\nServer-Side Helpers\n\nThe server-side helpers provides you with a set of helper functions that you can use to prefetch queries on the server. This is useful for SSG, but also for SSR if you opt not to use ssr: true.\n\nPrefetching via the server-side helpers allows populating the query cache on the server, which means that these queries do not have to fetch on the client initially.\n\nThere are 2 ways to use the server-side helpers.​\n1. Internal router​\n\nThis method is used when you have direct access to your tRPC router. e.g. when developing a monolithic Next.js application.\n\nUsing the helpers makes tRPC call your procedures directly on the server, without an HTTP request, similar to server-side calls. That also means that you don't have the request and response at hand like you usually do. Make sure you're instantiating the server-side helpers with a context without req & res, which are typically filled via the context creation. We recommend the concept of \"inner\" and \"outer\" context in that scenario.\n\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport { createContext } from '~/server/context';\nimport superjson from 'superjson';\nconst helpers = createServerSideHelpers({\n  router: appRouter,\n  ctx: await createContext(),\n  transformer: superjson, // optional - adds superjson serialization\n});\nCopy\n2. External router​\n\nThis method is used when you don't have direct access to your tRPC router. e.g. when developing a Next.js application and a standalone API hosted separately.\n\nimport { createTRPCClient } from '@trpc/client';\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport superjson from 'superjson';\nconst proxyClient = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000/api/trpc',\n    }),\n  ],\n});\nconst helpers = createServerSideHelpers({\n  client: proxyClient,\n});\nCopy\nHelpers usage​\n\nThe server-side helpers methods return an object much like the tRPC client, with all of your routers as keys. However, rather than useQuery and useMutation, you get prefetch, fetch, prefetchInfinite, and fetchInfinite functions.\n\nThe primary difference between prefetch and fetch is that fetch acts much like a normal function call, returning the result of the query, whereas prefetch does not return the result and never throws - if you need that behavior, use fetch instead. Instead, prefetch will add the query to the cache, which you then dehydrate and send to the client.\n\nreturn {\n  props: {\n    // very important - use `trpcState` as the key\n    trpcState: helpers.dehydrate(),\n  },\n};\nCopy\n\nThe rule of thumb is prefetch for queries that you know you'll need on the client, and fetch for queries that you want to use the result of on the server.\n\nThe functions are all wrappers around react-query functions. Please check out their docs to learn more about them in detail.\n\nINFO\n\nFor a full example, see our E2E SSG test example\n\nNext.js Example​\npages/posts/[id].tsx\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport { appRouter } from '~/server/routers/_app';\nimport { trpc } from '~/utils/trpc';\nimport { GetServerSidePropsContext, InferGetServerSidePropsType } from 'next';\nimport superjson from 'superjson';\nexport async function getServerSideProps(\n  context: GetServerSidePropsContext<{ id: string }>,\n) {\n  const helpers = createServerSideHelpers({\n    router: appRouter,\n    ctx: {},\n    transformer: superjson,\n  });\n  const id = context.params?.id as string;\n  /*\n   * Prefetching the `post.byId` query.\n   * `prefetch` does not return the result and never throws - if you need that behavior, use `fetch` instead.\n   */\n  await helpers.post.byId.prefetch({ id });\n  // Make sure to return { props: { trpcState: helpers.dehydrate() } }\n  return {\n    props: {\n      trpcState: helpers.dehydrate(),\n      id,\n    },\n  };\n}\nexport default function PostViewPage(\n  props: InferGetServerSidePropsType<typeof getServerSideProps>,\n) {\n  const { id } = props;\n  const postQuery = trpc.post.byId.useQuery({ id });\n  if (postQuery.status !== 'success') {\n    // won't happen since the query has been prefetched\n    return <>Loading...</>;\n  }\n  const { data } = postQuery;\n  return (\n    <>\n      <h1>{data.title}</h1>\n      <em>Created {data.createdAt.toLocaleDateString()}</em>\n      <p>{data.text}</p>\n      <h2>Raw data:</h2>\n      <pre>{JSON.stringify(data, null, 4)}</pre>\n    </>\n  );\n}\nCopy\nEdit this page"
  },
  {
    "title": "Aborting Procedure Calls | tRPC",
    "url": "https://trpc.io/docs/client/nextjs/aborting-procedure-calls",
    "html": "Client Usage\nNext.js Integration\nAborting Procedure Calls\nVersion: 11.x\nAborting Procedure Calls\n\nBy default, tRPC does not cancel requests on unmount. If you want to opt into this behavior, you can provide abortOnUnmount in your configuration callback.\n\nGlobally​\nclient.ts\n// @filename: utils.ts\nimport { createTRPCNext } from '@trpc/next';\n \nexport const trpc = createTRPCNext<AppRouter>({\n  config() {\n    return {\n      // ...\n      abortOnUnmount: true,\n    };\n  },\n});\nCopy\nPer-request​\n\nYou may also override this behavior at the request level.\n\nclient.ts\n// @filename: pages/posts/[id].tsx\nimport { trpc } from '~/utils/trpc';\n \nconst PostViewPage: NextPageWithLayout = () => {\n  const id = useRouter().query.id as string;\n  const postQuery = trpc.post.byId.useQuery({ id }, { trpc: { abortOnUnmount: true } });\n \n  return (...)\n}\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/react/disabling-queries",
    "html": "Client Usage\nReact Query Integration (Classic)\nDisabling Queries\nVersion: 11.x\nDisabling Queries\n\nTo disable queries, you can pass skipToken as the first argument to useQuery or useInfiniteQuery. This will prevent the query from being executed.\n\nTypesafe conditional queries using skipToken​\nimport { skipToken } from '@tanstack/react-query';\nexport function MyComponent() {\nconst [name, setName] = useState<string | undefined>();\nconst result = trpc.getUserByName.useQuery(name ? { name: name } : skipToken);\n  return (\n    ...\n  )\n}\nCopy\nEdit this page"
  },
  {
    "title": "TanStack React Query | tRPC",
    "url": "https://trpc.io/docs/client/tanstack-react-query/setup",
    "html": "Client Usage\nTanStack React Query (⭐️)\nSetup\nVersion: 11.x\nTanStack React Query\n\nCompared to our classic React Query Integration this client is simpler and more TanStack Query-native, providing factories for common TanStack React Query interfaces like QueryKeys, QueryOptions, and MutationOptions. We think it's the future and recommend using this over the classic client, read the announcement post for more information about this change.\n\nTIP\n\nYou can try this integration out on the homepage of tRPC.io: https://trpc.io/?try=minimal-react#try-it-out\n\n❓ Do I have to use an integration?\nSetup​\n1. Install dependencies​\n\nThe following dependencies should be installed\n\nnpm\nyarn\npnpm\nbun\ndeno\nnpm install @trpc/server @trpc/client @trpc/tanstack-react-query @tanstack/react-query\n2. Import your AppRouter​\n\nImport your AppRouter type into the client application. This type holds the shape of your entire API.\n\nutils/trpc.ts\nimport type { AppRouter } from '../server/router';\nCopy\nTIP\n\nBy using import type you ensure that the reference will be stripped at compile-time, meaning you don't inadvertently import server-side code into your client. For more information, see the Typescript docs.\n\n3a. Set up the tRPC context provider​\n\nIn cases where you rely on React context, such as when using server-side rendering in full-stack frameworks like Next.js, it's important to create a new QueryClient for each request so that your users don't end up sharing the same cache, you can use the createTRPCContext to create a set of type-safe context providers and consumers from your AppRouter type signature.\n\nutils/trpc.ts\nimport { createTRPCContext } from '@trpc/tanstack-react-query';\nimport type { AppRouter } from '../server/router';\n \nexport const { TRPCProvider, useTRPC, useTRPCClient } = createTRPCContext<AppRouter>();\nCopy\n\nThen, create a tRPC client, and wrap your application in the TRPCProvider, as below. You will also need to set up and connect React Query, which they document in more depth.\n\nTIP\n\nIf you already use React Query in your application, you should re-use the QueryClient and QueryClientProvider you already have. You can read more about the QueryClient initialization in the React Query docs.\n\ncomponents/App.tsx\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport { useState } from 'react';\nimport { TRPCProvider } from './utils/trpc';\nfunction makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        // With SSR, we usually want to set some default staleTime\n        // above 0 to avoid refetching immediately on the client\n        staleTime: 60 * 1000,\n      },\n    },\n  });\n}\nlet browserQueryClient: QueryClient | undefined = undefined;\nfunction getQueryClient() {\n  if (typeof window === 'undefined') {\n    // Server: always make a new query client\n    return makeQueryClient();\n  } else {\n    // Browser: make a new query client if we don't already have one\n    // This is very important, so we don't re-make a new client if React\n    // suspends during the initial render. This may not be needed if we\n    // have a suspense boundary BELOW the creation of the query client\n    if (!browserQueryClient) browserQueryClient = makeQueryClient();\n    return browserQueryClient;\n  }\n}\nexport function App() {\n  const queryClient = getQueryClient();\n  const [trpcClient] = useState(() =>\n    createTRPCClient<AppRouter>({\n      links: [\n        httpBatchLink({\n          url: 'http://localhost:2022',\n        }),\n      ],\n    }),\n  );\n  return (\n    <QueryClientProvider client={queryClient}>\n      <TRPCProvider trpcClient={trpcClient} queryClient={queryClient}>\n        {/* Your app here */}\n      </TRPCProvider>\n    </QueryClientProvider>\n  );\n}\nCopy\n3b. Set up with Query/Mutation Key Prefixing enabled​\n\nIf you want to prefix all queries and mutations with a specific key, see Query Key Prefixing for setup and usage examples.\n\n3c. Set up without React context​\n\nWhen building an SPA using only client-side rendering with something like Vite, you can create the QueryClient and tRPC client outside of React context as singletons.\n\nutils/trpc.ts\nimport { QueryClient } from '@tanstack/react-query';\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport { createTRPCOptionsProxy } from '@trpc/tanstack-react-query';\nimport type { AppRouter } from '../server/router';\nexport const queryClient = new QueryClient();\nconst trpcClient = createTRPCClient<AppRouter>({\n  links: [httpBatchLink({ url: 'http://localhost:2022' })],\n});\nexport const trpc = createTRPCOptionsProxy<AppRouter>({\n  client: trpcClient,\n  queryClient,\n});\nCopy\ncomponents/App.tsx\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport React from 'react';\nimport { queryClient } from './utils/trpc';\nexport function App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      {/* Your app here */}\n    </QueryClientProvider>\n  );\n}\nCopy\n4. Fetch data​\n\nYou can now use the tRPC React Query integration to call queries and mutations on your API.\n\ncomponents/user-list.tsx\nimport { useMutation, useQuery } from '@tanstack/react-query';\nimport { useTRPC } from '../utils/trpc';\nexport default function UserList() {\n  const trpc = useTRPC(); // use `import { trpc } from './utils/trpc'` if you're using the singleton pattern\n  const userQuery = useQuery(trpc.getUser.queryOptions({ id: 'id_bilbo' }));\n  const userCreator = useMutation(trpc.createUser.mutationOptions());\n  return (\n    <div>\n      <p>{userQuery.data?.name}</p>\n      <button onClick={() => userCreator.mutate({ name: 'Frodo' })}>\n        Create Frodo\n      </button>\n    </div>\n  );\n}\nCopy\nEdit this page"
  },
  {
    "title": "TanStack React Query | tRPC",
    "url": "https://trpc.io/docs/client/tanstack-react-query/usage",
    "html": "Client Usage\nTanStack React Query (⭐️)\nUsage\nVersion: 11.x\nTanStack React Query\n\nCompared to our classic React Query Integration this client is simpler and more TanStack Query-native, providing factories for common TanStack React Query interfaces like QueryKeys, QueryOptions, and MutationOptions. We think it's the future and recommend using this over the classic client, read the announcement post for more information about this change.\n\nQuick example query​\nimport { useQuery } from '@tanstack/react-query';\nimport { useTRPC } from './trpc';\nfunction Users() {\n  const trpc = useTRPC();\n  const greetingQuery = useQuery(trpc.greeting.queryOptions({ name: 'Jerry' }));\n  // greetingQuery.data === 'Hello Jerry'\n}\nCopy\nUsage​\n\nThe philosophy of this client is to provide thin and type-safe factories which work natively and type-safely with Tanstack React Query. This means just by following the autocompletes the client gives you, you can focus on building just with the knowledge the TanStack React Query docs provide.\n\nexport default function Basics() {\n  const trpc = useTRPC();\n  const queryClient = useQueryClient();\n  // Create QueryOptions which can be passed to query hooks\n  const myQueryOptions = trpc.path.to.query.queryOptions({ /** inputs */ })\n  const myQuery = useQuery(myQueryOptions)\n  // or:\n  // useSuspenseQuery(myQueryOptions)\n  // useInfiniteQuery(myQueryOptions)\n  // Create MutationOptions which can be passed to useMutation\n  const myMutationOptions = trpc.path.to.mutation.mutationOptions()\n  const myMutation = useMutation(myMutationOptions)\n  // Create a QueryKey which can be used to manipulated many methods\n  // on TanStack's QueryClient in a type-safe manner\n  const myQueryKey = trpc.path.to.query.queryKey()\n  const invalidateMyQueryKey = () => {\n    queryClient.invalidateQueries({ queryKey: myQueryKey })\n  }\n  return (\n    // Your app here\n  )\n}\nCopy\n\nThe trpc object is fully type-safe and will provide autocompletes for all the procedures in your AppRouter. At the end of the proxy, the following methods are available:\n\nqueryOptions - querying data​\n\nAvailable for all query procedures. Provides a type-safe wrapper around Tanstack's queryOptions function. The first argument is the input for the procedure, and the second argument accepts any native Tanstack React Query options.\n\nconst queryOptions = trpc.path.to.query.queryOptions(\n  {\n    /** input */\n  },\n  {\n    // Any Tanstack React Query options\n    staleTime: 1000,\n  },\n);\nCopy\n\nYou can additionally provide a trpc object to the queryOptions function to provide tRPC request options to the client.\n\nconst queryOptions = trpc.path.to.query.queryOptions(\n  {\n    /** input */\n  },\n  {\n    trpc: {\n      // Provide tRPC request options to the client\n      context: {\n        // see https://trpc.io/docs/client/links#managing-context\n      },\n    },\n  },\n);\nCopy\n\nIf you want to disable a query in a type safe way, you can use skipToken:\n\nimport { skipToken } from '@tanstack/react-query';\nconst query = useQuery(\n  trpc.user.details.queryOptions(\n    user?.id && project?.id\n      ? {\n          userId: user.id,\n          projectId: project.id,\n        }\n      : skipToken,\n    {\n      staleTime: 1000,\n    },\n  ),\n);\nCopy\n\nThe result can be passed to useQuery or useSuspenseQuery hooks or query client methods like fetchQuery, prefetchQuery, prefetchInfiniteQuery, invalidateQueries, etc.\n\ninfiniteQueryOptions - querying infinite data​\n\nAvailable for all query procedures that takes a cursor input. Provides a type-safe wrapper around Tanstack's infiniteQueryOptions function. The first argument is the input for the procedure, and the second argument accepts any native Tanstack React Query options.\n\nconst infiniteQueryOptions = trpc.path.to.query.infiniteQueryOptions(\n  {\n    /** input */\n  },\n  {\n    // Any Tanstack React Query options\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  },\n);\nCopy\nqueryKey - getting the query key and performing operations on the query client​\n\nAvailable for all query procedures. Allows you to access the query key in a type-safe manner.\n\nconst queryKey = trpc.path.to.query.queryKey();\nCopy\n\nSince Tanstack React Query uses fuzzy matching for query keys, you can also create a partial query key for any sub-path to match all queries belonging to a router:\n\nconst queryKey = trpc.router.pathKey();\nCopy\n\nOr even the root path to match all tRPC queries:\n\nconst queryKey = trpc.pathKey();\nCopy\nqueryFilter - creating query filters​\n\nAvailable for all query procedures. Allows creating query filters in a type-safe manner.\n\nconst queryFilter = trpc.path.to.query.queryFilter(\n  {\n    /** input */\n  },\n  {\n    // Any Tanstack React Query filter\n    predicate: (query) => {\n      query.state.data;\n    },\n  },\n);\nCopy\n\nLike with query keys, if you want to run a filter across a whole router you can use pathFilter to target any sub-path.\n\nconst queryFilter = trpc.path.pathFilter({\n  // Any Tanstack React Query filter\n  predicate: (query) => {\n    query.state.data;\n  },\n});\nCopy\n\nUseful for creating filters that can be passed to client methods like queryClient.invalidateQueries etc.\n\nmutationOptions - creating mutation options​\n\nAvailable for all mutation procedures. Provides a type-safe identify function for constructing options that can be passed to useMutation.\n\nconst mutationOptions = trpc.path.to.mutation.mutationOptions({\n  // Any Tanstack React Query options\n  onSuccess: (data) => {\n    // do something with the data\n  },\n});\nCopy\nmutationKey - getting the mutation key​\n\nAvailable for all mutation procedures. Allows you to get the mutation key in a type-safe manner.\n\nconst mutationKey = trpc.path.to.mutation.mutationKey();\nCopy\nsubscriptionOptions - creating subscription options​\n\nTanStack does not provide a subscription hook, so we continue to expose our own abstraction here which works with a standard tRPC subscription setup. Available for all subscription procedures. Provides a type-safe identify function for constructing options that can be passed to useSubscription. Note that you need to have either the httpSubscriptionLink or wsLink configured in your tRPC client to use subscriptions.\n\nfunction SubscriptionExample() {\n  const trpc = useTRPC();\n  const subscription = useSubscription(\n    trpc.path.to.subscription.subscriptionOptions(\n      {\n        /** input */\n      },\n      {\n        enabled: true,\n        onStarted: () => {\n          // do something when the subscription is started\n        },\n        onData: (data) => {\n          // you can handle the data here\n        },\n        onError: (error) => {\n          // you can handle the error here\n        },\n        onConnectionStateChange: (state) => {\n          // you can handle the connection state here\n        },\n      },\n    ),\n  );\n  // Or you can handle the state here\n  subscription.data; // The lastly received data\n  subscription.error; // The lastly received error\n  /**\n   * The current status of the subscription.\n   * Will be one of: `'idle'`, `'connecting'`, `'pending'`, or `'error'`.\n   *\n   * - `idle`: subscription is disabled or ended\n   * - `connecting`: trying to establish a connection\n   * - `pending`: connected to the server, receiving data\n   * - `error`: an error occurred and the subscription is stopped\n   */\n  subscription.status;\n  // Reset the subscription (if you have an error etc)\n  subscription.reset();\n  return <>{/* ... */}</>;\n}\nCopy\nQuery Key Prefixing​\n\nWhen using multiple tRPC providers in a single application (e.g., connecting to different backend services), queries with the same path will collide in the cache. You can prevent this by enabling query key prefixing.\n\n// Without prefixes - these would collide!\nconst authQuery = useQuery(trpcAuth.list.queryOptions()); // auth service\nconst billingQuery = useQuery(trpcBilling.list.queryOptions()); // billing service\nCopy\n\nEnable the feature flag when creating your context:\n\nutils/trpc.ts\n// [...]\nconst billing = createTRPCContext<BillingRouter, { keyPrefix: true }>();\nexport const BillingProvider = billing.TRPCProvider;\nexport const useBilling = billing.useTRPC;\nexport const createBillingClient = () =>\n  createTRPCClient<BillingRouter>({\n    links: [\n      /* ... */\n    ],\n  });\nconst account = createTRPCContext<AccountRouter, { keyPrefix: true }>();\nexport const AccountProvider = account.TRPCProvider;\nexport const useAccount = account.useTRPC;\nexport const createAccountClient = () =>\n  createTRPCClient<AccountRouter>({\n    links: [\n      /* ... */\n    ],\n  });\nCopy\nApp.tsx\n// [...]\nexport function App() {\n  const [queryClient] = useState(() => new QueryClient());\n  const [billingClient] = useState(() => createBillingClient());\n  const [accountClient] = useState(() => createAccountClient());\n  return (\n    <QueryClientProvider client={queryClient}>\n      <BillingProvider\n        trpcClient={billingClient}\n        queryClient={queryClient}\n        keyPrefix=\"billing\"\n      >\n        <AccountProvider\n          trpcClient={accountClient}\n          queryClient={queryClient}\n          keyPrefix=\"account\"\n        >\n          {/* ... */}\n        </AccountProvider>\n      </BillingProvider>\n    </QueryClientProvider>\n  );\n}\nCopy\ncomponents/MyComponent.tsx\n// [...]\nexport function MyComponent() {\n  const billing = useBilling();\n  const account = useAccount();\n  const billingList = useQuery(billing.list.queryOptions());\n  const accountList = useQuery(account.list.queryOptions());\n  return (\n    <div>\n      <div>Billing: {JSON.stringify(billingList.data ?? null)}</div>\n      <div>Account: {JSON.stringify(accountList.data ?? null)}</div>\n    </div>\n  );\n}\nCopy\n\nThe query keys will be properly prefixed to avoid collisions:\n\n// Example of how the query keys look with prefixes\nconst queryKeys = [\n  [['billing'], ['list'], { type: 'query' }],\n  [['account'], ['list'], { type: 'query' }],\n];\nCopy\nInferring Input and Output types​\n\nWhen you need to infer the input and output types for a procedure or router, there are 2 options available depending on the situation.\n\nInfer the input and output types of a full router\n\nimport type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';\nimport { AppRouter } from './path/to/server';\nexport type Inputs = inferRouterInputs<AppRouter>;\nexport type Outputs = inferRouterOutputs<AppRouter>;\nCopy\n\nInfer types for a single procedure\n\nimport type { inferInput, inferOutput } from '@trpc/tanstack-react-query';\nfunction Component() {\n  const trpc = useTRPC();\n  type Input = inferInput<typeof trpc.path.to.procedure>;\n  type Output = inferOutput<typeof trpc.path.to.procedure>;\n}\nCopy\nAccessing the tRPC client​\n\nIf you used the setup with React Context, you can access the tRPC client using the useTRPCClient hook.\n\nimport { useTRPCClient } from './trpc';\nfunction Component() {\n  const trpcClient = useTRPCClient();\n  const result = await trpcClient.path.to.procedure.query({\n    /** input */\n  });\n}\nCopy\n\nIf you setup without React Context, you can import the global client instance directly instead.\n\nimport { client } from './trpc';\nconst result = await client.path.to.procedure.query({\n  /** input */\n});\nCopy\nEdit this page"
  },
  {
    "title": "Migrating from the classic React Client | tRPC",
    "url": "https://trpc.io/docs/client/tanstack-react-query/migrating",
    "html": "Client Usage\nTanStack React Query (⭐️)\nMigrating\nVersion: 11.x\nMigrating from the classic React Client\n\nThere are a few approaches to migrate over, and this library is a significant departure from the classic client, so we're not expecting anybody to do it in one shot. But you will probably want to try a combination of...\n\nCodemod migration​\nINFO\n\nThe codemod is a work in progress and we're looking for help to make it better. If you're interested in contributing to the codemod, please see Julius' comment here.\n\nWe're working on a codemod to help you migrate your existing codebase over to the new client. This is already available to try but we need your feedback and contributions to improve it. Codemods are very tricky to get right so we're looking for your help to make it as effective as possible.\n\nRun our upgrade CLI:\n\nnpx @trpc/upgrade\nCopy\n\nWhen prompted, select the transforms Migrate Hooks to xxxOptions API and Migrate context provider setup.\n\nGradual migration​\n\nThe new and classic clients are compatible with each other and can live together in the same application. This means you can start migrating by using the new client in new parts of your application, and gradually migrate over existing usage as you see fit. Most importantly, Query Keys are identical, which means you can use the new client and classic client together and still rely on TanStack Query's caching.\n\nMigrating Queries​\n\nA classic query would look like this\n\nimport { trpc } from './trpc';\nfunction Users() {\n  const greetingQuery = trpc.greeting.useQuery({ name: 'Jerry' });\n  // greetingQuery.data === 'Hello Jerry'\n}\nCopy\n\nand changes to\n\nimport { useQuery } from '@tanstack/react-query';\nimport { useTRPC } from './trpc';\nfunction Users() {\n  const trpc = useTRPC();\n  const greetingQuery = useQuery(trpc.greeting.queryOptions({ name: 'Jerry' }));\n  // greetingQuery.data === 'Hello Jerry'\n}\nCopy\nMigrating Invalidations and other QueryClient usages​\n\nA classic query would look like this\n\nimport { trpc } from './trpc';\nfunction Users() {\n  const utils = trpc.useUtils();\n  async function invalidateGreeting() {\n    await utils.greeting.invalidate({ name: 'Jerry' });\n  }\n}\nCopy\n\nand changes to\n\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\nimport { useTRPC } from './trpc';\nfunction Users() {\n  const trpc = useTRPC();\n  const queryClient = useQueryClient();\n  async function invalidateGreeting() {\n    await queryClient.invalidateQueries(\n      trpc.greeting.queryFilter({ name: 'Jerry' }),\n    );\n  }\n}\nCopy\n\nThis is the same for any QueryClient usage, instead of using tRPC's useUtils you can now follow the TanStack documentation directly\n\nMigrating Mutations​\n\nA classic mutation might look like this\n\nimport { trpc } from './trpc';\nfunction Users() {\n  const createUserMutation = trpc.createUser.useMutation();\n  createUserMutation.mutate({ name: 'Jerry' });\n}\nCopy\n\nand changes to\n\nimport { useMutation } from '@tanstack/react-query';\nimport { useTRPC } from './trpc';\nfunction Users() {\n  const trpc = useTRPC();\n  const createUserMutation = useMutation(trpc.createUser.mutationOptions());\n  createUserMutation.mutate({ name: 'Jerry' });\n}\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/tanstack-react-query/server-components",
    "html": "Client Usage\nTanStack React Query (⭐️)\nServer Components\nVersion: 11.x\nSet up with React Server Components\n\nThis guide is an overview of how one may use tRPC with a React Server Components (RSC) framework such as Next.js App Router. Be aware that RSC on its own solves a lot of the same problems tRPC was designed to solve, so you may not need tRPC at all.\n\nThere are also not a one-size-fits-all way to integrate tRPC with RSCs, so see this guide as a starting point and adjust it to your needs and preferences.\n\nINFO\n\nIf you're looking for how to use tRPC with Server Actions, check out this blog post by Julius.\n\nCAUTION\n\nPlease read React Query's Advanced Server Rendering docs before proceeding to understand the different types of server rendering and what footguns to avoid.\n\nAdd tRPC to existing projects​\n1. Install deps​\nnpm\nyarn\npnpm\nbun\ndeno\nnpm install @trpc/server @trpc/client @trpc/tanstack-react-query @tanstack/react-query@latest zod client-only server-only\n2. Create a tRPC router​\n\nInitialize your tRPC backend in trpc/init.ts using the initTRPC function, and create your first router. We're going to make a simple \"hello world\" router and procedure here - but for deeper information on creating your tRPC API you should refer to the Quickstart guide and Backend usage docs for tRPC information.\n\nINFO\n\nThe file names used here are not enforced by tRPC. You may use any file structure you wish.\n\nView sample backend\n3. Create a Query Client factory​\n\nCreate a shared file trpc/query-client.ts that exports a function that creates a QueryClient instance.\n\ntrpc/query-client.ts\nimport {\n  defaultShouldDehydrateQuery,\n  QueryClient,\n} from '@tanstack/react-query';\nimport superjson from 'superjson';\nexport function makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        staleTime: 30 * 1000,\n      },\n      dehydrate: {\n        // serializeData: superjson.serialize,\n        shouldDehydrateQuery: (query) =>\n          defaultShouldDehydrateQuery(query) ||\n          query.state.status === 'pending',\n      },\n      hydrate: {\n        // deserializeData: superjson.deserialize,\n      },\n    },\n  });\n}\nCopy\n\nWe're setting a few default options here:\n\nstaleTime: With SSR, we usually want to set some default staleTime above 0 to avoid refetching immediately on the client.\nshouldDehydrateQuery: This is a function that determines whether a query should be dehydrated or not. Since the RSC transport protocol supports hydrating promises over the network, we extend the defaultShouldDehydrateQuery function to also include queries that are still pending. This will allow us to start prefetching in a server component high up the tree, then consuming that promise in a client component further down.\nserializeData and deserializeData (optional): If you set up a data transformer in the previous step, set this option to make sure the data is serialized correctly when hydrating the query client over the server-client boundary.\n4. Create a tRPC client for Client Components​\n\nThe trpc/client.tsx is the entrypoint when consuming your tRPC API from client components. In here, import the type definition of your tRPC router and create typesafe hooks using createTRPCContext. We'll also export our context provider from this file.\n\ntrpc/client.tsx\n'use client';\n// ^-- to make sure we can mount the Provider from a server component\nimport type { QueryClient } from '@tanstack/react-query';\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport { createTRPCContext } from '@trpc/tanstack-react-query';\nimport { useState } from 'react';\nimport { makeQueryClient } from './query-client';\nimport type { AppRouter } from './routers/_app';\nexport const { TRPCProvider, useTRPC } = createTRPCContext<AppRouter>();\nlet browserQueryClient: QueryClient;\nfunction getQueryClient() {\n  if (typeof window === 'undefined') {\n    // Server: always make a new query client\n    return makeQueryClient();\n  }\n  // Browser: make a new query client if we don't already have one\n  // This is very important, so we don't re-make a new client if React\n  // suspends during the initial render. This may not be needed if we\n  // have a suspense boundary BELOW the creation of the query client\n  if (!browserQueryClient) browserQueryClient = makeQueryClient();\n  return browserQueryClient;\n}\nfunction getUrl() {\n  const base = (() => {\n    if (typeof window !== 'undefined') return '';\n    if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;\n    return 'http://localhost:3000';\n  })();\n  return `${base}/api/trpc`;\n}\nexport function TRPCReactProvider(\n  props: Readonly<{\n    children: React.ReactNode;\n  }>,\n) {\n  // NOTE: Avoid useState when initializing the query client if you don't\n  //       have a suspense boundary between this and the code that may\n  //       suspend because React will throw away the client on the initial\n  //       render if it suspends and there is no boundary\n  const queryClient = getQueryClient();\n  const [trpcClient] = useState(() =>\n    createTRPCClient<AppRouter>({\n      links: [\n        httpBatchLink({\n          // transformer: superjson, <-- if you use a data transformer\n          url: getUrl(),\n        }),\n      ],\n    }),\n  );\n  return (\n    <QueryClientProvider client={queryClient}>\n      <TRPCProvider trpcClient={trpcClient} queryClient={queryClient}>\n        {props.children}\n      </TRPCProvider>\n    </QueryClientProvider>\n  );\n}\nCopy\n\nMount the provider in the root of your application (e.g. app/layout.tsx when using Next.js).\n\n5. Create a tRPC caller for Server Components​\n\nTo prefetch queries from server components, we create a proxy from our router. You can also pass in a client if your router is on a separate server.\n\ntrpc/server.tsx\nimport 'server-only'; // <-- ensure this file cannot be imported from the client\nimport { createTRPCOptionsProxy } from '@trpc/tanstack-react-query';\nimport { cache } from 'react';\nimport { createTRPCContext } from './init';\nimport { makeQueryClient } from './query-client';\nimport { appRouter } from './routers/_app';\n// IMPORTANT: Create a stable getter for the query client that\n//            will return the same client during the same request.\nexport const getQueryClient = cache(makeQueryClient);\nexport const trpc = createTRPCOptionsProxy({\n  ctx: createTRPCContext,\n  router: appRouter,\n  queryClient: getQueryClient,\n});\n// If your router is on a separate server, pass a client:\ncreateTRPCOptionsProxy({\n  client: createTRPCClient({\n    links: [httpLink({ url: '...' })],\n  }),\n  queryClient: getQueryClient,\n});\nCopy\nUsing your API​\n\nNow you can use your tRPC API in your app. While you can use the React Query hooks in client components just like you would in any other React app, we can take advantage of the RSC capabilities by prefetching queries in a server component high up the tree. You may be familiar with this concept as \"render as you fetch\" commonly implemented as loaders. This means the request fires as soon as possible but without suspending until the data is needed by using the useQuery or useSuspenseQuery hooks.\n\nThis approach leverages Next.js App Router's streaming capabilities, initiating the query on the server and streaming data to the client as it becomes available. It optimizes both the time to first byte in the browser and the data fetch time, resulting in faster page loads. However, greeting.data may initially be undefined before the data streams in.\n\nIf you prefer to avoid this initial undefined state, you can await the prefetchQuery call. This ensures the query on the client always has data on first render, but it comes with a tradeoff - the page will load more slowly since the server must complete the query before sending HTML to the client.\n\napp/page.tsx\nimport { dehydrate, HydrationBoundary } from '@tanstack/react-query';\nimport { getQueryClient, trpc } from '~/trpc/server';\nimport { ClientGreeting } from './client-greeting';\nexport default async function Home() {\n  const queryClient = getQueryClient();\n  void queryClient.prefetchQuery(\n    trpc.hello.queryOptions({\n      /** input */\n    }),\n  );\n  return (\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      <div>...</div>\n      {/** ... */}\n      <ClientGreeting />\n    </HydrationBoundary>\n  );\n}\nCopy\napp/client-greeting.tsx\n'use client';\n// <-- hooks can only be used in client components\nimport { useQuery } from '@tanstack/react-query';\nimport { useTRPC } from '~/trpc/client';\nexport function ClientGreeting() {\n  const trpc = useTRPC();\n  const greeting = useQuery(trpc.hello.queryOptions({ text: 'world' }));\n  if (!greeting.data) return <div>Loading...</div>;\n  return <div>{greeting.data.greeting}</div>;\n}\nCopy\nTIP\n\nYou can also create a prefetch and HydrateClient helper functions to make it a bit more consice and reusable:\n\ntrpc/server.tsx\nexport function HydrateClient(props: { children: React.ReactNode }) {\n  const queryClient = getQueryClient();\n  return (\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      {props.children}\n    </HydrationBoundary>\n  );\n}\nexport function prefetch<T extends ReturnType<TRPCQueryOptions<any>>>(\n  queryOptions: T,\n) {\n  const queryClient = getQueryClient();\n  if (queryOptions.queryKey[1]?.type === 'infinite') {\n    void queryClient.prefetchInfiniteQuery(queryOptions as any);\n  } else {\n    void queryClient.prefetchQuery(queryOptions);\n  }\n}\nCopy\n\nThen you can use it like this:\n\nimport { HydrateClient, prefetch, trpc } from '~/trpc/server';\nfunction Home() {\n  prefetch(\n    trpc.hello.queryOptions({\n      /** input */\n    }),\n  );\n  return (\n    <HydrateClient>\n      <div>...</div>\n      {/** ... */}\n      <ClientGreeting />\n    </HydrateClient>\n  );\n}\nCopy\nLeveraging Suspense​\n\nYou may prefer handling loading and error states using Suspense and Error Boundaries. You can do this by using the useSuspenseQuery hook.\n\napp/page.tsx\nimport { HydrateClient, prefetch, trpc } from '~/trpc/server';\nimport { Suspense } from 'react';\nimport { ErrorBoundary } from 'react-error-boundary';\nimport { ClientGreeting } from './client-greeting';\nexport default async function Home() {\n  prefetch(trpc.hello.queryOptions());\n  return (\n    <HydrateClient>\n      <div>...</div>\n      {/** ... */}\n      <ErrorBoundary fallback={<div>Something went wrong</div>}>\n        <Suspense fallback={<div>Loading...</div>}>\n          <ClientGreeting />\n        </Suspense>\n      </ErrorBoundary>\n    </HydrateClient>\n  );\n}\nCopy\napp/client-greeting.tsx\n'use client';\nimport { useSuspenseQuery } from '@tanstack/react-query';\nimport { trpc } from '~/trpc/client';\nexport function ClientGreeting() {\n  const trpc = useTRPC();\n  const { data } = useSuspenseQuery(trpc.hello.queryOptions());\n  return <div>{data.greeting}</div>;\n}\nCopy\nGetting data in a server component​\n\nIf you need access to the data in a server component, we recommend creating a server caller and using it directly. Please note that this method is detached from your query client and does not store the data in the cache. This means that you cannot use the data in a server component and expect it to be available in the client. This is intentional and explained in more detail in the Advanced Server Rendering guide.\n\ntrpc/server.tsx\n// ...\nexport const caller = appRouter.createCaller(createTRPCContext);\nCopy\napp/page.tsx\nimport { caller } from '~/trpc/server';\nexport default async function Home() {\n  const greeting = await caller.hello();\n  //    ^? { greeting: string }\n  return <div>{greeting.greeting}</div>;\n}\nCopy\n\nIf you really need to use the data both on the server as well as inside client components and understand the tradeoffs explained in the Advanced Server Rendering guide, you can use fetchQuery instead of prefetch to have the data both on the server as well as hydrating it down to the client:\n\napp/page.tsx\nimport { getQueryClient, HydrateClient, trpc } from '~/trpc/server';\nexport default async function Home() {\n  const queryClient = getQueryClient();\n  const greeting = await queryClient.fetchQuery(trpc.hello.queryOptions());\n  // Do something with greeting on the server\n  return (\n    <HydrateClient>\n      <div>...</div>\n      {/** ... */}\n      <ClientGreeting />\n    </HydrateClient>\n  );\n}\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/react/setup",
    "html": "Client Usage\nReact Query Integration (Classic)\nSetup\nVersion: 11.x\nSet up the React Query Integration\n1. Install dependencies​\n\nThe following dependencies should be installed\n\nnpm\nyarn\npnpm\nbun\ndeno\nnpm install @trpc/server @trpc/client @trpc/react-query @tanstack/react-query\n2. Import your AppRouter​\n\nImport your AppRouter type into the client application. This type holds the shape of your entire API.\n\nutils/trpc.ts\nimport type { AppRouter } from '../server/router';\nCopy\nTIP\n\nBy using import type you ensure that the reference will be stripped at compile-time, meaning you don't inadvertently import server-side code into your client. For more information, see the Typescript docs.\n\n3. Create tRPC hooks​\n\nCreate a set of strongly-typed React hooks from your AppRouter type signature with createTRPCReact.\n\nutils/trpc.ts\nimport { createTRPCReact } from '@trpc/react-query';\nimport type { AppRouter } from '../server/router';\n \nexport const trpc = createTRPCReact<AppRouter>();\nCopy\n4. Add tRPC providers​\n\nCreate a tRPC client, and wrap your application in the tRPC Provider, as below. You will also need to set up and connect React Query, which they document in more depth.\n\nTIP\n\nIf you already use React Query in your application, you should re-use the QueryClient and QueryClientProvider you already have.\n\nApp.tsx\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { httpBatchLink } from '@trpc/client';\nimport React, { useState } from 'react';\nimport { trpc } from './utils/trpc';\nexport function App() {\n  const [queryClient] = useState(() => new QueryClient());\n  const [trpcClient] = useState(() =>\n    trpc.createClient({\n      links: [\n        httpBatchLink({\n          url: 'http://localhost:3000/trpc',\n          // You can pass any HTTP headers you wish here\n          async headers() {\n            return {\n              authorization: getAuthCookie(),\n            };\n          },\n        }),\n      ],\n    }),\n  );\n  return (\n    <trpc.Provider client={trpcClient} queryClient={queryClient}>\n      <QueryClientProvider client={queryClient}>\n        {/* Your app here */}\n      </QueryClientProvider>\n    </trpc.Provider>\n  );\n}\nCopy\nNOTE\n\nThe reason for using useState in the creation of the queryClient and the TRPCClient, as opposed to declaring them outside of the component, is to ensure that each request gets a unique client when using SSR. If you use client side rendering then you can move them if you wish.\n\n5. Fetch data​\n\nYou can now use the tRPC React Query integration to call queries and mutations on your API.\n\npages/IndexPage.tsx\nimport { trpc } from '../utils/trpc';\n \nexport default function IndexPage() {\n  const userQuery = trpc.getUser.useQuery({ id: 'id_bilbo' });\n  const userCreator = trpc.createUser.useMutation();\n \n  return (\n    <div>\n      <p>{userQuery.data?.name}</p>\n \n      <button onClick={() => userCreator.mutate({ name: 'Frodo' })}>\n        Create Frodo\n      </button>\n    </div>\n  );\n}\nCopy\nEdit this page"
  },
  {
    "title": "Set up with React Server Components | tRPC",
    "url": "https://trpc.io/docs/client/react/server-components",
    "html": "Client Usage\nReact Query Integration (Classic)\nServer Components\nVersion: 11.x\nSet up with React Server Components\nTIP\n\nThese are the docs for our 'Classic' React Query integration, which (while still supported) is not the recommended way to start new tRPC projects with TanStack React Query. We recommend using the new TanStack React Query Integration instead.\n\nThis guide is an overview of how one may use tRPC with a React Server Components (RSC) framework such as Next.js App Router. Be aware that RSC on its own solves a lot of the same problems tRPC was designed to solve, so you may not need tRPC at all.\n\nThere are also not a one-size-fits-all way to integrate tRPC with RSCs, so see this guide as a starting point and adjust it to your needs and preferences.\n\nINFO\n\nIf you're looking for how to use tRPC with Server Actions, check out this blog post by Julius.\n\nCAUTION\n\nPlease read React Query's Advanced Server Rendering docs before proceeding to understand the different types of server rendering and what footguns to avoid.\n\nAdd tRPC to existing projects​\n1. Install deps​\nnpm\nyarn\npnpm\nbun\ndeno\nnpm install @trpc/server @trpc/client @trpc/react-query @tanstack/react-query@latest zod client-only server-only\n2. Create a tRPC router​\n\nInitialize your tRPC backend in trpc/init.ts using the initTRPC function, and create your first router. We're going to make a simple \"hello world\" router and procedure here - but for deeper information on creating your tRPC API you should refer to the Quickstart guide and Backend usage docs for tRPC information.\n\nINFO\n\nThe file names used here are not enforced by tRPC. You may use any file structure you wish.\n\nView sample backend\n3. Create a Query Client factory​\n\nCreate a shared file trpc/query-client.ts that exports a function that creates a QueryClient instance.\n\ntrpc/query-client.ts\nimport {\n  defaultShouldDehydrateQuery,\n  QueryClient,\n} from '@tanstack/react-query';\nimport superjson from 'superjson';\nexport function makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        staleTime: 30 * 1000,\n      },\n      dehydrate: {\n        // serializeData: superjson.serialize,\n        shouldDehydrateQuery: (query) =>\n          defaultShouldDehydrateQuery(query) ||\n          query.state.status === 'pending',\n      },\n      hydrate: {\n        // deserializeData: superjson.deserialize,\n      },\n    },\n  });\n}\nCopy\n\nWe're setting a few default options here:\n\nstaleTime: With SSR, we usually want to set some default staleTime above 0 to avoid refetching immediately on the client.\nshouldDehydrateQuery: This is a function that determines whether a query should be dehydrated or not. Since the RSC transport protocol supports hydrating promises over the network, we extend the defaultShouldDehydrateQuery function to also include queries that are still pending. This will allow us to start prefetching in a server component high up the tree, then consuming that promise in a client component further down.\nserializeData and deserializeData (optional): If you set up a data transformer in the previous step, set this option to make sure the data is serialized correctly when hydrating the query client over the server-client boundary.\n4. Create a tRPC client for Client Components​\n\nThe trpc/client.tsx is the entrypoint when consuming your tRPC API from client components. In here, import the type definition of your tRPC router and create typesafe hooks using createTRPCReact. We'll also export our context provider from this file.\n\ntrpc/client.tsx\n'use client';\n// ^-- to make sure we can mount the Provider from a server component\nimport type { QueryClient } from '@tanstack/react-query';\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCReact } from '@trpc/react-query';\nimport { useState } from 'react';\nimport { makeQueryClient } from './query-client';\nimport type { AppRouter } from './routers/_app';\nexport const trpc = createTRPCReact<AppRouter>();\nlet clientQueryClientSingleton: QueryClient;\nfunction getQueryClient() {\n  if (typeof window === 'undefined') {\n    // Server: always make a new query client\n    return makeQueryClient();\n  }\n  // Browser: use singleton pattern to keep the same query client\n  return (clientQueryClientSingleton ??= makeQueryClient());\n}\nfunction getUrl() {\n  const base = (() => {\n    if (typeof window !== 'undefined') return '';\n    if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;\n    return 'http://localhost:3000';\n  })();\n  return `${base}/api/trpc`;\n}\nexport function TRPCProvider(\n  props: Readonly<{\n    children: React.ReactNode;\n  }>,\n) {\n  // NOTE: Avoid useState when initializing the query client if you don't\n  //       have a suspense boundary between this and the code that may\n  //       suspend because React will throw away the client on the initial\n  //       render if it suspends and there is no boundary\n  const queryClient = getQueryClient();\n  const [trpcClient] = useState(() =>\n    trpc.createClient({\n      links: [\n        httpBatchLink({\n          // transformer: superjson, <-- if you use a data transformer\n          url: getUrl(),\n        }),\n      ],\n    }),\n  );\n  return (\n    <trpc.Provider client={trpcClient} queryClient={queryClient}>\n      <QueryClientProvider client={queryClient}>\n        {props.children}\n      </QueryClientProvider>\n    </trpc.Provider>\n  );\n}\nCopy\n\nMount the provider in the root of your application (e.g. app/layout.tsx when using Next.js).\n\n5. Create a tRPC caller for Server Components​\n\nTo prefetch queries from server components, we use a tRPC caller. The @trpc/react-query/rsc module exports a thin wrapper around createCaller that integrates with your React Query client.\n\ntrpc/server.tsx\nimport 'server-only'; // <-- ensure this file cannot be imported from the client\nimport { createHydrationHelpers } from '@trpc/react-query/rsc';\nimport { cache } from 'react';\nimport { createCallerFactory, createTRPCContext } from './init';\nimport { makeQueryClient } from './query-client';\nimport { appRouter } from './routers/_app';\n// IMPORTANT: Create a stable getter for the query client that\n//            will return the same client during the same request.\nexport const getQueryClient = cache(makeQueryClient);\nconst caller = createCallerFactory(appRouter)(createTRPCContext);\nexport const { trpc, HydrateClient } = createHydrationHelpers<typeof appRouter>(\n  caller,\n  getQueryClient,\n);\nCopy\nUsing your API​\n\nNow you can use your tRPC API in your app. While you can use the React Query hooks in client components just like you would in any other React app, we can take advantage of the RSC capabilities by prefetching queries in a server component high up the tree. You may be familiar with this concept as \"render as you fetch\" commonly implemented as loaders. This means the request fires as soon as possible but without suspending until the data is needed by using the useQuery or useSuspenseQuery hooks.\n\napp/page.tsx\nimport { trpc } from '~/trpc/server';\nimport { ClientGreeting } from './client-greeting';\nexport default async function Home() {\n  void trpc.hello.prefetch();\n  return (\n    <HydrateClient>\n      <div>...</div>\n      {/** ... */}\n      <ClientGreeting />\n    </HydrateClient>\n  );\n}\nCopy\napp/client-greeting.tsx\n'use client';\n// <-- hooks can only be used in client components\nimport { trpc } from '~/trpc/client';\nexport function ClientGreeting() {\n  const greeting = trpc.hello.useQuery();\n  if (!greeting.data) return <div>Loading...</div>;\n  return <div>{greeting.data.greeting}</div>;\n}\nCopy\nLeveraging Suspense​\n\nYou may prefer handling loading and error states using Suspense and Error Boundaries. You can do this by using the useSuspenseQuery hook.\n\napp/page.tsx\nimport { trpc } from '~/trpc/server';\nimport { Suspense } from 'react';\nimport { ErrorBoundary } from 'react-error-boundary';\nimport { ClientGreeting } from './client-greeting';\nexport default async function Home() {\n  void trpc.hello.prefetch();\n  return (\n    <HydrateClient>\n      <div>...</div>\n      {/** ... */}\n      <ErrorBoundary fallback={<div>Something went wrong</div>}>\n        <Suspense fallback={<div>Loading...</div>}>\n          <ClientGreeting />\n        </Suspense>\n      </ErrorBoundary>\n    </HydrateClient>\n  );\n}\nCopy\napp/client-greeting.tsx\n'use client';\nimport { trpc } from '~/trpc/client';\nexport function ClientGreeting() {\n  const [data] = trpc.hello.useSuspenseQuery();\n  return <div>{data.greeting}</div>;\n}\nCopy\nGetting data in a server component​\n\nIf you need access to the data in a server component, you can invoke the procedure directly instead of using .prefetch(), just like you use the normal server caller. Please note that this method is de-attached from your query client and does not store the data in the cache. This means that you cannot use the data in a server component and expect it to be available in the client. This is intentional and explained in more detail in the Advanced Server Rendering guide.\n\napp/page.tsx\nimport { trpc } from '~/trpc/server';\nexport default async function Home() {\n  // Use the caller directly without using `.prefetch()`\n  const greeting = await trpc.hello();\n  //    ^? { greeting: string }\n  return <div>{greeting.greeting}</div>;\n}\nCopy\nEdit this page"
  },
  {
    "title": "Inferring Types | tRPC",
    "url": "https://trpc.io/docs/client/react/infer-types",
    "html": "Client Usage\nReact Query Integration (Classic)\nInferring Types\nVersion: 11.x\nInferring Types\n\nIn addition to the type inference made available by @trpc/server (see here) this integration also provides some inference helpers for usage purely in React.\n\nInfer React Query options based on your router​\n\nWhen creating custom hooks around tRPC procedures, it's sometimes necessary to have the types of the options inferred from the router. You can do so via the inferReactQueryProcedureOptions helper exported from @trpc/react-query.\n\ntrpc.ts\nimport {\n  createTRPCReact,\n  type inferReactQueryProcedureOptions,\n} from '@trpc/react-query';\nimport type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';\nimport type { AppRouter } from './server';\n \n// infer the types for your router\nexport type ReactQueryOptions = inferReactQueryProcedureOptions<AppRouter>;\nexport type RouterInputs = inferRouterInputs<AppRouter>;\nexport type RouterOutputs = inferRouterOutputs<AppRouter>;\n \nexport const trpc = createTRPCReact<AppRouter>();\nCopy\nusePostCreate.ts\nimport {\n  trpc,\n  type ReactQueryOptions,\n  type RouterInputs,\n  type RouterOutputs,\n} from './trpc';\n \ntype PostCreateOptions = ReactQueryOptions['post']['create'];\n \nfunction usePostCreate(options?: PostCreateOptions) {\n  const utils = trpc.useUtils();\n \n  return trpc.post.create.useMutation({\n    ...options,\n    onSuccess(post) {\n      // invalidate all queries on the post router\n      // when a new post is created\n      utils.post.invalidate();\n      options?.onSuccess?.(post);\n    },\n  });\n}\nCopy\nusePostById.ts\nimport { ReactQueryOptions, RouterInputs, trpc } from './trpc';\n \ntype PostByIdOptions = ReactQueryOptions['post']['byId'];\ntype PostByIdInput = RouterInputs['post']['byId'];\n \nfunction usePostById(input: PostByIdInput, options?: PostByIdOptions) {\n  return trpc.post.byId.useQuery(input, options);\n}\nCopy\nInfer abstract types from a \"Router Factory\"​\n\nIf you write a factory which creates a similar router interface several times in your application, you may wish to share client code between usages of the factory. @trpc/react-query/shared exports several types which can be used to generate abstract types for a router factory, and build common React components which are passed the router as a prop.\n\napi/factory.ts\nimport { t, publicProcedure } from './trpc';\n \n// @trpc/react-query/shared exports several **Like types which can be used to generate abstract types\nimport { RouterLike, UtilsLike } from '@trpc/react-query/shared';\n \n// Factory function written by you, however you need,\n// so long as you can infer the resulting type of t.router() later\nexport function createMyRouter() {\n  return t.router({\n    createThing: publicProcedure\n      .input(ThingRequest)\n      .output(Thing)\n      .mutation(/* do work */),\n    listThings: publicProcedure\n      .input(ThingQuery)\n      .output(ThingArray)\n      .query(/* do work */),\n  })\n}\n \n// Infer the type of your router, and then generate the abstract types for use in the client\ntype MyRouterType = ReturnType<typeof createMyRouter>\nexport MyRouterLike = RouterLike<MyRouterType>\nexport MyRouterUtilsLike = UtilsLike<MyRouterType>\nCopy\napi/server.ts\nexport type AppRouter = typeof appRouter;\n \n// Export your MyRouter types to the client\nexport type { MyRouterLike, MyRouterUtilsLike } from './factory';\nCopy\nfrontend/usePostCreate.ts\nimport type { MyRouterLike, MyRouterUtilsLike, trpc, useUtils } from './trpc';\n \ntype MyGenericComponentProps = {\n  route: MyRouterLike;\n  utils: MyRouterUtilsLike;\n};\n \nfunction MyGenericComponent(props: MyGenericComponentProps) {\n  const { route } = props;\n  const thing = route.listThings.useQuery({\n    filter: 'qwerty',\n  });\n \n  const mutation = route.doThing.useMutation({\n    onSuccess() {\n      props.utils.listThings.invalidate();\n    },\n  });\n \n  function handleClick() {\n    mutation.mutate({\n      name: 'Thing 1',\n    });\n  }\n \n  return; /* ui */\n}\n \nfunction MyPageComponent() {\n  const utils = useUtils();\n \n  return (\n    <MyGenericComponent\n      route={trpc.deep.route.things}\n      utils={utils.deep.route.things}\n    />\n  );\n}\n \nfunction MyOtherPageComponent() {\n  const utils = useUtils();\n \n  return (\n    <MyGenericComponent\n      route={trpc.different.things}\n      utils={utils.different.things}\n    />\n  );\n}\nCopy\n\nA more complete working example can be found here\n\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/react/useQuery",
    "html": "Client Usage\nReact Query Integration (Classic)\nuseQuery()\nVersion: 11.x\nuseQuery()\n\nuseQuery is the primary hook for data fetching, it works similarly to @tanstack/react-query's useQuery, but with some trpc specific options and additional features like streaming.\n\nNOTE\n\nFor in-depth information about options and usage patterns, refer to the TanStack Query docs on queries.\n\nSignature​\nfunction useQuery(\n  input: TInput | SkipToken,\n  opts?: UseTRPCQueryOptions;\n)\ninterface UseTRPCQueryOptions\n  extends UseQueryOptions {\n  trpc: {\n    ssr?: boolean;\n    abortOnUnmount?: boolean;\n    context?: Record<string, unknown>;\n  }\n}\nCopy\n\nSince UseTRPCQueryOptions extends @tanstack/react-query's UseQueryOptions, you can use any of their options here such as enabled, refetchOnWindowFocus, etc. We also have some trpc specific options that let you opt in or out of certain behaviors on a per-procedure level:\n\ntrpc.ssr: If you have ssr: true in your global config, you can set this to false to disable ssr for this particular query. Note that this does not work the other way around, i.e., you can not enable ssr on a procedure if your global config is set to false.\ntrpc.abortOnUnmount: Override the global config and opt in or out of aborting queries on unmount.\ntrpc.context: Add extra meta data that could be used in Links.\nTIP\n\nIf you need to set any options but don't want to pass any input, you can pass undefined instead.\n\nYou'll notice that you get autocompletion on the input based on what you have set in your input schema on your backend.\n\nExample usage​\nBackend code\ncomponents/MyComponent.tsx\nimport { trpc } from '../utils/trpc';\nexport function MyComponent() {\n  // input is optional, so we don't have to pass second argument\n  const helloNoArgs = trpc.hello.useQuery();\n  const helloWithArgs = trpc.hello.useQuery({ text: 'client' });\n  return (\n    <div>\n      <h1>Hello World Example</h1>\n      <ul>\n        <li>\n          helloNoArgs ({helloNoArgs.status}):{' '}\n          <pre>{JSON.stringify(helloNoArgs.data, null, 2)}</pre>\n        </li>\n        <li>\n          helloWithArgs ({helloWithArgs.status}):{' '}\n          <pre>{JSON.stringify(helloWithArgs.data, null, 2)}</pre>\n        </li>\n      </ul>\n    </div>\n  );\n}\nCopy\nStreaming responses using async generators​\nINFO\n\nSince v11 we now support streaming queries when using the httpBatchStreamLink.\n\nWhen returning an async generators in a query, you will:\n\nGet the results of the iterator in the data-property as an array which updates as the response comes in\nThe status will be success as soon as the first chunk is received.\nThe fetchStatus property which will be fetching until the last chunk is received.\nExample​\nserver/routers/_app.ts\nimport { publicProcedure, router } from './trpc';\nconst appRouter = router({\n  iterable: publicProcedure.query(async function* () {\n    for (let i = 0; i < 3; i++) {\n      await new Promise((resolve) => setTimeout(resolve, 500));\n      yield i;\n    }\n  }),\n});\nexport type AppRouter = typeof appRouter;\nCopy\ncomponents/MyComponent.tsx\nimport { trpc } from '~/utils';\nexport function MyComponent() {\n  const result = trpc.iterable.useQuery();\n  return (\n    <div>\n      {result.data?.map((chunk, index) => (\n        <Fragment key={index}>{chunk}</Fragment>\n      ))}\n    </div>\n  );\n}\nCopy\n\nresult properties while streaming:\n\nstatus\tfetchStatus\tdata\n'pending'\t'fetching'\tundefined\n'success'\t'fetching'\t[]\n'success'\t'fetching'\t[1]\n'success'\t'fetching'\t[1, 2]\n'success'\t'fetching'\t[1, 2, 3]\n'success'\t'idle'\t[1, 2, 3]\nEdit this page"
  },
  {
    "title": "useMutation() | tRPC",
    "url": "https://trpc.io/docs/client/react/useMutation",
    "html": "Client Usage\nReact Query Integration (Classic)\nuseMutation()\nVersion: 11.x\nuseMutation()\nNOTE\n\nThe hooks provided by @trpc/react-query are a thin wrapper around @tanstack/react-query. For in-depth information about options and usage patterns, refer to their docs on mutations.\n\nWorks like react-query's mutations - see their docs.\n\nExample​\nBackend code\nimport { trpc } from '../utils/trpc';\nexport function MyComponent() {\n  const mutation = trpc.login.useMutation();\n  const handleLogin = () => {\n    const name = 'John Doe';\n    mutation.mutate({ name });\n  };\n  return (\n    <div>\n      <h1>Login Form</h1>\n      <button onClick={handleLogin} disabled={mutation.isPending}>\n        Login\n      </button>\n      {mutation.error && <p>Something went wrong! {mutation.error.message}</p>}\n    </div>\n  );\n}\nCopy\nEdit this page"
  },
  {
    "title": "useInfiniteQuery | tRPC",
    "url": "https://trpc.io/docs/client/react/useInfiniteQuery",
    "html": "Client Usage\nReact Query Integration (Classic)\nuseInfiniteQuery()\nVersion: 11.x\nuseInfiniteQuery\nINFO\nYour procedure needs to accept a cursor input of any type (string, number, etc) to expose this hook.\nFor more details on infinite queries read the react-query docs\nIn this example we're using Prisma - see their docs on cursor-based pagination\nExample Procedure​\nserver/routers/_app.ts\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\nimport { Context } from './[trpc]';\nexport const t = initTRPC.create();\nexport const appRouter = t.router({\n  infinitePosts: t.procedure\n    .input(\n      z.object({\n        limit: z.number().min(1).max(100).nullish(),\n        cursor: z.number().nullish(), // <-- \"cursor\" needs to exist, but can be any type\n        direction: z.enum(['forward', 'backward']), // optional, useful for bi-directional query\n      }),\n    )\n    .query(async (opts) => {\n      const { input } = opts;\n      const limit = input.limit ?? 50;\n      const { cursor } = input;\n      const items = await prisma.post.findMany({\n        take: limit + 1, // get an extra item at the end which we'll use as next cursor\n        where: {\n          title: {\n            contains: 'Prisma' /* Optional filter */,\n          },\n        },\n        cursor: cursor ? { myCursor: cursor } : undefined,\n        orderBy: {\n          myCursor: 'asc',\n        },\n      });\n      let nextCursor: typeof cursor | undefined = undefined;\n      if (items.length > limit) {\n        const nextItem = items.pop();\n        nextCursor = nextItem!.myCursor;\n      }\n      return {\n        items,\n        nextCursor,\n      };\n    }),\n});\nCopy\nExample React Component​\ncomponents/MyComponent.tsx\nimport { trpc } from '../utils/trpc';\nexport function MyComponent() {\n  const myQuery = trpc.infinitePosts.useInfiniteQuery(\n    {\n      limit: 10,\n    },\n    {\n      getNextPageParam: (lastPage) => lastPage.nextCursor,\n      // initialCursor: 1, // <-- optional you can pass an initialCursor\n    },\n  );\n  // [...]\n}\nCopy\nHelpers​\ngetInfiniteData()​\n\nThis helper gets the currently cached data from an existing infinite query\n\ncomponents/MyComponent.tsx\nimport { trpc } from '../utils/trpc';\nexport function MyComponent() {\n  const utils = trpc.useUtils();\n  const myMutation = trpc.infinitePosts.add.useMutation({\n    async onMutate(opts) {\n      await utils.infinitePosts.cancel();\n      const allPosts = utils.infinitePosts.getInfiniteData({ limit: 10 });\n      // [...]\n    },\n  });\n}\nCopy\nsetInfiniteData()​\n\nThis helper allows you to update a query's cached data\n\ncomponents/MyComponent.tsx\nimport { trpc } from '../utils/trpc';\nexport function MyComponent() {\n  const utils = trpc.useUtils();\n  const myMutation = trpc.infinitePosts.delete.useMutation({\n    async onMutate(opts) {\n      await utils.infinitePosts.cancel();\n      utils.infinitePosts.setInfiniteData({ limit: 10 }, (data) => {\n        if (!data) {\n          return {\n            pages: [],\n            pageParams: [],\n          };\n        }\n        return {\n          ...data,\n          pages: data.pages.map((page) => ({\n            ...page,\n            items: page.items.filter((item) => item.status === 'published'),\n          })),\n        };\n      });\n    },\n  });\n  // [...]\n}\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/react/useSubscription",
    "html": "Client Usage\nReact Query Integration (Classic)\nuseSubscription()\nVersion: 11.x\nuseSubscription()\n\nThe useSubscription hook can be used to subscribe to a subscription procedure on the server.\n\nSignature​\nOptions​\nTIP\nIf you need to set any options but don't want to pass any input, you can pass undefined instead.\nIf you pass skipToken from @tanstack/react-query, the subscription will be paused.\nHave a look at our SSE example for a complete example of how to use subscriptions\nfunction useSubscription<TOutput, TError>(\n  input: TInput | SkipToken,\n  opts?: UseTRPCSubscriptionOptions<TOutput, TError>,\n): TRPCSubscriptionResult<TOutput, TError>;\ninterface UseTRPCSubscriptionOptions<TOutput, TError> {\n  /**\n   * Callback invoked when the subscription starts.\n   */\n  onStarted?: () => void;\n  /**\n   * Callback invoked when new data is received from the subscription.\n   * @param data - The data received.\n   */\n  onData?: (data: TOutput) => void;\n  /**\n   * Callback invoked when an **unrecoverable error** occurs and the subscription is stopped.\n   */\n  onError?: (error: TError) => void;\n  /**\n   * Callback invoked when the subscription is completed.\n   */\n  onComplete?: () => void;\n  /**\n   * @deprecated Use a `skipToken` from `@tanstack/react-query` instead.\n   * This will be removed in a future version.\n   */\n  enabled?: boolean;\n}\nCopy\nReturn type​\ntype TRPCSubscriptionResult<TOutput, TError> = {\n  /**\n   * The current status of the subscription.\n   * Will be one of: `'idle'`, `'connecting'`, `'pending'`, or `'error'`.\n   *\n   * - `idle`: subscription is disabled or ended\n   * - `connecting`: trying to establish a connection\n   * - `pending`: connected to the server, receiving data\n   * - `error`: an error occurred and the subscription is stopped\n   */\n  status: 'idle' | 'connecting' | 'pending' | 'error';\n  /**\n   * The last data received from the subscription.\n   */\n  data: TOutput | undefined;\n  /**\n   * The last error received - will be `null` whenever the status is `'pending'` or `'idle'`\n   * - has a value only when the status is `'error'`\n   * - *may* have a value when the status is `'connecting'`\n   */\n  error: TRPCClientError | null;\n  /**\n   * Function to reset the subscription.\n   */\n  reset: () => void;\n};\nCopy\nExample​\ncomponents/MyComponent.tsx\nimport { trpc } from '../utils/trpc';\nexport function MyComponent() {\n  const [numbers, setNumbers] = React.useState<number[]>([]);\n  const result = trpc.onNumber.useSubscription(undefined, {\n    onData: (num) => {\n      setNumbers((prev) => [...prev, num]);\n    },\n  });\n  return (\n    <div>\n      <h1>Subscription Example</h1>\n      <p>\n        {result.status}: <pre>{JSON.stringify(result.data, null, 2)}</pre>\n      </p>\n      <h2>Previous numbers:</h2>\n      <ul>\n        {numbers.map((num, i) => (\n          <li key={i}>{num}</li>\n        ))}\n      </ul>\n      {result.status === 'error' && (\n        <button onClick={() => result.reset()}>\n          Something went wrong - restart the subscription\n        </button>\n      )}\n    </div>\n  );\n}\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/react/useUtils",
    "html": "Client Usage\nReact Query Integration (Classic)\nuseUtils()\nVersion: 11.x\nuseUtils\n\nuseUtils is a hook that gives you access to helpers that let you manage the cached data of the queries you execute via @trpc/react-query. These helpers are actually thin wrappers around @tanstack/react-query's queryClient methods. If you want more in-depth information about options and usage patterns for useContext helpers than what we provide here, we will link to their respective @tanstack/react-query docs so you can refer to them accordingly.\n\nNOTE\n\nThis hook was called useContext() until 10.41.0 (and is still aliased for the foreseeable future)\n\nUsage​\n\nuseUtils returns an object with all the available queries you have in your routers. You use it the same way as your trpc client object. Once you reach a query, you'll have access to the query helpers. For example, let's say you have a post router with an all query:\n\nserver.ts\n// @filename: server.ts\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n \nconst t = initTRPC.create();\n \nconst appRouter = t.router({\n  post: t.router({\n    all: t.procedure.query(() => {\n      return {\n        posts: [\n          { id: 1, title: 'everlong' },\n          { id: 2, title: 'After Dark' },\n        ],\n      };\n    }),\n  }),\n});\n \nexport type AppRouter = typeof appRouter;\nCopy\n\nNow in our component, when we navigate the object useUtils gives us and reach the post.all query, we'll get access to our query helpers!\n\nMyComponent.tsx\nfunction MyComponent() {\n  const utils = trpc.useUtils();\n  utils.post.all.f;\n                  \nfetch\nfetchInfinite\n  // [...]\n}\nCopy\nHelpers​\n\nThese are the helpers you'll get access to via useUtils. The table below will help you know which tRPC helper wraps which @tanstack/react-query helper method. Each react-query method will link to its respective docs/guide:\n\ntRPC helper wrapper\t@tanstack/react-query helper method\nfetch\tqueryClient.fetchQuery\nprefetch\tqueryClient.prefetchQuery\nfetchInfinite\tqueryClient.fetchInfiniteQuery\nprefetchInfinite\tqueryClient.prefetchInfiniteQuery\nensureData\tqueryClient.ensureData\ninvalidate\tqueryClient.invalidateQueries\nrefetch\tqueryClient.refetchQueries\ncancel\tqueryClient.cancelQueries\nsetData\tqueryClient.setQueryData\nsetQueriesData\tqueryClient.setQueriesData\ngetData\tqueryClient.getQueryData\nsetInfiniteData\tqueryClient.setInfiniteQueryData\ngetInfiniteData\tqueryClient.getInfiniteData\nsetMutationDefaults\tqueryClient.setMutationDefaults\ngetMutationDefaults\tqueryClient.getMutationDefaults\nisMutating\tqueryClient.isMutating\n❓ The function I want isn't here!​\n\n@tanstack/react-query has a lot of functions that we haven't put in the tRPC context yet. If you need a function that isn't here, feel free to open a feature request requesting it.\n\nIn the meantime, you can import and use the function directly from @tanstack/react-query. We also provide a getQueryKey which you can use to get the correct queryKey on the filters when using these functions.\n\nProxy client​\n\nIn addition to the above react-query helpers, the context also exposes your tRPC proxy client. This lets you call your procedures with async/await without needing to create an additional vanilla client.\n\nimport { trpc } from '../utils/trpc';\nfunction MyComponent() {\n  const [apiKey, setApiKey] = useState();\n  const utils = trpc.useUtils();\n  return (\n    <Form\n      handleSubmit={async (event) => {\n        const apiKey = await utils.client.apiKey.create.mutate(event);\n        setApiKey(apiKey);\n      }}\n    >\n      ...\n    </Form>\n  );\n}\nCopy\nQuery Invalidation​\n\nYou invalidate queries via the invalidate helper. invalidate is actually a special helper given that, unlike the other helpers, it's available at every level of the router map. This means you can either run invalidate on a single query, a whole router, or every router if you want. We get more in detail in the sections below.\n\nInvalidating a single query​\n\nYou can invalidate a query relating to a single procedure and even filter based on the input passed to it to prevent unnecessary calls to the back end.\n\nExample code​\nimport { trpc } from '../utils/trpc';\nfunction MyComponent() {\n  const utils = trpc.useUtils();\n  const mutation = trpc.post.edit.useMutation({\n    onSuccess(input) {\n      utils.post.all.invalidate();\n      utils.post.byId.invalidate({ id: input.id }); // Will not invalidate queries for other id's 👍\n    },\n  });\n  // [...]\n}\nCopy\nInvalidating across whole routers​\n\nIt is also possible to invalidate queries across an entire router rather then just one query.\n\nExample code​\nBackend code\nimport { trpc } from '../utils/trpc';\nfunction MyComponent() {\n  const utils = trpc.useUtils();\n  const invalidateAllQueriesAcrossAllRouters = () => {\n    // 1️⃣\n    // All queries on all routers will be invalidated 🔥\n    utils.invalidate();\n  };\n  const invalidateAllPostQueries = () => {\n    // 2️⃣\n    // All post queries will be invalidated 📭\n    utils.post.invalidate();\n  };\n  const invalidatePostById = () => {\n    // 3️⃣\n    // All queries in the post router with input {id:1} invalidated 📭\n    utils.post.byId.invalidate({ id: 1 });\n  };\n  // Example queries\n  trpc.user.all.useQuery(); // Would only be validated by 1️⃣ only.\n  trpc.post.all.useQuery(); // Would be invalidated by 1️⃣ & 2️⃣\n  trpc.post.byId.useQuery({ id: 1 }); // Would be invalidated by 1️⃣, 2️⃣ and 3️⃣\n  trpc.post.byId.useQuery({ id: 2 }); // would be invalidated by 1️⃣ and 2️⃣ but NOT 3️⃣!\n  // [...]\n}\nCopy\nInvalidate full cache on every mutation​\n\nKeeping track of exactly what queries a mutation should invalidate is hard, therefore, it can be a pragmatic solution to invalidate the full cache as a side-effect on any mutation. Since we have request batching, this invalidation will simply refetch all queries on the page you're looking at in one single request.\n\nWe have added a feature to help with this:\n\nexport const trpc = createTRPCReact<AppRouter, SSRContext>({\n  overrides: {\n    useMutation: {\n      /**\n       * This function is called whenever a `.useMutation` succeeds\n       **/\n      async onSuccess(opts) {\n        /**\n         * @note that order here matters:\n         * The order here allows route changes in `onSuccess` without\n         * having a flash of content change whilst redirecting.\n         **/\n        // Calls the `onSuccess` defined in the `useQuery()`-options:\n        await opts.originalFn();\n        // Invalidate all queries in the react-query cache:\n        await opts.queryClient.invalidateQueries();\n      },\n    },\n  },\n});\nCopy\nAdditional Options​\n\nAside from the query helpers, the object useUtils returns also contains the following properties:\n\ninterface ProxyTRPCContextProps<TRouter extends AnyRouter, TSSRContext> {\n  /**\n   * The `TRPCClient`\n   */\n  client: TRPCClient<TRouter>;\n  /**\n   * The SSR context when server-side rendering\n   * @default null\n   */\n  ssrContext?: TSSRContext | null;\n  /**\n   * State of SSR hydration.\n   * - `false` if not using SSR.\n   * - `prepass` when doing a prepass to fetch queries' data\n   * - `mounting` before TRPCProvider has been rendered on the client\n   * - `mounted` when the TRPCProvider has been rendered on the client\n   * @default false\n   */\n  ssrState?: SSRState;\n  /**\n   * Abort loading query calls when unmounting a component - usually when navigating to a new page\n   * @default false\n   */\n  abortOnUnmount?: boolean;\n}\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/react/createTRPCQueryUtils",
    "html": "Client Usage\nReact Query Integration (Classic)\ncreateTRPCQueryUtils()\nVersion: 11.x\ncreateTRPCQueryUtils\n\nThe use case for createTRPCQueryUtils is when you need to use the helpers outside of a React Component, for example in react-routers loaders.\n\nSimilar to useUtils, createTRPCQueryUtils is a function that gives you access to helpers that let you manage the cached data of the queries you execute via @trpc/react-query. These helpers are actually thin wrappers around @tanstack/react-query's queryClient methods. If you want more in-depth information about options and usage patterns for useUtils helpers than what we provide here, we will link to their respective @tanstack/react-query docs so you can refer to them accordingly.\n\nThe difference between useUtils and createTRPCQueryUtils is that useUtils is a react hook that uses useQueryClient under the hood. This means that it is able to work better within React Components.\n\nIf you need access to the client directly, you can use the client object that you passed to createTRPCQueryUtils during creation.\n\nCAUTION\n\nYou should avoid using createTRPCQueryUtils in React Components. Instead, use useUtils which is a React hook that implements useCallback and useQueryClient under the hood.\n\nUsage​\n\ncreateTRPCQueryUtils returns an object with all the available queries you have in your routers. You use it the same way as your trpc client object. Once you reach a query, you'll have access to the query helpers. For example, let's say you have a post router with an all query:\n\nNow in our component, when we navigate the object createTRPCQueryUtils gives us and reach the post.all query, we'll get access to our query helpers!\n\nMyPage.tsx\nimport { QueryClient } from '@tanstack/react-query';\nimport { createTRPCQueryUtils, createTRPCReact } from '@trpc/react-query';\nimport { useLoaderData } from 'react-router-dom';\nimport type { AppRouter } from './server';\nconst trpc = createTRPCReact<AppRouter>();\nconst trpcClient = trpc.createClient({ links: [] });\nconst queryClient = new QueryClient();\nconst clientUtils = createTRPCQueryUtils({ queryClient, client: trpcClient });\n// This is a react-router loader\nexport async function loader() {\n  const allPostsData = await clientUtils.post.all.ensureData(); // Fetches data if it doesn't exist in the cache\n  return {\n    allPostsData,\n  };\n}\n// This is a react component\nexport function Component() {\n  const loaderData = useLoaderData() as Awaited<ReturnType<typeof loader>>;\n  const allPostQuery = trpc.post.all.useQuery({\n    initialData: loaderData.allPostsData, // Uses the data from the loader\n  });\n  return (\n    <div>\n      {allPostQuery.data.posts.map((post) => (\n        <div key={post.id}>{post.title}</div>\n      ))}\n    </div>\n  );\n}\nCopy\nNOTE\n\nIf you were using Remix Run or SSR you wouldn't re-use the same queryClient for every request. Instead, you would create a new queryClient for every request so that there's no cross-request data leakage.\n\nHelpers​\n\nMuch like useUtils, createTRPCQueryUtils gives you access to same set of helpers. The only difference is that you need to pass in the queryClient and client objects.\n\nYou can see them on the useUtils-page.\n\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/react/useQueries",
    "html": "Client Usage\nReact Query Integration (Classic)\nuseQueries()\nVersion: 11.x\nuseQueries()\n\nThe useQueries hook can be used to fetch a variable number of queries at the same time using only one hook call.\n\nThe main use case for such a hook is to be able to fetch a number of queries, usually of the same type. For example if you fetch a list of todo ids, you can then map over them in a useQueries hook calling a byId endpoint that would fetch the details of each todo.\n\nNOTE\n\nWhile fetching multiple types in a useQueries hook is possible, there is not much of an advantage compared to using multiple useQuery calls unless you use the suspense option as that useQueries can trigger suspense in parallel while multiple useQuery calls would waterfall.\n\nUsage​\n\nThe useQueries hook is the same as that of @tanstack/query useQueries. The only difference is that you pass in a function that returns an array of queries instead of an array of queries inside an object parameter.\n\nTIP\n\nWhen you're using the httpBatchLink or wsLink, the below will end up being only 1 HTTP call to your server. Additionally, if the underlying procedure is using something like Prisma's findUnique() it will automatically batch & do exactly 1 database query as a well.\n\nconst Component = (props: { postIds: string[] }) => {\n  const postQueries = trpc.useQueries((t) =>\n    props.postIds.map((id) => t.post.byId({ id })),\n  );\n  return <>{/* [...] */}</>;\n};\nCopy\nProviding options to individual queries​\n\nYou can also pass in any normal query options to the second parameter of any of the query calls in the array such as enabled, suspense, refetchOnWindowFocus...etc. For a complete overview of all the available options, see the tanstack useQuery documentation.\n\nconst Component = () => {\n  const [post, greeting] = trpc.useQueries((t) => [\n    t.post.byId({ id: '1' }, { enabled: false }),\n    t.greeting({ text: 'world' }),\n  ]);\n  const onButtonClick = () => {\n    post.refetch();\n  };\n  return (\n    <div>\n      <h1>{post.data && post.data.title}</h1>\n      <p>{greeting.data.message}</p>\n      <button onClick={onButtonClick}>Click to fetch</button>\n    </div>\n  );\n};\nCopy\nContext​\n\nYou can also pass in an optional React Query context to override the default.\n\nconst [post, greeting] = trpc.useQueries(\n  (t) => [t.post.byId({ id: '1' }), t.greeting({ text: 'world' })],\n  myCustomContext,\n);\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/react/suspense",
    "html": "Client Usage\nReact Query Integration (Classic)\nSuspense\nVersion: 11.x\nSuspense\nINFO\nEnsure you're on the latest version of React\nIf you use suspense with tRPC's automatic SSR in Next.js, the full page will crash on the server if a query fails, even if you have an <ErrorBoundary />\nUsage​\nTIP\n\nuseSuspenseQuery & useSuspenseInfiniteQuery both return a [data, query]-tuple, to make it easy to directly use your data and renaming the variable to something descriptive\n\nuseSuspenseQuery()​\n// @filename: pages/index.tsx\nimport React from 'react';\nimport { trpc } from '../utils/trpc';\n \nfunction PostView() {\n  const [post, postQuery] = trpc.post.byId.useSuspenseQuery({ id: '1' });\n          \nconst post: {\n    id: string;\n    title: string;\n}\n \n  return <>{/* ... */}</>;\n}\nCopy\nuseSuspenseInfiniteQuery()​\n// @filename: pages/index.tsx\nimport React from 'react';\nimport { trpc } from '../utils/trpc';\nfunction PostView() {\n  const [{ pages }, allPostsQuery] = trpc.post.all.useSuspenseInfiniteQuery(\n    {},\n    {\n      getNextPageParam(lastPage) {\n        return lastPage.nextCursor;\n      },\n    },\n  );\n  const { isFetching, isFetchingNextPage, fetchNextPage, hasNextPage } =\n    allPostsQuery;\n  return <>{/* ... */}</>;\n}\nCopy\nuseSuspenseQueries()​\n\nSuspense equivalent of useQueries().\n\nconst Component = (props: { postIds: string[] }) => {\n  const [posts, postQueries] = trpc.useSuspenseQueries((t) =>\n    props.postIds.map((id) => t.post.byId({ id })),\n  );\n  return <>{/* [...] */}</>;\n};\nCopy\nPrefetching​\n\nThe performance of suspense queries can be improved by prefetching the query data before the Suspense component is rendered (this is sometimes called \"render-as-you-fetch\").\n\nNOTE\nPrefetching and the render-as-you-fetch model are very dependent on the framework and router you are using. We recommend reading your frameworks router docs along with the @tanstack/react-query docs to understand how to implement these patterns.\nIf you are using Next.js please look at the docs on Server-Side Helpers to implement server-side prefetching.\nRoute-level prefetching​\nconst utils = createTRPCQueryUtils({ queryClient, client: trpcClient });\n// tanstack router/ react router loader\nconst loader = async (params: { id: string }) =>\n  utils.post.byId.ensureQueryData({ id: params.id });\nCopy\nComponent-level prefetching with usePrefetchQuery​\nimport { trpc } from '../utils/trpc';\nfunction PostViewPage(props: { postId: string }) {\n  trpc.post.byId.usePrefetchQuery({ id: props.postId });\n  return (\n    <Suspense>\n      <PostView postId={props.postId} />\n    </Suspense>\n  );\n}\nCopy\nComponent-level prefetching with usePrefetchInfiniteQuery​\nimport { trpc } from '../utils/trpc';\n// will have to be passed to the child PostView `useSuspenseInfiniteQuery`\nexport const getNextPageParam = (lastPage) => lastPage.nextCursor;\nfunction PostViewPage(props: { postId: string }) {\n  trpc.post.all.usePrefetchInfiniteQuery({}, { getNextPageParam });\n  return (\n    <Suspense>\n      <PostView postId={props.postId} />\n    </Suspense>\n  );\n}\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/react/getQueryKey",
    "html": "Client Usage\nReact Query Integration (Classic)\ngetQueryKey()\nVersion: 11.x\ngetQueryKey\n\nWe provide a getQueryKey helper that accepts a router or procedure so that you can easily provide the native function the correct query key.\n\n// Queries\nfunction getQueryKey(\n  procedure: AnyQueryProcedure,\n  input?: DeepPartial<TInput>,\n  type?: QueryType; /** @default 'any' */\n): TRPCQueryKey;\n// Routers\nfunction getQueryKey(\n  router: AnyRouter,\n): TRPCQueryKey;\ntype QueryType = \"query\" | \"infinite\" | \"any\";\n// for useQuery ──┘         │            │\n// for useInfiniteQuery ────┘            │\n// will match all ───────────────────────┘\nCopy\nNOTE\n\nThe query type any will match all queries in the cache only if the react query method where it's used uses fuzzy matching. See TanStack/query#5111 (comment) for more context.\n\nimport { useIsFetching, useQueryClient } from '@tanstack/react-query';\nimport { getQueryKey } from '@trpc/react-query';\nimport { trpc } from '~/utils/trpc';\nfunction MyComponent() {\n  const queryClient = useQueryClient();\n  const posts = trpc.post.list.useQuery();\n  // See if a query is fetching\n  const postListKey = getQueryKey(trpc.post.list, undefined, 'query');\n  const isFetching = useIsFetching(postListKey);\n  // Set some query defaults for an entire router\n  const postKey = getQueryKey(trpc.post);\n  queryClient.setQueryDefaults(postKey, { staleTime: 30 * 60 * 1000 });\n  // ...\n}\nCopy\nMutations​\n\nSimilarly to queries, we provide a getMutationKey for mutations. The underlying function is the same as getQueryKey (in fact, you could technically use getQueryKey for mutations as well), the only difference is in semantics.\n\nfunction getMutationKey(procedure: AnyMutationProcedure): TRPCMutationKey;\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/react/aborting-procedure-calls",
    "html": "Client Usage\nReact Query Integration (Classic)\nAborting Procedure Calls\nVersion: 11.x\nAborting Procedure Calls\n\nBy default, tRPC does not cancel requests via React Query. If you want to opt into this behaviour, you can provide abortOnUnmount in your configuration.\n\nNOTE\n\n@tanstack/react-query only supports aborting queries.\n\nGlobally​\nclient.ts\n// @filename: utils.ts\nimport { createTRPCReact } from '@trpc/react-query';\n \nexport const trpc = createTRPCReact<AppRouter>({\n  abortOnUnmount: true,\n});\n \ntrpc.createClient({\n  // ...\n});\nCopy\nPer-request​\n\nYou may also override this behaviour at the query level.\n\npages/post/[id].tsx\nimport { trpc } from '../utils/trpc';\n \nfunction PostViewPage() {\n  const { query } = useRouter();\n  const postQuery = trpc.post.byId.useQuery(\n    { id: query.id },\n    { trpc: { abortOnUnmount: true } }\n  );\n \n  // ...\n}\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/links/httpLink",
    "html": "Client Usage\nLinks\nHTTP Link\nVersion: 11.x\nHTTP Link\n\nhttpLink is a terminating link that sends a tRPC operation to a tRPC procedure over HTTP.\n\nhttpLink supports both POST and GET requests.\n\nUsage​\n\nYou can import and add the httpLink to the links array as such:\n\nclient/index.ts\nimport { createTRPCClient, httpLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpLink({\n      url: 'http://localhost:3000',\n      // transformer,\n    }),\n  ],\n});\nCopy\nhttpLink Options​\n\nThe httpLink function takes an options object that has the HTTPLinkOptions shape.\n\nexport interface HTTPLinkOptions {\n  url: string;\n  /**\n   * Add ponyfill for fetch\n   */\n  fetch?: typeof fetch;\n  /**\n   * Add ponyfill for AbortController\n   */\n  AbortController?: typeof AbortController | null;\n  /**\n   * Data transformer\n   * @see https://trpc.io/docs/v11/data-transformers\n   **/\n  transformer?: DataTransformerOptions;\n  /**\n   * Headers to be set on outgoing requests or a callback that of said headers\n   * @see http://trpc.io/docs/v10/header\n   */\n  headers?:\n    | HTTPHeaders\n    | ((opts: { op: Operation }) => HTTPHeaders | Promise<HTTPHeaders>);\n  /**\n   * Send all requests as POSTS requests regardless of the procedure type\n   * The server must separately allow overriding the method. See:\n   * @see https://trpc.io/docs/rpc\n   */\n  methodOverride?: 'POST';\n}\nCopy\nReference​\n\nYou can check out the source code for this link on GitHub.\n\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/links/httpBatchLink",
    "html": "Client Usage\nLinks\nHTTP Batch Link\nVersion: 11.x\nHTTP Batch Link\n\nhttpBatchLink is a terminating link that batches an array of individual tRPC operations into a single HTTP request that's sent to a single tRPC procedure.\n\nUsage​\n\nYou can import and add the httpBatchLink to the links array as such:\n\nclient/index.ts\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000',\n    }),\n    // transformer,\n  ],\n});\nCopy\n\nAfter that, you can make use of batching by setting all your procedures in a Promise.all. The code below will produce exactly one HTTP request and on the server exactly one database query:\n\nconst somePosts = await Promise.all([\n  trpc.post.byId.query(1),\n  trpc.post.byId.query(2),\n  trpc.post.byId.query(3),\n]);\nCopy\nhttpBatchLink Options​\n\nThe httpBatchLink function takes an options object that has the HTTPBatchLinkOptions shape.\n\nexport interface HTTPBatchLinkOptions extends HTTPLinkOptions {\n  /**\n   * Maximum length of HTTP URL allowed before operations are split into multiple requests\n   * @default Infinity\n   */\n  maxURLLength?: number;\n  /**\n   * Maximum number of operations allowed in a single batch request\n   * @default Infinity\n   */\n  maxItems?: number;\n}\nexport interface HTTPLinkOptions {\n  url: string;\n  /**\n   * Add ponyfill for fetch\n   */\n  fetch?: typeof fetch;\n  /**\n   * Add ponyfill for AbortController\n   */\n  AbortController?: typeof AbortController | null;\n  /**\n   * Data transformer\n   * @see https://trpc.io/docs/data-transformers\n   **/\n  transformer?: DataTransformerOptions;\n  /**\n   * Headers to be set on outgoing requests or a callback that of said headers\n   * @see http://trpc.io/docs/header\n   */\n  headers?:\n    | HTTPHeaders\n    | ((opts: { opList: Operation[] }) => HTTPHeaders | Promise<HTTPHeaders>);\n}\nCopy\nSetting a maximum URL length​\n\nWhen sending batch requests, sometimes the URL can become too large causing HTTP errors like 413 Payload Too Large, 414 URI Too Long, and 404 Not Found. The maxURLLength option will limit the number of requests that can be sent together in a batch.\n\nAn alternative way of doing this is to\n\nclient/index.ts\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000',\n      maxURLLength: 2083, // a suitable size\n      // alternatively, you can make all RPC-calls to be called with POST\n      // methodOverride: 'POST',\n    }),\n  ],\n});\nCopy\nDisabling request batching​\n1. Disable batching on your server:​\nserver.ts\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\ncreateHTTPServer({\n  // [...]\n  // 👇 disable batching\n  allowBatching: false,\n});\nCopy\n\nor, if you're using Next.js:\n\npages/api/trpc/[trpc].ts\nexport default trpcNext.createNextApiHandler({\n  // [...]\n  // 👇 disable batching\n  allowBatching: false,\n});\nCopy\n2. Replace httpBatchLink with httpLink in your tRPC Client​\nclient/index.ts\nimport { createTRPCClient, httpLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\nCopy\n\nor, if you're using Next.js:\n\nutils/trpc.ts\nimport type { AppRouter } from '@/server/routers/app';\nimport { httpLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nexport const trpc = createTRPCNext<AppRouter>({\n  config() {\n    return {\n      links: [\n        httpLink({\n          url: '/api/trpc',\n        }),\n      ],\n    };\n  },\n});\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/links/httpBatchStreamLink",
    "html": "Client Usage\nLinks\nHTTP Batch Stream Link\nVersion: 11.x\nHTTP Batch Stream Link\n\nhttpBatchStreamLink is a terminating link that batches an array of individual tRPC operations into a single HTTP request that's sent to a single tRPC procedure (equivalent to httpBatchLink), but doesn't wait for all the responses of the batch to be ready and streams the responses as soon as any data is available.\n\nOptions​\n\nOptions are identical to httpBatchLink options.\n\nUsage​\n\nAll usage and options are identical to httpBatchLink.\n\nNOTE\n\nIf you require the ability to change/set response headers (which includes cookies) from within your procedures, make sure to use httpBatchLink instead! This is due to the fact that httpBatchStreamLink does not support setting headers once the stream has begun. Read more.\n\nYou can import and add the httpBatchStreamLink to the links array as such:\n\nclient/index.ts\nimport { createTRPCClient, httpBatchStreamLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchStreamLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\nCopy\n\nAfter that, you can make use of batching by setting all your procedures in a Promise.all. The code below will produce exactly one HTTP request and on the server exactly one database query:\n\nconst somePosts = await Promise.all([\n  trpc.post.byId.query(1),\n  trpc.post.byId.query(2),\n  trpc.post.byId.query(3),\n]);\nCopy\nStreaming mode​\n\nWhen batching requests together, the behavior of a regular httpBatchLink is to wait for all requests to finish before sending the response. If you want to send responses as soon as they are ready, you can use httpBatchStreamLink instead. This is useful for long-running requests.\n\nclient/index.ts\nimport { createTRPCClient, httpBatchStreamLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchStreamLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\nCopy\n\nCompared to a regular httpBatchLink, a httpBatchStreamLink will:\n\nCause the requests to be sent with a trpc-accept: application/jsonl header\nCause the response to be sent with a transfer-encoding: chunked and content-type: application/jsonl\nRemove the data key from the argument object passed to responseMeta (because with a streamed response, the headers are sent before the data is available)\nAsync generators and deferred promises​\n\nYou can try this out on the homepage of tRPC.io: https://trpc.io/?try=minimal#try-it-out\n\n// @filename: server.ts\nimport { publicProcedure, router } from './trpc';\n \nconst appRouter = router({\n  examples: {\n    iterable: publicProcedure.query(async function* () {\n      for (let i = 0; i < 3; i++) {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n        yield i;\n      }\n    }),\n  },\n});\n \nexport type AppRouter = typeof appRouter;\n \n \n// @filename: client.ts\nimport { createTRPCClient, httpBatchStreamLink } from '@trpc/client';\nimport type { AppRouter } from './server';\n \nconst trpc = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchStreamLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\nconst iterable = await trpc.examples.iterable.query();\n         \nconst iterable: AsyncIterable<number, never, unknown>\n \nfor await (const value of iterable) {\n  console.log('Iterable:', value);\n                            \nconst value: number\n}\nCopy\nCompatibility (client-side)​\nBrowsers​\n\nBrowser support should be identical to fetch support.\n\nNode.js / Deno​\n\nFor runtimes other than the browser ones, the fetch implementation should support streaming, meaning that the response obtained by await fetch(...) should have a body property of type ReadableStream<Uint8Array> | NodeJS.ReadableStream, meaning that:\n\neither response.body.getReader is a function that returns a ReadableStreamDefaultReader<Uint8Array> object\nor response.body is a Uint8Array Buffer\n\nThis includes support for undici, node-fetch, native Node.js fetch implementation, and WebAPI fetch implementation (browsers).\n\nReact Native​\n\nReceiving the stream relies on the TextDecoder and TextDecoderStream APIs, which is not available in React Native. It's important to note that if your TextDecoderStream polyfill does not automatically polyfill ReadableStream and WritableStream those will also need to be polyfilled. If you still want to enable streaming, you need to polyfill those.\n\nYou will also need to overide the default fetch in the httpBatchStreamLink configuration options. In the below example we will be using the Expo fetch package for the fetch implementation.\n\nhttpBatchStreamLink({\n  fetch: (url, opts) =>\n    fetch(url, {\n      ...opts,\n      reactNative: { textStreaming: true },\n    }),\n  ...restOfConfig,\n});\nCopy\nCompatibility (server-side)​\n\n⚠️ for aws lambda, httpBatchStreamLink is not supported (will simply behave like a regular httpBatchLink). It should not break anything if enabled, but will not have any effect.\n\n⚠️ for cloudflare workers, you need to enable the ReadableStream API through a feature flag: streams_enable_constructors\n\nReference​\n\nYou can check out the source code for this link on GitHub.\n\nConfigure a ping option to keep the connection alive​\n\nWhen setting up your root config, you can pass in a jsonl option to configure a ping option to keep the connection alive.\n\nimport { initTRPC } from '@trpc/server';\nconst t = initTRPC.create({\n  jsonl: {\n    pingMs: 1000,\n  },\n});\nCopy\nEdit this page"
  },
  {
    "title": "HTTP Subscription Link | tRPC",
    "url": "https://trpc.io/docs/client/links/httpSubscriptionLink",
    "html": "Client Usage\nLinks\nHTTP Subscription Link\nVersion: 11.x\nHTTP Subscription Link\n\nhttpSubscriptionLink is a terminating link that's uses Server-sent Events (SSE) for subscriptions.\n\nSSE is a good option for real-time as it's a bit easier than setting up a WebSockets-server.\n\nSetup​\nINFO\n\nIf your client's environment doesn't support EventSource, you need an EventSource polyfill. For React Native specific instructions please defer to the compatibility section.\n\nTo use httpSubscriptionLink, you need to use a splitLink to make it explicit that we want to use SSE for subscriptions.\n\nclient/index.ts\nimport type { TRPCLink } from '@trpc/client';\nimport {\n  httpBatchLink,\n  httpSubscriptionLink,\n  loggerLink,\n  splitLink,\n} from '@trpc/client';\nconst trpcClient = createTRPCClient<AppRouter>({\n  /**\n   * @see https://trpc.io/docs/v11/client/links\n   */\n  links: [\n    // adds pretty logs to your console in development and logs errors in production\n    loggerLink(),\n    splitLink({\n      // uses the httpSubscriptionLink for subscriptions\n      condition: (op) => op.type === 'subscription',\n      true: httpSubscriptionLink({\n        url: `/api/trpc`,\n      }),\n      false: httpBatchLink({\n        url: `/api/trpc`,\n      }),\n    }),\n  ],\n});\nCopy\nTIP\n\nThe document here outlines the specific details of using httpSubscriptionLink. For general usage of subscriptions, see our subscriptions guide.\n\nHeaders and authorization / authentication​\nWeb apps​\nSame domain​\n\nIf you're doing a web application, cookies are sent as part of the request as long as your client is on the same domain as the server.\n\nCross-domain​\n\nIf the client and server are not on the same domain, you can use withCredentials: true (read more on MDN here).\n\nExample:\n\n// [...]\nhttpSubscriptionLink({\n  url: 'https://example.com/api/trpc',\n  eventSourceOptions() {\n    return {\n      withCredentials: true, // <---\n    };\n  },\n});\nCopy\nCustom headers through ponyfill​\n\nRecommended for non-web environments\n\nYou can ponyfill EventSource and use the eventSourceOptions -callback to populate headers.\n\nimport {\n  createTRPCClient,\n  httpBatchLink,\n  httpSubscriptionLink,\n  splitLink,\n} from '@trpc/client';\nimport { EventSourcePolyfill } from 'event-source-polyfill';\nimport type { AppRouter } from '../server/index.js';\n// Initialize the tRPC client\nconst trpc = createTRPCClient<AppRouter>({\n  links: [\n    splitLink({\n      condition: (op) => op.type === 'subscription',\n      true: httpSubscriptionLink({\n        url: 'http://localhost:3000',\n        // ponyfill EventSource\n        EventSource: EventSourcePolyfill,\n        // options to pass to the EventSourcePolyfill constructor\n        eventSourceOptions: async ({ op }) => {\n          //                          ^ Includes the operation that's being executed\n          // you can use this to generate a signature for the operation\n          const signature = await getSignature(op);\n          return {\n            headers: {\n              authorization: 'Bearer supersecret',\n              'x-signature': signature,\n            },\n          };\n        },\n      }),\n      false: httpBatchLink({\n        url: 'http://localhost:3000',\n      }),\n    }),\n  ],\n});\nCopy\nUpdating configuration on an active connection​\n\nhttpSubscriptionLink leverages SSE through EventSource, ensuring that connections encountering errors like network failures or bad response codes are automatically retried. However, EventSource does not allow re-execution of the eventSourceOptions() or url() options to update its configuration, which is particularly important in scenarios where authentication has expired since the last connection.\n\nTo address this limitation, you can use a retryLink in conjunction with httpSubscriptionLink. This approach ensures that the connection is re-established with the latest configuration, including any updated authentication details.\n\nCAUTION\n\nPlease note that restarting the connection will result in the EventSource being recreated from scratch, which means any previously tracked events will be lost.\n\nimport {\n  createTRPCClient,\n  httpBatchLink,\n  httpSubscriptionLink,\n  retryLink,\n  splitLink,\n} from '@trpc/client';\nimport {\n  EventSourcePolyfill,\n  EventSourcePolyfillInit,\n} from 'event-source-polyfill';\nimport type { AppRouter } from '../server/index.js';\n// Initialize the tRPC client\nconst trpc = createTRPCClient<AppRouter>({\n  links: [\n    splitLink({\n      condition: (op) => op.type === 'subscription',\n      false: httpBatchLink({\n        url: 'http://localhost:3000',\n      }),\n      true: [\n        retryLink({\n          retry: (opts) => {\n            opts.op.type;\n            //       ^? will always be 'subscription' since we're in a splitLink\n            const code = opts.error.data?.code;\n            if (!code) {\n              // This shouldn't happen as our httpSubscriptionLink will automatically retry within when there's a non-parsable response\n              console.error('No error code found, retrying', opts);\n              return true;\n            }\n            if (code === 'UNAUTHORIZED' || code === 'FORBIDDEN') {\n              console.log('Retrying due to 401/403 error');\n              return true;\n            }\n            return false;\n          },\n        }),\n        httpSubscriptionLink({\n          url: async () => {\n            // calculate the latest URL if needed...\n            return getAuthenticatedUri();\n          },\n          // ponyfill EventSource\n          EventSource: EventSourcePolyfill,\n          eventSourceOptions: async () => {\n            // ...or maybe renew an access token\n            const token = await auth.getOrRenewToken();\n            return {\n              headers: {\n                authorization: `Bearer ${token}`,\n              },\n            };\n          },\n        }),\n      ],\n    }),\n  ],\n});\nCopy\nConnection params​\n\nIn order to authenticate with EventSource, you can define connectionParams in httpSubscriptionLink. This will be sent as part of the URL, which is why other methods are preferred).\n\nserver/context.ts\nimport type { CreateHTTPContextOptions } from '@trpc/server/adapters/standalone';\n \nexport const createContext = async (opts: CreateHTTPContextOptions) => {\n  const token = opts.info.connectionParams?.token;\n         \nconst token: string | undefined\n \n  // [... authenticate]\n \n  return {};\n};\n \nexport type Context = Awaited<ReturnType<typeof createContext>>;\nCopy\nclient/trpc.ts\nimport {\n  createTRPCClient,\n  httpBatchLink,\n  httpSubscriptionLink,\n  splitLink,\n} from '@trpc/client';\nimport type { AppRouter } from '../server/index.js';\n// Initialize the tRPC client\nconst trpc = createTRPCClient<AppRouter>({\n  links: [\n    splitLink({\n      condition: (op) => op.type === 'subscription',\n      true: httpSubscriptionLink({\n        url: 'http://localhost:3000',\n        connectionParams: async () => {\n          // Will be serialized as part of the URL\n          return {\n            token: 'supersecret',\n          };\n        },\n      }),\n      false: httpBatchLink({\n        url: 'http://localhost:3000',\n      }),\n    }),\n  ],\n});\nCopy\nTimeout Configuration​\n\nThe httpSubscriptionLink supports configuring a timeout for inactivity through the reconnectAfterInactivityMs option. If no messages (including ping messages) are received within the specified timeout period, the connection will be marked as \"connecting\" and automatically attempt to reconnect.\n\nThe timeout configuration is set on the server side when initializing tRPC:\n\nserver/trpc.ts\nimport { initTRPC } from '@trpc/server';\nexport const t = initTRPC.create({\n  sse: {\n    client: {\n      reconnectAfterInactivityMs: 3_000,\n    },\n  },\n});\nCopy\nServer Ping Configuration​\n\nThe server can be configured to send periodic ping messages to keep the connection alive and prevent timeout disconnections. This is particularly useful when combined with the reconnectAfterInactivityMs-option.\n\nserver/trpc.ts\nimport { initTRPC } from '@trpc/server';\nexport const t = initTRPC.create({\n  sse: {\n    // Maximum duration of a single SSE connection in milliseconds\n    // maxDurationMs: 60_00,\n    ping: {\n      // Enable periodic ping messages to keep connection alive\n      enabled: true,\n      // Send ping message every 2s\n      intervalMs: 2_000,\n    },\n    // client: {\n    //   reconnectAfterInactivityMs: 3_000\n    // }\n  },\n});\nCopy\nCompatibility (React Native)​\n\nThe httpSubscriptionLink makes use of the EventSource API, Streams API, and AsyncIterators, these are not natively supported by React Native and will have to be ponyfilled.\n\nTo ponyfill EventSource we recommend to use a polyfill that utilizes the networking library exposed by React Native, over using a polyfill that using the XMLHttpRequest API. Libraries that polyfill EventSource using XMLHttpRequest fail to reconnect after the app has been in the background. Consider using the rn-eventsource-reborn package.\n\nThe Streams API can be ponyfilled using the web-streams-polyfill package.\n\nAsyncIterators can be polyfilled using the @azure/core-asynciterator-polyfill package.\n\nInstallation​\n\nInstall the required polyfills:\n\nnpm\nyarn\npnpm\nbun\ndeno\nnpm install rn-eventsource-reborn web-streams-polyfill @azure/core-asynciterator-polyfill\n\nAdd the polyfills to your project before the link is used (e.g. where you add your TRPCReact.Provider):\n\nutils/api.tsx\nimport '@azure/core-asynciterator-polyfill';\nimport { RNEventSource } from 'rn-eventsource-reborn';\nimport { ReadableStream, TransformStream } from 'web-streams-polyfill';\nglobalThis.ReadableStream = globalThis.ReadableStream || ReadableStream;\nglobalThis.TransformStream = globalThis.TransformStream || TransformStream;\nCopy\n\nOnce the ponyfills are added, you can continue setting up the httpSubscriptionLink as described in the setup section.\n\nhttpSubscriptionLink Options​\ntype HTTPSubscriptionLinkOptions<\n  TRoot extends AnyClientTypes,\n  TEventSource extends EventSourceLike.AnyConstructor = typeof EventSource,\n> = {\n  /**\n   * EventSource ponyfill\n   */\n  EventSource?: TEventSource;\n  /**\n   * EventSource options or a callback that returns them\n   */\n  eventSourceOptions?:\n    | EventSourceLike.InitDictOf<TEventSource>\n    | ((opts: {\n        op: Operation;\n      }) =>\n        | EventSourceLike.InitDictOf<TEventSource>\n        | Promise<EventSourceLike.InitDictOf<TEventSource>>);\n};\nCopy\nSSE Options on the server​\nexport interface SSEStreamProducerOptions<TValue = unknown> {\n  ping?: {\n    /**\n     * Enable ping comments sent from the server\n     * @default false\n     */\n    enabled: boolean;\n    /**\n     * Interval in milliseconds\n     * @default 1000\n     */\n    intervalMs?: number;\n  };\n  /**\n   * Maximum duration in milliseconds for the request before ending the stream\n   * @default undefined\n   */\n  maxDurationMs?: number;\n  /**\n   * End the request immediately after data is sent\n   * Only useful for serverless runtimes that do not support streaming responses\n   * @default false\n   */\n  emitAndEndImmediately?: boolean;\n  /**\n   * Client-specific options - these will be sent to the client as part of the first message\n   * @default {}\n   */\n  client?: {\n    /**\n     * Timeout and reconnect after inactivity in milliseconds\n     * @default undefined\n     */\n    reconnectAfterInactivityMs?: number;\n  };\n}\nCopy\nEdit this page"
  },
  {
    "title": "Local Link | tRPC",
    "url": "https://trpc.io/docs/client/links/localLink",
    "html": "Client Usage\nLinks\nLocal Link\nVersion: 11.x\nLocal Link\n\nlocalLink is a terminating link that allows you to make tRPC procedure calls directly in your application without going through HTTP.\n\nINFO\n\nWe have prefixed this as unstable_ as it's a new API, but you're safe to use it! Read more.\n\nUsage​\nimport { createTRPCClient, unstable_localLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    unstable_localLink({\n      router: appRouter,\n      createContext: async () => {\n        // Create your context here\n        return {};\n      },\n      onError: (opts) => {\n        // Log errors here, similarly to how you would in an API route\n        console.error('Error:', opts.error);\n      },\n    }),\n  ],\n});\nCopy\nFeatures​\nDirect procedure calls without HTTP overhead\nFull support for queries, mutations, and subscriptions\nAutomatic error handling and transformation\nSupport for abort signals\nType-safe context creation\nOptions​\n\nThe localLink accepts the following options:\n\ntype LocalLinkOptions<TRouter extends AnyRouter> = {\n  router: TRouter;\n  createContext: () => Promise<inferRouterContext<TRouter>>;\n  onError?: (opts: ErrorHandlerOptions<inferRouterContext<TRouter>>) => void;\n} & TransformerOptions<inferClientTypes<TRouter>>;\nCopy\nrouter​\n\nThe tRPC router instance to use for procedure calls.\n\ncreateContext​\n\nA function that creates the context for each procedure call. This is called for each request and should return a promise that resolves to the context object.\n\nonError​\n\nAn optional error handler that is called when an error occurs during a procedure call. It receives the error, operation type, path, input, and context.\n\ntransformer​\n\nOptional input/output transformers for serialization/deserialization of data.\n\nNotes​\nIt's recommended to use this link in scenarios where you need direct procedure calls without HTTP\nFor most client-side applications, you should use the httpLink or other HTTP-based links instead\nThe link supports all tRPC features including queries, mutations, and subscriptions\nError handling and transformation are handled automatically, just like with HTTP-based links\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/links/wsLink",
    "html": "Client Usage\nLinks\nWebSocket Link\nVersion: 11.x\nWebSocket Link\n\nwsLink is a terminating link that's used when using tRPC's WebSockets Client and Subscriptions, which you can learn more about here).\n\nUsage​\n\nTo use wsLink, you need to pass it a TRPCWebSocketClient, which you can create with createWSClient:\n\nclient/index.ts\nimport { createTRPCClient, createWSClient, wsLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst wsClient = createWSClient({\n  url: 'ws://localhost:3000',\n});\nconst trpcClient = createTRPCClient<AppRouter>({\n  links: [wsLink<AppRouter>({ client: wsClient })],\n});\nCopy\nAuthentication / Connection params​\n\nSee more here\n\nwsLink / createWSClient Options​\n\nThe wsLink function requires a TRPCWebSocketClient to be passed, which can be configured with the fields defined in WebSocketClientOptions:\n\nexport interface WebSocketLinkOptions {\n  client: TRPCWebSocketClient;\n  /**\n   * Data transformer\n   * @see https://trpc.io/docs/v11/data-transformers\n   **/\n  transformer?: DataTransformerOptions;\n}\nfunction createWSClient(opts: WebSocketClientOptions) => TRPCWebSocketClient\nexport interface WebSocketClientOptions {\n  /**\n   * The URL to connect to (can be a function that returns a URL)\n   */\n  url: string | (() => MaybePromise<string>);\n  /**\n   * Connection params that are available in `createContext()`\n   * These are sent as the first message\n   */\n  connectionParams: string | (() => MaybePromise<string>);\n  /**\n   * Ponyfill which WebSocket implementation to use\n   */\n  WebSocket?: typeof WebSocket;\n  /**\n   * The number of milliseconds before a reconnect is attempted.\n   * @default {@link exponentialBackoff}\n   */\n  retryDelayMs?: typeof exponentialBackoff;\n  /**\n   * Triggered when a WebSocket connection is established\n   */\n  onOpen?: () => void;\n  /**\n   * Triggered when a WebSocket connection encounters an error\n   */\n  onError?: (evt?: Event) => void;\n  /**\n   * Triggered when a WebSocket connection is closed\n   */\n  onClose?: (cause?: { code?: number }) => void;\n  /**\n   * Lazy mode will close the WebSocket automatically after a period of inactivity (no messages sent or received and no pending requests)\n   */\n  lazy?: {\n    /**\n     * Enable lazy mode\n     * @default false\n     */\n    enabled: boolean;\n    /**\n     * Close the WebSocket after this many milliseconds\n     * @default 0\n     */\n    closeMs: number;\n  };\n  /**\n   * Send ping messages to the server and kill the connection if no pong message is returned\n   */\n  keepAlive?: {\n    /**\n     * @default false\n     */\n    enabled: boolean;\n    /**\n     * Send a ping message every this many milliseconds\n     * @default 5_000\n     */\n    intervalMs?: number;\n    /**\n     * Close the WebSocket after this many milliseconds if the server does not respond\n     * @default 1_000\n     */\n    pongTimeoutMs?: number;\n  };\n}\nCopy\nReference​\n\nYou can check out the source code for this link on GitHub.\n\nEdit this page"
  },
  {
    "title": "Split Link | tRPC",
    "url": "https://trpc.io/docs/client/links/splitLink",
    "html": "Client Usage\nLinks\nSplit Link\nVersion: 11.x\nSplit Link\n\nsplitLink is a link that allows you to branch your link chain's execution depending on a given condition. Both the true and false branches are required. You can provide just one link, or multiple links per branch via an array.\n\nIt's important to note that when you provide links for splitLink to execute, splitLink will create an entirely new link chain based on the links you passed. Therefore, you need to use a terminating link if you only provide one link or add the terminating link at the end of the array if you provide multiple links to be executed on a branch. Here's a visual representation of how splitLink works:\n\ntRPC Client\nOperation\nLink\nLink\nsplitLink\nInitiated\nCompleted\ndown\ndown\nup\nup\nTerminating Link\nRequest\nResponse\nRequest\ntRPC Server\npasses \ncondition?\nLink\nTerminating Link\nLink\ntrue\nBranch\nfalse\nBranch\ndown\nup\nResponse\nYES\nNO\ndown\nup\ndown\nup\nUsage Example​\nDisable batching for certain requests​\n\nLet's say you're using httpBatchLink as the terminating link in your tRPC client config. This means request batching is enabled in every request. However, if you need to disable batching only for certain requests, you would need to change the terminating link in your tRPC client config dynamically between httpLink and httpBatchLink. This is a perfect opportunity for splitLink to be used:\n\n1. Configure client / utils/trpc.ts​\nclient/index.ts\nimport {\n  createTRPCClient,\n  httpBatchLink,\n  httpLink,\n  splitLink,\n} from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst url = `http://localhost:3000`;\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    splitLink({\n      condition(op) {\n        // check for context property `skipBatch`\n        return Boolean(op.context.skipBatch);\n      },\n      // when condition is true, use normal request\n      true: httpLink({\n        url,\n      }),\n      // when condition is false, use batching\n      false: httpBatchLink({\n        url,\n      }),\n    }),\n  ],\n});\nCopy\n2. Perform request without batching​\nclient.ts\nconst postResult = proxy.posts.query(null, {\n  context: {\n    skipBatch: true,\n  },\n});\nCopy\n\nor:\n\nMyComponent.tsx\nexport function MyComponent() {\n  const postsQuery = proxy.posts.useQuery(undefined, {\n    trpc: {\n      context: {\n        skipBatch: true,\n      },\n    }\n  });\n  return (\n    <pre>{JSON.stringify(postsQuery.data ?? null, null, 4)}</pre>\n  )\n})\nCopy\nsplitLink Options​\n\nThe splitLink function takes an options object that has three fields: condition, true, and false.\n\nfunction splitLink<TRouter extends AnyRouter = AnyRouter>(opts: {\n  condition: (op: Operation) => boolean;\n  /**\n   * The link to execute next if the test function returns `true`.\n   */\n  true: TRPCLink<TRouter> | TRPCLink<TRouter>[];\n  /**\n   * The link to execute next if the test function returns `false`.\n   */\n  false: TRPCLink<TRouter> | TRPCLink<TRouter>[];\n}) => TRPCLink<TRouter>\nCopy\nReference​\n\nYou can check out the source code for this link on GitHub.\n\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/links/loggerLink",
    "html": "Client Usage\nLinks\nLogger Link\nVersion: 11.x\nLogger Link\n\nloggerLink is a link that lets you implement a logger for your tRPC client. It allows you to see more clearly what operations are queries, mutations, or subscriptions, their requests, and responses. The link, by default, prints a prettified log to the browser's console. However, you can customize the logging behavior and the way it prints to the console with your own implementations.\n\nUsage​\n\nYou can import and add the loggerLink to the links array as such:\n\nclient/index.ts\nimport { createTRPCClient, httpBatchLink, loggerLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    /**\n     * The function passed to enabled is an example in case you want to the link to\n     * log to your console in development and only log errors in production\n     */\n    loggerLink({\n      enabled: (opts) =>\n        (process.env.NODE_ENV === 'development' &&\n          typeof window !== 'undefined') ||\n        (opts.direction === 'down' && opts.result instanceof Error),\n    }),\n    httpBatchLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\nCopy\nloggerLink Options​\n\nThe loggerLink function takes an options object that has the LoggerLinkOptions shape:\n\ntype LoggerLinkOptions<TRouter extends AnyRouter> = {\n  logger?: LogFn<TRouter>;\n  /**\n   * It is a function that returns a condition that determines whether to enable the logger.\n   * It is true by default.\n   */\n  enabled?: EnabledFn<TRouter>;\n  /**\n   * Used in the built-in defaultLogger\n   */\n  console?: ConsoleEsque;\n  /**\n   * Color mode used in the default logger.\n   * @default typeof window === 'undefined' ? 'ansi' : 'css'\n   */\n  colorMode?: 'ansi' | 'css';\n};\nCopy\nReference​\n\nYou can check out the source code for this link on GitHub.\n\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/client/links/retryLink",
    "html": "Client Usage\nLinks\nRetry Link\nVersion: 11.x\nRetry Link\n\nretryLink is a link that allows you to retry failed operations in your tRPC client. It provides a customizable way to handle transient errors, such as network failures or server errors, by automatically retrying the failed requests based on specified conditions.\n\nTIP\n\nIf you use @trpc/react-query you will generally not need this link as it's built into the useQuery() and the useMutation() hooks from @tanstack/react-query.\n\nUsage​\n\nYou can import and add the retryLink to the links array when creating your tRPC client. This link can be placed before or after other links in your setup, depending on your requirements.\n\nimport { createTRPCClient, retryLink } from '@trpc/client';\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    retryLink({\n      retry(opts) {\n        if (\n          opts.error.data &&\n          opts.error.data.code !== 'INTERNAL_SERVER_ERROR'\n        ) {\n          // Don't retry on non-500s\n          return false;\n        }\n        if (opts.op.type !== 'query') {\n          // Only retry queries\n          return false;\n        }\n        // Retry up to 3 times\n        return opts.attempts <= 3;\n      },\n      // Double every attempt, with max of 30 seconds (starting at 1 second)\n      retryDelayMs: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\n    }),\n    httpBatchLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\nCopy\n\nIn the example above, we add the retryLink before the httpBatchLink. By default, retryLink will:\n\nRetry the request if the error is a TRPCClientError with a status code of 500 or if we couldn't get a valid TRPC error.\nRetry the request up to 3 times.\n\nYou can customize the retry logic by providing a custom retry function.\n\nOptions​\ninterface RetryLinkOptions<TInferrable extends InferrableClientTypes> {\n  /**\n   * The retry function\n   */\n  retry: (opts: RetryFnOptions<TInferrable>) => boolean;\n  /**\n   * The delay between retries in ms (defaults to 0)\n   */\n  retryDelayMs?: (attempt: number) => number;\n}\ninterface RetryFnOptions<TInferrable extends InferrableClientTypes> {\n  /**\n   * The operation that failed\n   */\n  op: Operation;\n  /**\n   * The error that occurred\n   */\n  error: TRPCClientError<TInferrable>;\n  /**\n   * The number of attempts that have been made (including the first call)\n   */\n  attempts: number;\n}\nCopy\nHandling tracked() events​\n\nWhen using retryLink with subscriptions that use tracked(), the link will automatically include the last known event ID when retrying. This ensures that when a subscription reconnects, it can resume from where it left off without missing any events.\n\nFor example, if you're using Server-sent Events (SSE) with httpSubscriptionLink, the retryLink will automatically handle reconnecting with the last event ID when errors like 401 Unauthorized occur.\n\nEdit this page"
  }
]
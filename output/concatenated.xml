<directory_structure>
output/
  nextjs/
    docs.json
  react/
    reference.json
  trpc/
    docs.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="output/nextjs/docs.json">
[
  {
    "title": "Architecture: Accessibility | Next.js",
    "url": "https://nextjs.org/docs/architecture/accessibility",
    "html": "Next.js Docs\nArchitecture\nAccessibility\nCopy page\nAccessibility\n\nThe Next.js team is committed to making Next.js accessible to all developers (and their end-users). By adding accessibility features to Next.js by default, we aim to make the Web more inclusive for everyone.\n\nRoute Announcements\n\nWhen transitioning between pages rendered on the server (e.g. using the <a href> tag) screen readers and other assistive technology announce the page title when the page loads so that users understand that the page has changed.\n\nIn addition to traditional page navigations, Next.js also supports client-side transitions for improved performance (using next/link). To ensure that client-side transitions are also announced to assistive technology, Next.js includes a route announcer by default.\n\nThe Next.js route announcer looks for the page name to announce by first inspecting document.title, then the <h1> element, and finally the URL pathname. For the most accessible user experience, ensure that each page in your application has a unique and descriptive title.\n\nLinting\n\nNext.js provides an integrated ESLint experience out of the box, including custom rules for Next.js. By default, Next.js includes eslint-plugin-jsx-a11y to help catch accessibility issues early, including warning on:\n\naria-props\naria-proptypes\naria-unsupported-elements\nrole-has-required-aria-props\nrole-supports-aria-props\n\nFor example, this plugin helps ensure you add alt text to img tags, use correct aria-* attributes, use correct role attributes, and more.\n\nAccessibility Resources\nWebAIM WCAG checklist\nWCAG 2.2 Guidelines\nThe A11y Project\nCheck color contrast ratios\n between foreground and background elements\nUse prefers-reduced-motion\n when working with animations\nPrevious\nArchitecture\nNext\nFast Refresh\n\nWas this helpful?\n\nsupported.\nSend"
  }
]
</file>

<file path="output/react/reference.json">
[
  {
    "title": "React DOM APIs ‚Äì React",
    "url": "https://react.dev/reference/react-dom",
    "html": "API REFERENCE\nReact DOM APIs\n\nThe react-dom package contains methods that are only supported for the web applications (which run in the browser DOM environment). They are not supported for React Native.\n\nAPIs \n\nThese APIs can be imported from your components. They are rarely used:\n\ncreatePortal lets you render child components in a different part of the DOM tree.\nflushSync lets you force React to flush a state update and update the DOM synchronously.\nResource Preloading APIs \n\nThese APIs can be used to make apps faster by pre-loading resources such as scripts, stylesheets, and fonts as soon as you know you need them, for example before navigating to another page where the resources will be used.\n\nReact-based frameworks frequently handle resource loading for you, so you might not have to call these APIs yourself. Consult your framework‚Äôs documentation for details.\n\nprefetchDNS lets you prefetch the IP address of a DNS domain name that you expect to connect to.\npreconnect lets you connect to a server you expect to request resources from, even if you don‚Äôt know what resources you‚Äôll need yet.\npreload lets you fetch a stylesheet, font, image, or external script that you expect to use.\npreloadModule lets you fetch an ESM module that you expect to use.\npreinit lets you fetch and evaluate an external script or fetch and insert a stylesheet.\npreinitModule lets you fetch and evaluate an ESM module.\nEntry points \n\nThe react-dom package provides two additional entry points:\n\nreact-dom/client contains APIs to render React components on the client (in the browser).\nreact-dom/server contains APIs to render React components on the server.\nRemoved APIs \n\nThese APIs were removed in React 19:\n\nfindDOMNode: see alternatives.\nhydrate: use hydrateRoot instead.\nrender: use createRoot instead.\nunmountComponentAtNode: use root.unmount() instead.\nrenderToNodeStream: use react-dom/server APIs instead.\nrenderToStaticNodeStream: use react-dom/server APIs instead.\nPREVIOUS\n<title>\nNEXT\ncreatePortal"
  },
  {
    "title": "Built-in React DOM Hooks ‚Äì React",
    "url": "https://react.dev/reference/react-dom/hooks",
    "html": "API REFERENCE\nBuilt-in React DOM Hooks\n\nThe react-dom package contains Hooks that are only supported for web applications (which run in the browser DOM environment). These Hooks are not supported in non-browser environments like iOS, Android, or Windows applications. If you are looking for Hooks that are supported in web browsers and other environments see the React Hooks page. This page lists all the Hooks in the react-dom package.\n\nForm Hooks \n\nForms let you create interactive controls for submitting information.  To manage forms in your components, use one of these Hooks:\n\nuseFormStatus allows you to make updates to the UI based on the status of a form.\nfunction Form({ action }) {\n\n  async function increment(n) {\n\n    return n + 1;\n\n  }\n\n  const [count, incrementFormAction] = useActionState(increment, 0);\n\n  return (\n\n    <form action={action}>\n\n      <button formAction={incrementFormAction}>Count: {count}</button>\n\n      <Button />\n\n    </form>\n\n  );\n\n}\n\n\n\nfunction Button() {\n\n  const { pending } = useFormStatus();\n\n  return (\n\n    <button disabled={pending} type=\"submit\">\n\n      Submit\n\n    </button>\n\n  );\n\n}\nNEXT\nuseFormStatus"
  },
  {
    "title": "useFormStatus ‚Äì React",
    "url": "https://react.dev/reference/react-dom/hooks/useFormStatus",
    "html": "API REFERENCE\nHOOKS\nuseFormStatus\n\nuseFormStatus is a Hook that gives you status information of the last form submission.\n\nconst { pending, data, method, action } = useFormStatus();\nReference\nuseFormStatus()\nUsage\nDisplay a pending state during form submission\nRead the form data being submitted\nTroubleshooting\nstatus.pending is never true\nReference \nuseFormStatus() \n\nThe useFormStatus Hook provides status information of the last form submission.\n\nimport { useFormStatus } from \"react-dom\";\n\nimport action from './actions';\n\n\n\nfunction Submit() {\n\n  const status = useFormStatus();\n\n  return <button disabled={status.pending}>Submit</button>\n\n}\n\n\n\nexport default function App() {\n\n  return (\n\n    <form action={action}>\n\n      <Submit />\n\n    </form>\n\n  );\n\n}\n\nTo get status information, the Submit component must be rendered within a <form>. The Hook returns information like the pending property which tells you if the form is actively submitting.\n\nIn the above example, Submit uses this information to disable <button> presses while the form is submitting.\n\nSee more examples below.\n\nParameters \n\nuseFormStatus does not take any parameters.\n\nReturns \n\nA status object with the following properties:\n\npending: A boolean. If true, this means the parent <form> is pending submission. Otherwise, false.\n\ndata: An object implementing the FormData interface that contains the data the parent <form> is submitting. If there is no active submission or no parent <form>, it will be null.\n\nmethod: A string value of either 'get' or 'post'. This represents whether the parent <form> is submitting with either a GET or POST HTTP method. By default, a <form> will use the GET method and can be specified by the method property.\n\naction: A reference to the function passed to the action prop on the parent <form>. If there is no parent <form>, the property is null. If there is a URI value provided to the action prop, or no action prop specified, status.action will be null.\nCaveats \nThe useFormStatus Hook must be called from a component that is rendered inside a <form>.\nuseFormStatus will only return status information for a parent <form>. It will not return status information for any <form> rendered in that same component or children components.\nUsage \nDisplay a pending state during form submission \n\nTo display a pending state while a form is submitting, you can call the useFormStatus Hook in a component rendered in a <form> and read the pending property returned.\n\nHere, we use the pending property to indicate the form is submitting.\n\nApp.js\nReload\nClear\nFork\nimport { useFormStatus } from \"react-dom\";\nimport { submitForm } from \"./actions.js\";\n\nfunction Submit() {\n  const { pending } = useFormStatus();\n  return (\n    <button type=\"submit\" disabled={pending}>\n      {pending ? \"Submitting...\" : \"Submit\"}\n    </button>\n  );\n}\n\nfunction Form({ action }) {\n  return (\n    <form action={action}>\n      <Submit />\n    </form>\n  );\n}\n\nexport default function App() {\n  return <Form action={submitForm} />;\n}\n\n\nShow more\nPitfall\nuseFormStatus will not return status information for a <form> rendered in the same component. \n\nThe useFormStatus Hook only returns status information for a parent <form> and not for any <form> rendered in the same component calling the Hook, or child components.\n\nfunction Form() {\n\n  // üö© `pending` will never be true\n\n  // useFormStatus does not track the form rendered in this component\n\n  const { pending } = useFormStatus();\n\n  return <form action={submit}></form>;\n\n}\n\nInstead call useFormStatus from inside a component that is located inside <form>.\n\nfunction Submit() {\n\n  // ‚úÖ `pending` will be derived from the form that wraps the Submit component\n\n  const { pending } = useFormStatus(); \n\n  return <button disabled={pending}>...</button>;\n\n}\n\n\n\nfunction Form() {\n\n  // This is the <form> `useFormStatus` tracks\n\n  return (\n\n    <form action={submit}>\n\n      <Submit />\n\n    </form>\n\n  );\n\n}\nRead the form data being submitted \n\nYou can use the data property of the status information returned from useFormStatus to display what data is being submitted by the user.\n\nHere, we have a form where users can request a username. We can use useFormStatus to display a temporary status message confirming what username they have requested.\n\nUsernameForm.js\nApp.js\nReload\nClear\nFork\nimport {useState, useMemo, useRef} from 'react';\nimport {useFormStatus} from 'react-dom';\n\nexport default function UsernameForm() {\n  const {pending, data} = useFormStatus();\n\n  return (\n    <div>\n      <h3>Request a Username: </h3>\n      <input type=\"text\" name=\"username\" disabled={pending}/>\n      <button type=\"submit\" disabled={pending}>\n        Submit\n      </button>\n      <br />\n      <p>{data ? `Requesting ${data?.get(\"username\")}...`: ''}</p>\n    </div>\n  );\n}\n\n\nShow more\nTroubleshooting \nstatus.pending is never true \n\nuseFormStatus will only return status information for a parent <form>.\n\nIf the component that calls useFormStatus is not nested in a <form>, status.pending will always return false. Verify useFormStatus is called in a component that is a child of a <form> element.\n\nuseFormStatus will not track the status of a <form> rendered in the same component. See Pitfall for more details.\n\nPREVIOUS\nHooks\nNEXT\nComponents"
  },
  {
    "title": "React DOM Components ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components",
    "html": "API REFERENCE\nReact DOM Components\n\nReact supports all of the browser built-in HTML and SVG components.\n\nCommon components \n\nAll of the built-in browser components support some props and events.\n\nCommon components (e.g. <div>)\n\nThis includes React-specific props like ref and dangerouslySetInnerHTML.\n\nForm components \n\nThese built-in browser components accept user input:\n\n<input>\n<select>\n<textarea>\n\nThey are special in React because passing the value prop to them makes them controlled.\n\nResource and Metadata Components \n\nThese built-in browser components let you load external resources or annotate the document with metadata:\n\n<link>\n<meta>\n<script>\n<style>\n<title>\n\nThey are special in React because React can render them into the document head, suspend while resources are loading, and enact other behaviors that are described on the reference page for each specific component.\n\nAll HTML components \n\nReact supports all built-in browser HTML components. This includes:\n\n<aside>\n<audio>\n<b>\n<base>\n<bdi>\n<bdo>\n<blockquote>\n<body>\n<br>\n<button>\n<canvas>\n<caption>\n<cite>\n<code>\n<col>\n<colgroup>\n<data>\n<datalist>\n<dd>\n<del>\n<details>\n<dfn>\n<dialog>\n<div>\n<dl>\n<dt>\n<em>\n<embed>\n<fieldset>\n<figcaption>\n<figure>\n<footer>\n<form>\n<h1>\n<head>\n<header>\n<hgroup>\n<hr>\n<html>\n<i>\n<iframe>\n<img>\n<input>\n<ins>\n<kbd>\n<label>\n<legend>\n<li>\n<link>\n<main>\n<map>\n<mark>\n<menu>\n<meta>\n<meter>\n<nav>\n<noscript>\n<object>\n<ol>\n<optgroup>\n<option>\n<output>\n<p>\n<picture>\n<pre>\n<progress>\n<q>\n<rp>\n<rt>\n<ruby>\n<s>\n<samp>\n<script>\n<section>\n<select>\n<slot>\n<small>\n<source>\n<span>\n<strong>\n<style>\n<sub>\n<summary>\n<sup>\n<table>\n<tbody>\n<td>\n<template>\n<textarea>\n<tfoot>\n<th>\n<thead>\n<time>\n<title>\n<tr>\n<track>\n<u>\n<ul>\n<var>\n<video>\n<wbr>\nNote\n\nSimilar to the DOM standard, React uses a camelCase convention for prop names. For example, you‚Äôll write tabIndex instead of tabindex. You can convert existing HTML to JSX with an online converter.\n\nCustom HTML elements \n\nIf you render a tag with a dash, like <my-element>, React will assume you want to render a custom HTML element.\n\nIf you render a built-in browser HTML element with an is attribute, it will also be treated as a custom element.\n\nSetting values on custom elements \n\nCustom elements have two methods of passing data into them:\n\nAttributes: Which are displayed in markup and can only be set to string values\nProperties: Which are not displayed in markup and can be set to arbitrary JavaScript values\n\nBy default, React will pass values bound in JSX as attributes:\n\n<my-element value=\"Hello, world!\"></my-element>\n\nNon-string JavaScript values passed to custom elements will be serialized by default:\n\n// Will be passed as `\"1,2,3\"` as the output of `[1,2,3].toString()`\n\n<my-element value={[1,2,3]}></my-element>\n\nReact will, however, recognize an custom element‚Äôs property as one that it may pass arbitrary values to if the property name shows up on the class during construction:\n\nMyElement.js\nApp.js\nReload\nClear\nFork\nexport class MyElement extends HTMLElement {\n  constructor() {\n    super();\n    // The value here will be overwritten by React \n    // when initialized as an element\n    this.value = undefined;\n  }\n\n  connectedCallback() {\n    this.innerHTML = this.value.join(\", \");\n  }\n}\n\n\nListening for events on custom elements \n\nA common pattern when using custom elements is that they may dispatch CustomEvents rather than accept a function to call when an event occur. You can listen for these events using an on prefix when binding to the event via JSX.\n\nMyElement.js\nApp.js\nReload\nClear\nFork\nexport function App() {\n  return (\n    <my-element\n      onspeak={e => console.log(e.detail.message)}\n    ></my-element>\n  )\n}\n\n\nNote\n\nEvents are case-sensitive and support dashes (-). Preserve the casing of the event and include all dashes when listening for custom element‚Äôs events:\n\n// Listens for `say-hi` events\n\n<my-element onsay-hi={console.log}></my-element>\n\n// Listens for `sayHi` events\n\n<my-element onsayHi={console.log}></my-element>\nAll SVG components \n\nReact supports all built-in browser SVG components. This includes:\n\n<a>\n<animate>\n<animateMotion>\n<animateTransform>\n<circle>\n<clipPath>\n<defs>\n<desc>\n<discard>\n<ellipse>\n<feBlend>\n<feColorMatrix>\n<feComponentTransfer>\n<feComposite>\n<feConvolveMatrix>\n<feDiffuseLighting>\n<feDisplacementMap>\n<feDistantLight>\n<feDropShadow>\n<feFlood>\n<feFuncA>\n<feFuncB>\n<feFuncG>\n<feFuncR>\n<feGaussianBlur>\n<feImage>\n<feMerge>\n<feMergeNode>\n<feMorphology>\n<feOffset>\n<fePointLight>\n<feSpecularLighting>\n<feSpotLight>\n<feTile>\n<feTurbulence>\n<filter>\n<foreignObject>\n<g>\n<hatch>\n<hatchpath>\n<image>\n<line>\n<linearGradient>\n<marker>\n<mask>\n<metadata>\n<mpath>\n<path>\n<pattern>\n<polygon>\n<polyline>\n<radialGradient>\n<rect>\n<script>\n<set>\n<stop>\n<style>\n<svg>\n<switch>\n<symbol>\n<text>\n<textPath>\n<title>\n<tspan>\n<use>\n<view>\nNote\n\nSimilar to the DOM standard, React uses a camelCase convention for prop names. For example, you‚Äôll write tabIndex instead of tabindex. You can convert existing SVG to JSX with an online converter.\n\nNamespaced attributes also have to be written without the colon:\n\nxlink:actuate becomes xlinkActuate.\nxlink:arcrole becomes xlinkArcrole.\nxlink:href becomes xlinkHref.\nxlink:role becomes xlinkRole.\nxlink:show becomes xlinkShow.\nxlink:title becomes xlinkTitle.\nxlink:type becomes xlinkType.\nxml:base becomes xmlBase.\nxml:lang becomes xmlLang.\nxml:space becomes xmlSpace.\nxmlns:xlink becomes xmlnsXlink.\nPREVIOUS\nuseFormStatus\nNEXT\nCommon (e.g. <div>)"
  },
  {
    "title": "Common components (e.g. <div>) ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/common",
    "html": "API REFERENCE\nCOMPONENTS\nCommon components (e.g. <div>)\n\nAll built-in browser components, such as <div>, support some common props and events.\n\nReference\nCommon components (e.g. <div>)\nref callback function\nReact event object\nAnimationEvent handler function\nClipboardEvent handler function\nCompositionEvent handler function\nDragEvent handler function\nFocusEvent handler function\nEvent handler function\nInputEvent handler function\nKeyboardEvent handler function\nMouseEvent handler function\nPointerEvent handler function\nTouchEvent handler function\nTransitionEvent handler function\nUIEvent handler function\nWheelEvent handler function\nUsage\nApplying CSS styles\nManipulating a DOM node with a ref\nDangerously setting the inner HTML\nHandling mouse events\nHandling pointer events\nHandling focus events\nHandling keyboard events\nReference \nCommon components (e.g. <div>) \n<div className=\"wrapper\">Some content</div>\n\nSee more examples below.\n\nProps \n\nThese special React props are supported for all built-in components:\n\nchildren: A React node (an element, a string, a number, a portal, an empty node like null, undefined and booleans, or an array of other React nodes). Specifies the content inside the component. When you use JSX, you will usually specify the children prop implicitly by nesting tags like <div><span /></div>.\n\ndangerouslySetInnerHTML: An object of the form { __html: '<p>some html</p>' } with a raw HTML string inside. Overrides the innerHTML property of the DOM node and displays the passed HTML inside. This should be used with extreme caution! If the HTML inside isn‚Äôt trusted (for example, if it‚Äôs based on user data), you risk introducing an XSS vulnerability. Read more about using dangerouslySetInnerHTML.\n\nref: A ref object from useRef or createRef, or a ref callback function, or a string for legacy refs. Your ref will be filled with the DOM element for this node. Read more about manipulating the DOM with refs.\n\nsuppressContentEditableWarning: A boolean. If true, suppresses the warning that React shows for elements that both have children and contentEditable={true} (which normally do not work together). Use this if you‚Äôre building a text input library that manages the contentEditable content manually.\n\nsuppressHydrationWarning: A boolean. If you use server rendering, normally there is a warning when the server and the client render different content. In some rare cases (like timestamps), it is very hard or impossible to guarantee an exact match. If you set suppressHydrationWarning to true, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don‚Äôt overuse it. Read about suppressing hydration errors.\n\nstyle: An object with CSS styles, for example { fontWeight: 'bold', margin: 20 }. Similarly to the DOM style property, the CSS property names need to be written as camelCase, for example fontWeight instead of font-weight. You can pass strings or numbers as values. If you pass a number, like width: 100, React will automatically append px (‚Äúpixels‚Äù) to the value unless it‚Äôs a unitless property. We recommend using style only for dynamic styles where you don‚Äôt know the style values ahead of time. In other cases, applying plain CSS classes with className is more efficient. Read more about className and style.\n\nThese standard DOM props are also supported for all built-in components:\n\naccessKey: A string. Specifies a keyboard shortcut for the element. Not generally recommended.\naria-*: ARIA attributes let you specify the accessibility tree information for this element. See ARIA attributes for a complete reference. In React, all ARIA attribute names are exactly the same as in HTML.\nautoCapitalize: A string. Specifies whether and how the user input should be capitalized.\nclassName: A string. Specifies the element‚Äôs CSS class name. Read more about applying CSS styles.\ncontentEditable: A boolean. If true, the browser lets the user edit the rendered element directly. This is used to implement rich text input libraries like Lexical. React warns if you try to pass React children to an element with contentEditable={true} because React will not be able to update its content after user edits.\ndata-*: Data attributes let you attach some string data to the element, for example data-fruit=\"banana\". In React, they are not commonly used because you would usually read data from props or state instead.\ndir: Either 'ltr' or 'rtl'. Specifies the text direction of the element.\ndraggable: A boolean. Specifies whether the element is draggable. Part of HTML Drag and Drop API.\nenterKeyHint: A string. Specifies which action to present for the enter key on virtual keyboards.\nhtmlFor: A string. For <label> and <output>, lets you associate the label with some control. Same as for HTML attribute. React uses the standard DOM property names (htmlFor) instead of HTML attribute names.\nhidden: A boolean or a string. Specifies whether the element should be hidden.\nid: A string. Specifies a unique identifier for this element, which can be used to find it later or connect it with other elements. Generate it with useId to avoid clashes between multiple instances of the same component.\nis: A string. If specified, the component will behave like a custom element.\ninputMode: A string. Specifies what kind of keyboard to display (for example, text, number or telephone).\nitemProp: A string. Specifies which property the element represents for structured data crawlers.\nlang: A string. Specifies the language of the element.\nonAnimationEnd: An AnimationEvent handler function. Fires when a CSS animation completes.\nonAnimationEndCapture: A version of onAnimationEnd that fires in the capture phase.\nonAnimationIteration: An AnimationEvent handler function. Fires when an iteration of a CSS animation ends, and another one begins.\nonAnimationIterationCapture: A version of onAnimationIteration that fires in the capture phase.\nonAnimationStart: An AnimationEvent handler function. Fires when a CSS animation starts.\nonAnimationStartCapture: onAnimationStart, but fires in the capture phase.\nonAuxClick: A MouseEvent handler function. Fires when a non-primary pointer button was clicked.\nonAuxClickCapture: A version of onAuxClick that fires in the capture phase.\nonBeforeInput: An InputEvent handler function. Fires before the value of an editable element is modified. React does not yet use the native beforeinput event, and instead attempts to polyfill it using other events.\nonBeforeInputCapture: A version of onBeforeInput that fires in the capture phase.\nonBlur: A FocusEvent handler function. Fires when an element lost focus. Unlike the built-in browser blur event, in React the onBlur event bubbles.\nonBlurCapture: A version of onBlur that fires in the capture phase.\nonClick: A MouseEvent handler function. Fires when the primary button was clicked on the pointing device.\nonClickCapture: A version of onClick that fires in the capture phase.\nonCompositionStart: A CompositionEvent handler function. Fires when an input method editor starts a new composition session.\nonCompositionStartCapture: A version of onCompositionStart that fires in the capture phase.\nonCompositionEnd: A CompositionEvent handler function. Fires when an input method editor completes or cancels a composition session.\nonCompositionEndCapture: A version of onCompositionEnd that fires in the capture phase.\nonCompositionUpdate: A CompositionEvent handler function. Fires when an input method editor receives a new character.\nonCompositionUpdateCapture: A version of onCompositionUpdate that fires in the capture phase.\nonContextMenu: A MouseEvent handler function. Fires when the user tries to open a context menu.\nonContextMenuCapture: A version of onContextMenu that fires in the capture phase.\nonCopy: A ClipboardEvent handler function. Fires when the user tries to copy something into the clipboard.\nonCopyCapture: A version of onCopy that fires in the capture phase.\nonCut: A ClipboardEvent handler function. Fires when the user tries to cut something into the clipboard.\nonCutCapture: A version of onCut that fires in the capture phase.\nonDoubleClick: A MouseEvent handler function. Fires when the user clicks twice. Corresponds to the browser dblclick event.\nonDoubleClickCapture: A version of onDoubleClick that fires in the capture phase.\nonDrag: A DragEvent handler function. Fires while the user is dragging something.\nonDragCapture: A version of onDrag that fires in the capture phase.\nonDragEnd: A DragEvent handler function. Fires when the user stops dragging something.\nonDragEndCapture: A version of onDragEnd that fires in the capture phase.\nonDragEnter: A DragEvent handler function. Fires when the dragged content enters a valid drop target.\nonDragEnterCapture: A version of onDragEnter that fires in the capture phase.\nonDragOver: A DragEvent handler function. Fires on a valid drop target while the dragged content is dragged over it. You must call e.preventDefault() here to allow dropping.\nonDragOverCapture: A version of onDragOver that fires in the capture phase.\nonDragStart: A DragEvent handler function. Fires when the user starts dragging an element.\nonDragStartCapture: A version of onDragStart that fires in the capture phase.\nonDrop: A DragEvent handler function. Fires when something is dropped on a valid drop target.\nonDropCapture: A version of onDrop that fires in the capture phase.\nonFocus: A FocusEvent handler function. Fires when an element receives focus. Unlike the built-in browser focus event, in React the onFocus event bubbles.\nonFocusCapture: A version of onFocus that fires in the capture phase.\nonGotPointerCapture: A PointerEvent handler function. Fires when an element programmatically captures a pointer.\nonGotPointerCaptureCapture: A version of onGotPointerCapture that fires in the capture phase.\nonKeyDown: A KeyboardEvent handler function. Fires when a key is pressed.\nonKeyDownCapture: A version of onKeyDown that fires in the capture phase.\nonKeyPress: A KeyboardEvent handler function. Deprecated. Use onKeyDown or onBeforeInput instead.\nonKeyPressCapture: A version of onKeyPress that fires in the capture phase.\nonKeyUp: A KeyboardEvent handler function. Fires when a key is released.\nonKeyUpCapture: A version of onKeyUp that fires in the capture phase.\nonLostPointerCapture: A PointerEvent handler function. Fires when an element stops capturing a pointer.\nonLostPointerCaptureCapture: A version of onLostPointerCapture that fires in the capture phase.\nonMouseDown: A MouseEvent handler function. Fires when the pointer is pressed down.\nonMouseDownCapture: A version of onMouseDown that fires in the capture phase.\nonMouseEnter: A MouseEvent handler function. Fires when the pointer moves inside an element. Does not have a capture phase. Instead, onMouseLeave and onMouseEnter propagate from the element being left to the one being entered.\nonMouseLeave: A MouseEvent handler function. Fires when the pointer moves outside an element. Does not have a capture phase. Instead, onMouseLeave and onMouseEnter propagate from the element being left to the one being entered.\nonMouseMove: A MouseEvent handler function. Fires when the pointer changes coordinates.\nonMouseMoveCapture: A version of onMouseMove that fires in the capture phase.\nonMouseOut: A MouseEvent handler function. Fires when the pointer moves outside an element, or if it moves into a child element.\nonMouseOutCapture: A version of onMouseOut that fires in the capture phase.\nonMouseUp: A MouseEvent handler function. Fires when the pointer is released.\nonMouseUpCapture: A version of onMouseUp that fires in the capture phase.\nonPointerCancel: A PointerEvent handler function. Fires when the browser cancels a pointer interaction.\nonPointerCancelCapture: A version of onPointerCancel that fires in the capture phase.\nonPointerDown: A PointerEvent handler function. Fires when a pointer becomes active.\nonPointerDownCapture: A version of onPointerDown that fires in the capture phase.\nonPointerEnter: A PointerEvent handler function. Fires when a pointer moves inside an element. Does not have a capture phase. Instead, onPointerLeave and onPointerEnter propagate from the element being left to the one being entered.\nonPointerLeave: A PointerEvent handler function. Fires when a pointer moves outside an element. Does not have a capture phase. Instead, onPointerLeave and onPointerEnter propagate from the element being left to the one being entered.\nonPointerMove: A PointerEvent handler function. Fires when a pointer changes coordinates.\nonPointerMoveCapture: A version of onPointerMove that fires in the capture phase.\nonPointerOut: A PointerEvent handler function. Fires when a pointer moves outside an element, if the pointer interaction is cancelled, and a few other reasons.\nonPointerOutCapture: A version of onPointerOut that fires in the capture phase.\nonPointerUp: A PointerEvent handler function. Fires when a pointer is no longer active.\nonPointerUpCapture: A version of onPointerUp that fires in the capture phase.\nonPaste: A ClipboardEvent handler function. Fires when the user tries to paste something from the clipboard.\nonPasteCapture: A version of onPaste that fires in the capture phase.\nonScroll: An Event handler function. Fires when an element has been scrolled. This event does not bubble.\nonScrollCapture: A version of onScroll that fires in the capture phase.\nonSelect: An Event handler function. Fires after the selection inside an editable element like an input changes. React extends the onSelect event to work for contentEditable={true} elements as well. In addition, React extends it to fire for empty selection and on edits (which may affect the selection).\nonSelectCapture: A version of onSelect that fires in the capture phase.\nonTouchCancel: A TouchEvent handler function. Fires when the browser cancels a touch interaction.\nonTouchCancelCapture: A version of onTouchCancel that fires in the capture phase.\nonTouchEnd: A TouchEvent handler function. Fires when one or more touch points are removed.\nonTouchEndCapture: A version of onTouchEnd that fires in the capture phase.\nonTouchMove: A TouchEvent handler function. Fires one or more touch points are moved.\nonTouchMoveCapture: A version of onTouchMove that fires in the capture phase.\nonTouchStart: A TouchEvent handler function. Fires when one or more touch points are placed.\nonTouchStartCapture: A version of onTouchStart that fires in the capture phase.\nonTransitionEnd: A TransitionEvent handler function. Fires when a CSS transition completes.\nonTransitionEndCapture: A version of onTransitionEnd that fires in the capture phase.\nonWheel: A WheelEvent handler function. Fires when the user rotates a wheel button.\nonWheelCapture: A version of onWheel that fires in the capture phase.\nrole: A string. Specifies the element role explicitly for assistive technologies.\nslot: A string. Specifies the slot name when using shadow DOM. In React, an equivalent pattern is typically achieved by passing JSX as props, for example <Layout left={<Sidebar />} right={<Content />} />.\nspellCheck: A boolean or null. If explicitly set to true or false, enables or disables spellchecking.\ntabIndex: A number. Overrides the default Tab button behavior. Avoid using values other than -1 and 0.\ntitle: A string. Specifies the tooltip text for the element.\ntranslate: Either 'yes' or 'no'. Passing 'no' excludes the element content from being translated.\n\nYou can also pass custom attributes as props, for example mycustomprop=\"someValue\". This can be useful when integrating with third-party libraries. The custom attribute name must be lowercase and must not start with on. The value will be converted to a string. If you pass null or undefined, the custom attribute will be removed.\n\nThese events fire only for the <form> elements:\n\nonReset: An Event handler function. Fires when a form gets reset.\nonResetCapture: A version of onReset that fires in the capture phase.\nonSubmit: An Event handler function. Fires when a form gets submitted.\nonSubmitCapture: A version of onSubmit that fires in the capture phase.\n\nThese events fire only for the <dialog> elements. Unlike browser events, they bubble in React:\n\nonCancel: An Event handler function. Fires when the user tries to dismiss the dialog.\nonCancelCapture: A version of onCancel that fires in the capture phase.\nonClose: An Event handler function. Fires when a dialog has been closed.\nonCloseCapture: A version of onClose that fires in the capture phase.\n\nThese events fire only for the <details> elements. Unlike browser events, they bubble in React:\n\nonToggle: An Event handler function. Fires when the user toggles the details.\nonToggleCapture: A version of onToggle that fires in the capture phase.\n\nThese events fire for <img>, <iframe>, <object>, <embed>, <link>, and SVG <image> elements. Unlike browser events, they bubble in React:\n\nonLoad: An Event handler function. Fires when the resource has loaded.\nonLoadCapture: A version of onLoad that fires in the capture phase.\nonError: An Event handler function. Fires when the resource could not be loaded.\nonErrorCapture: A version of onError that fires in the capture phase.\n\nThese events fire for resources like <audio> and <video>. Unlike browser events, they bubble in React:\n\nonAbort: An Event handler function. Fires when the resource has not fully loaded, but not due to an error.\nonAbortCapture: A version of onAbort that fires in the capture phase.\nonCanPlay: An Event handler function. Fires when there‚Äôs enough data to start playing, but not enough to play to the end without buffering.\nonCanPlayCapture: A version of onCanPlay that fires in the capture phase.\nonCanPlayThrough: An Event handler function. Fires when there‚Äôs enough data that it‚Äôs likely possible to start playing without buffering until the end.\nonCanPlayThroughCapture: A version of onCanPlayThrough that fires in the capture phase.\nonDurationChange: An Event handler function. Fires when the media duration has updated.\nonDurationChangeCapture: A version of onDurationChange that fires in the capture phase.\nonEmptied: An Event handler function. Fires when the media has become empty.\nonEmptiedCapture: A version of onEmptied that fires in the capture phase.\nonEncrypted: An Event handler function. Fires when the browser encounters encrypted media.\nonEncryptedCapture: A version of onEncrypted that fires in the capture phase.\nonEnded: An Event handler function. Fires when the playback stops because there‚Äôs nothing left to play.\nonEndedCapture: A version of onEnded that fires in the capture phase.\nonError: An Event handler function. Fires when the resource could not be loaded.\nonErrorCapture: A version of onError that fires in the capture phase.\nonLoadedData: An Event handler function. Fires when the current playback frame has loaded.\nonLoadedDataCapture: A version of onLoadedData that fires in the capture phase.\nonLoadedMetadata: An Event handler function. Fires when metadata has loaded.\nonLoadedMetadataCapture: A version of onLoadedMetadata that fires in the capture phase.\nonLoadStart: An Event handler function. Fires when the browser started loading the resource.\nonLoadStartCapture: A version of onLoadStart that fires in the capture phase.\nonPause: An Event handler function. Fires when the media was paused.\nonPauseCapture: A version of onPause that fires in the capture phase.\nonPlay: An Event handler function. Fires when the media is no longer paused.\nonPlayCapture: A version of onPlay that fires in the capture phase.\nonPlaying: An Event handler function. Fires when the media starts or restarts playing.\nonPlayingCapture: A version of onPlaying that fires in the capture phase.\nonProgress: An Event handler function. Fires periodically while the resource is loading.\nonProgressCapture: A version of onProgress that fires in the capture phase.\nonRateChange: An Event handler function. Fires when playback rate changes.\nonRateChangeCapture: A version of onRateChange that fires in the capture phase.\nonResize: An Event handler function. Fires when video changes size.\nonResizeCapture: A version of onResize that fires in the capture phase.\nonSeeked: An Event handler function. Fires when a seek operation completes.\nonSeekedCapture: A version of onSeeked that fires in the capture phase.\nonSeeking: An Event handler function. Fires when a seek operation starts.\nonSeekingCapture: A version of onSeeking that fires in the capture phase.\nonStalled: An Event handler function. Fires when the browser is waiting for data but it keeps not loading.\nonStalledCapture: A version of onStalled that fires in the capture phase.\nonSuspend: An Event handler function. Fires when loading the resource was suspended.\nonSuspendCapture: A version of onSuspend that fires in the capture phase.\nonTimeUpdate: An Event handler function. Fires when the current playback time updates.\nonTimeUpdateCapture: A version of onTimeUpdate that fires in the capture phase.\nonVolumeChange: An Event handler function. Fires when the volume has changed.\nonVolumeChangeCapture: A version of onVolumeChange that fires in the capture phase.\nonWaiting: An Event handler function. Fires when the playback stopped due to temporary lack of data.\nonWaitingCapture: A version of onWaiting that fires in the capture phase.\nCaveats \nYou cannot pass both children and dangerouslySetInnerHTML at the same time.\nSome events (like onAbort and onLoad) don‚Äôt bubble in the browser, but bubble in React.\nref callback function \n\nInstead of a ref object (like the one returned by useRef), you may pass a function to the ref attribute.\n\n<div ref={(node) => {\n\n  console.log('Attached', node);\n\n\n\n  return () => {\n\n    console.log('Clean up', node)\n\n  }\n\n}}>\n\nSee an example of using the ref callback.\n\nWhen the <div> DOM node is added to the screen, React will call your ref callback with the DOM node as the argument. When that <div> DOM node is removed, React will call your the cleanup function returned from the callback.\n\nReact will also call your ref callback whenever you pass a different ref callback. In the above example, (node) => { ... } is a different function on every render. When your component re-renders, the previous function will be called with null as the argument, and the next function will be called with the DOM node.\n\nParameters \nnode: A DOM node. React will pass you the DOM node when the ref gets attached. Unless you pass the same function reference for the ref callback on every render, the callback will get temporarily cleanup and re-create during every re-render of the component.\nNote\nReact 19 added cleanup functions for ref callbacks. \n\nTo support backwards compatibility, if a cleanup function is not returned from the ref callback, node will be called with null when the ref is detached. This behavior will be removed in a future version.\n\nReturns \noptional cleanup function: When the ref is detached, React will call the cleanup function. If a function is not returned by the ref callback, React will call the callback again with null as the argument when the ref gets detached. This behavior will be removed in a future version.\nCaveats \nWhen Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic ‚Äúmirrors‚Äù your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.\nWhen you pass a different ref callback, React will call the previous callback‚Äôs cleanup function if provided. If no cleanup function is defined, the ref callback will be called with null as the argument. The next function will be called with the DOM node.\nReact event object \n\nYour event handlers will receive a React event object. It is also sometimes known as a ‚Äúsynthetic event‚Äù.\n\n<button onClick={e => {\n\n  console.log(e); // React event object\n\n}} />\n\nIt conforms to the same standard as the underlying DOM events, but fixes some browser inconsistencies.\n\nSome React events do not map directly to the browser‚Äôs native events. For example in onMouseLeave, e.nativeEvent will point to a mouseout event. The specific mapping is not part of the public API and may change in the future. If you need the underlying browser event for some reason, read it from e.nativeEvent.\n\nProperties \n\nReact event objects implement some of the standard Event properties:\n\nbubbles: A boolean. Returns whether the event bubbles through the DOM.\ncancelable: A boolean. Returns whether the event can be canceled.\ncurrentTarget: A DOM node. Returns the node to which the current handler is attached in the React tree.\ndefaultPrevented: A boolean. Returns whether preventDefault was called.\neventPhase: A number. Returns which phase the event is currently in.\nisTrusted: A boolean. Returns whether the event was initiated by user.\ntarget: A DOM node. Returns the node on which the event has occurred (which could be a distant child).\ntimeStamp: A number. Returns the time when the event occurred.\n\nAdditionally, React event objects provide these properties:\n\nnativeEvent: A DOM Event. The original browser event object.\nMethods \n\nReact event objects implement some of the standard Event methods:\n\npreventDefault(): Prevents the default browser action for the event.\nstopPropagation(): Stops the event propagation through the React tree.\n\nAdditionally, React event objects provide these methods:\n\nisDefaultPrevented(): Returns a boolean value indicating whether preventDefault was called.\nisPropagationStopped(): Returns a boolean value indicating whether stopPropagation was called.\npersist(): Not used with React DOM. With React Native, call this to read event‚Äôs properties after the event.\nisPersistent(): Not used with React DOM. With React Native, returns whether persist has been called.\nCaveats \nThe values of currentTarget, eventPhase, target, and type reflect the values your React code expects. Under the hood, React attaches event handlers at the root, but this is not reflected in React event objects. For example, e.currentTarget may not be the same as the underlying e.nativeEvent.currentTarget. For polyfilled events, e.type (React event type) may differ from e.nativeEvent.type (underlying type).\nAnimationEvent handler function \n\nAn event handler type for the CSS animation events.\n\n<div\n\n  onAnimationStart={e => console.log('onAnimationStart')}\n\n  onAnimationIteration={e => console.log('onAnimationIteration')}\n\n  onAnimationEnd={e => console.log('onAnimationEnd')}\n\n/>\nParameters \ne: A React event object with these extra AnimationEvent properties:\nanimationName\nelapsedTime\npseudoElement\nClipboardEvent handler function \n\nAn event handler type for the Clipboard API events.\n\n<input\n\n  onCopy={e => console.log('onCopy')}\n\n  onCut={e => console.log('onCut')}\n\n  onPaste={e => console.log('onPaste')}\n\n/>\nParameters \n\ne: A React event object with these extra ClipboardEvent properties:\n\nclipboardData\nCompositionEvent handler function \n\nAn event handler type for the input method editor (IME) events.\n\n<input\n\n  onCompositionStart={e => console.log('onCompositionStart')}\n\n  onCompositionUpdate={e => console.log('onCompositionUpdate')}\n\n  onCompositionEnd={e => console.log('onCompositionEnd')}\n\n/>\nParameters \ne: A React event object with these extra CompositionEvent properties:\ndata\nDragEvent handler function \n\nAn event handler type for the HTML Drag and Drop API events.\n\n<>\n\n  <div\n\n    draggable={true}\n\n    onDragStart={e => console.log('onDragStart')}\n\n    onDragEnd={e => console.log('onDragEnd')}\n\n  >\n\n    Drag source\n\n  </div>\n\n\n\n  <div\n\n    onDragEnter={e => console.log('onDragEnter')}\n\n    onDragLeave={e => console.log('onDragLeave')}\n\n    onDragOver={e => { e.preventDefault(); console.log('onDragOver'); }}\n\n    onDrop={e => console.log('onDrop')}\n\n  >\n\n    Drop target\n\n  </div>\n\n</>\nParameters \n\ne: A React event object with these extra DragEvent properties:\n\ndataTransfer\n\nIt also includes the inherited MouseEvent properties:\n\naltKey\nbutton\nbuttons\nctrlKey\nclientX\nclientY\ngetModifierState(key)\nmetaKey\nmovementX\nmovementY\npageX\npageY\nrelatedTarget\nscreenX\nscreenY\nshiftKey\n\nIt also includes the inherited UIEvent properties:\n\ndetail\nview\nFocusEvent handler function \n\nAn event handler type for the focus events.\n\n<input\n\n  onFocus={e => console.log('onFocus')}\n\n  onBlur={e => console.log('onBlur')}\n\n/>\n\nSee an example.\n\nParameters \n\ne: A React event object with these extra FocusEvent properties:\n\nrelatedTarget\n\nIt also includes the inherited UIEvent properties:\n\ndetail\nview\nEvent handler function \n\nAn event handler type for generic events.\n\nParameters \ne: A React event object with no additional properties.\nInputEvent handler function \n\nAn event handler type for the onBeforeInput event.\n\n<input onBeforeInput={e => console.log('onBeforeInput')} />\nParameters \ne: A React event object with these extra InputEvent properties:\ndata\nKeyboardEvent handler function \n\nAn event handler type for keyboard events.\n\n<input\n\n  onKeyDown={e => console.log('onKeyDown')}\n\n  onKeyUp={e => console.log('onKeyUp')}\n\n/>\n\nSee an example.\n\nParameters \n\ne: A React event object with these extra KeyboardEvent properties:\n\naltKey\ncharCode\ncode\nctrlKey\ngetModifierState(key)\nkey\nkeyCode\nlocale\nmetaKey\nlocation\nrepeat\nshiftKey\nwhich\n\nIt also includes the inherited UIEvent properties:\n\ndetail\nview\nMouseEvent handler function \n\nAn event handler type for mouse events.\n\n<div\n\n  onClick={e => console.log('onClick')}\n\n  onMouseEnter={e => console.log('onMouseEnter')}\n\n  onMouseOver={e => console.log('onMouseOver')}\n\n  onMouseDown={e => console.log('onMouseDown')}\n\n  onMouseUp={e => console.log('onMouseUp')}\n\n  onMouseLeave={e => console.log('onMouseLeave')}\n\n/>\n\nSee an example.\n\nParameters \n\ne: A React event object with these extra MouseEvent properties:\n\naltKey\nbutton\nbuttons\nctrlKey\nclientX\nclientY\ngetModifierState(key)\nmetaKey\nmovementX\nmovementY\npageX\npageY\nrelatedTarget\nscreenX\nscreenY\nshiftKey\n\nIt also includes the inherited UIEvent properties:\n\ndetail\nview\nPointerEvent handler function \n\nAn event handler type for pointer events.\n\n<div\n\n  onPointerEnter={e => console.log('onPointerEnter')}\n\n  onPointerMove={e => console.log('onPointerMove')}\n\n  onPointerDown={e => console.log('onPointerDown')}\n\n  onPointerUp={e => console.log('onPointerUp')}\n\n  onPointerLeave={e => console.log('onPointerLeave')}\n\n/>\n\nSee an example.\n\nParameters \n\ne: A React event object with these extra PointerEvent properties:\n\nheight\nisPrimary\npointerId\npointerType\npressure\ntangentialPressure\ntiltX\ntiltY\ntwist\nwidth\n\nIt also includes the inherited MouseEvent properties:\n\naltKey\nbutton\nbuttons\nctrlKey\nclientX\nclientY\ngetModifierState(key)\nmetaKey\nmovementX\nmovementY\npageX\npageY\nrelatedTarget\nscreenX\nscreenY\nshiftKey\n\nIt also includes the inherited UIEvent properties:\n\ndetail\nview\nTouchEvent handler function \n\nAn event handler type for touch events.\n\n<div\n\n  onTouchStart={e => console.log('onTouchStart')}\n\n  onTouchMove={e => console.log('onTouchMove')}\n\n  onTouchEnd={e => console.log('onTouchEnd')}\n\n  onTouchCancel={e => console.log('onTouchCancel')}\n\n/>\nParameters \n\ne: A React event object with these extra TouchEvent properties:\n\naltKey\nctrlKey\nchangedTouches\ngetModifierState(key)\nmetaKey\nshiftKey\ntouches\ntargetTouches\n\nIt also includes the inherited UIEvent properties:\n\ndetail\nview\nTransitionEvent handler function \n\nAn event handler type for the CSS transition events.\n\n<div\n\n  onTransitionEnd={e => console.log('onTransitionEnd')}\n\n/>\nParameters \ne: A React event object with these extra TransitionEvent properties:\nelapsedTime\npropertyName\npseudoElement\nUIEvent handler function \n\nAn event handler type for generic UI events.\n\n<div\n\n  onScroll={e => console.log('onScroll')}\n\n/>\nParameters \ne: A React event object with these extra UIEvent properties:\ndetail\nview\nWheelEvent handler function \n\nAn event handler type for the onWheel event.\n\n<div\n\n  onWheel={e => console.log('onWheel')}\n\n/>\nParameters \n\ne: A React event object with these extra WheelEvent properties:\n\ndeltaMode\ndeltaX\ndeltaY\ndeltaZ\n\nIt also includes the inherited MouseEvent properties:\n\naltKey\nbutton\nbuttons\nctrlKey\nclientX\nclientY\ngetModifierState(key)\nmetaKey\nmovementX\nmovementY\npageX\npageY\nrelatedTarget\nscreenX\nscreenY\nshiftKey\n\nIt also includes the inherited UIEvent properties:\n\ndetail\nview\nUsage \nApplying CSS styles \n\nIn React, you specify a CSS class with className. It works like the class attribute in HTML:\n\n<img className=\"avatar\" />\n\nThen you write the CSS rules for it in a separate CSS file:\n\n/* In your CSS */\n\n.avatar {\n\n  border-radius: 50%;\n\n}\n\nReact does not prescribe how you add CSS files. In the simplest case, you‚Äôll add a <link> tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project.\n\nSometimes, the style values depend on data. Use the style attribute to pass some styles dynamically:\n\n<img\n\n  className=\"avatar\"\n\n  style={{\n\n    width: user.imageSize,\n\n    height: user.imageSize\n\n  }}\n\n/>\n\nIn the above example, style={{}} is not a special syntax, but a regular {} object inside the style={ } JSX curly braces. We recommend only using the style attribute when your styles depend on JavaScript variables.\n\nApp.js\nAvatar.js\nReload\nClear\nFork\nexport default function Avatar({ user }) {\n  return (\n    <img\n      src={user.imageUrl}\n      alt={'Photo of ' + user.name}\n      className=\"avatar\"\n      style={{\n        width: user.imageSize,\n        height: user.imageSize\n      }}\n    />\n  );\n}\n\n\nDEEP DIVE\nHow to apply multiple CSS classes conditionally? \nShow Details\nManipulating a DOM node with a ref \n\nSometimes, you‚Äôll need to get the browser DOM node associated with a tag in JSX. For example, if you want to focus an <input> when a button is clicked, you need to call focus() on the browser <input> DOM node.\n\nTo obtain the browser DOM node for a tag, declare a ref and pass it as the ref attribute to that tag:\n\nimport { useRef } from 'react';\n\n\n\nexport default function Form() {\n\n  const inputRef = useRef(null);\n\n  // ...\n\n  return (\n\n    <input ref={inputRef} />\n\n    // ...\n\nReact will put the DOM node into inputRef.current after it‚Äôs been rendered to the screen.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useRef } from 'react';\n\nexport default function Form() {\n  const inputRef = useRef(null);\n\n  function handleClick() {\n    inputRef.current.focus();\n  }\n\n  return (\n    <>\n      <input ref={inputRef} />\n      <button onClick={handleClick}>\n        Focus the input\n      </button>\n    </>\n  );\n}\n\n\nShow more\n\nRead more about manipulating DOM with refs and check out more examples.\n\nFor more advanced use cases, the ref attribute also accepts a callback function.\n\nDangerously setting the inner HTML \n\nYou can pass a raw HTML string to an element like so:\n\nconst markup = { __html: '<p>some raw html</p>' };\n\nreturn <div dangerouslySetInnerHTML={markup} />;\n\nThis is dangerous. As with the underlying DOM innerHTML property, you must exercise extreme caution! Unless the markup is coming from a completely trusted source, it is trivial to introduce an XSS vulnerability this way.\n\nFor example, if you use a Markdown library that converts Markdown to HTML, you trust that its parser doesn‚Äôt contain bugs, and the user only sees their own input, you can display the resulting HTML like this:\n\npackage.json\nApp.js\nMarkdownPreview.js\nReload\nClear\nFork\nimport { Remarkable } from 'remarkable';\n\nconst md = new Remarkable();\n\nfunction renderMarkdownToHTML(markdown) {\n  // This is ONLY safe because the output HTML\n  // is shown to the same user, and because you\n  // trust this Markdown parser to not have bugs.\n  const renderedHTML = md.render(markdown);\n  return {__html: renderedHTML};\n}\n\nexport default function MarkdownPreview({ markdown }) {\n  const markup = renderMarkdownToHTML(markdown);\n  return <div dangerouslySetInnerHTML={markup} />;\n}\n\n\nShow more\n\nThe {__html} object should be created as close to where the HTML is generated as possible, like the above example does in the renderMarkdownToHTML function. This ensures that all raw HTML being used in your code is explicitly marked as such, and that only variables that you expect to contain HTML are passed to dangerouslySetInnerHTML. It is not recommended to create the object inline like <div dangerouslySetInnerHTML={{__html: markup}} />.\n\nTo see why rendering arbitrary HTML is dangerous, replace the code above with this:\n\nconst post = {\n\n  // Imagine this content is stored in the database.\n\n  content: `<img src=\"\" onerror='alert(\"you were hacked\")'>`\n\n};\n\n\n\nexport default function MarkdownPreview() {\n\n  // üî¥ SECURITY HOLE: passing untrusted input to dangerouslySetInnerHTML\n\n  const markup = { __html: post.content };\n\n  return <div dangerouslySetInnerHTML={markup} />;\n\n}\n\nThe code embedded in the HTML will run. A hacker could use this security hole to steal user information or to perform actions on their behalf. Only use dangerouslySetInnerHTML with trusted and sanitized data.\n\nHandling mouse events \n\nThis example shows some common mouse events and when they fire.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function MouseExample() {\n  return (\n    <div\n      onMouseEnter={e => console.log('onMouseEnter (parent)')}\n      onMouseLeave={e => console.log('onMouseLeave (parent)')}\n    >\n      <button\n        onClick={e => console.log('onClick (first button)')}\n        onMouseDown={e => console.log('onMouseDown (first button)')}\n        onMouseEnter={e => console.log('onMouseEnter (first button)')}\n        onMouseLeave={e => console.log('onMouseLeave (first button)')}\n        onMouseOver={e => console.log('onMouseOver (first button)')}\n        onMouseUp={e => console.log('onMouseUp (first button)')}\n      >\n        First button\n      </button>\n      <button\n        onClick={e => console.log('onClick (second button)')}\n        onMouseDown={e => console.log('onMouseDown (second button)')}\n        onMouseEnter={e => console.log('onMouseEnter (second button)')}\n        onMouseLeave={e => console.log('onMouseLeave (second button)')}\n        onMouseOver={e => console.log('onMouseOver (second button)')}\n        onMouseUp={e => console.log('onMouseUp (second button)')}\n      >\n        Second button\n      </button>\n    </div>\n  );\n}\n\n\nShow more\nHandling pointer events \n\nThis example shows some common pointer events and when they fire.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function PointerExample() {\n  return (\n    <div\n      onPointerEnter={e => console.log('onPointerEnter (parent)')}\n      onPointerLeave={e => console.log('onPointerLeave (parent)')}\n      style={{ padding: 20, backgroundColor: '#ddd' }}\n    >\n      <div\n        onPointerDown={e => console.log('onPointerDown (first child)')}\n        onPointerEnter={e => console.log('onPointerEnter (first child)')}\n        onPointerLeave={e => console.log('onPointerLeave (first child)')}\n        onPointerMove={e => console.log('onPointerMove (first child)')}\n        onPointerUp={e => console.log('onPointerUp (first child)')}\n        style={{ padding: 20, backgroundColor: 'lightyellow' }}\n      >\n        First child\n      </div>\n      <div\n        onPointerDown={e => console.log('onPointerDown (second child)')}\n        onPointerEnter={e => console.log('onPointerEnter (second child)')}\n        onPointerLeave={e => console.log('onPointerLeave (second child)')}\n        onPointerMove={e => console.log('onPointerMove (second child)')}\n        onPointerUp={e => console.log('onPointerUp (second child)')}\n        style={{ padding: 20, backgroundColor: 'lightblue' }}\n      >\n        Second child\n      </div>\n    </div>\n  );\n}\n\n\nShow more\nHandling focus events \n\nIn React, focus events bubble. You can use the currentTarget and relatedTarget to differentiate if the focusing or blurring events originated from outside of the parent element. The example shows how to detect focusing a child, focusing the parent element, and how to detect focus entering or leaving the whole subtree.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function FocusExample() {\n  return (\n    <div\n      tabIndex={1}\n      onFocus={(e) => {\n        if (e.currentTarget === e.target) {\n          console.log('focused parent');\n        } else {\n          console.log('focused child', e.target.name);\n        }\n        if (!e.currentTarget.contains(e.relatedTarget)) {\n          // Not triggered when swapping focus between children\n          console.log('focus entered parent');\n        }\n      }}\n      onBlur={(e) => {\n        if (e.currentTarget === e.target) {\n          console.log('unfocused parent');\n        } else {\n          console.log('unfocused child', e.target.name);\n        }\n        if (!e.currentTarget.contains(e.relatedTarget)) {\n          // Not triggered when swapping focus between children\n          console.log('focus left parent');\n        }\n      }}\n    >\n      <label>\n        First name:\n        <input name=\"firstName\" />\n      </label>\n      <label>\n        Last name:\n        <input name=\"lastName\" />\n      </label>\n    </div>\n  );\n}\n\n\nShow more\nHandling keyboard events \n\nThis example shows some common keyboard events and when they fire.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function KeyboardExample() {\n  return (\n    <label>\n      First name:\n      <input\n        name=\"firstName\"\n        onKeyDown={e => console.log('onKeyDown:', e.key, e.code)}\n        onKeyUp={e => console.log('onKeyUp:', e.key, e.code)}\n      />\n    </label>\n  );\n}\n\n\nPREVIOUS\nComponents\nNEXT\n<form>"
  },
  {
    "title": "<form> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/form",
    "html": "API REFERENCE\nCOMPONENTS\n<form>\n\nThe built-in browser <form> component lets you create interactive controls for submitting information.\n\n<form action={search}>\n\n    <input name=\"query\" />\n\n    <button type=\"submit\">Search</button>\n\n</form>\nReference\n<form>\nUsage\nHandle form submission on the client\nHandle form submission with a Server Function\nDisplay a pending state during form submission\nOptimistically updating form data\nHandling form submission errors\nDisplay a form submission error without JavaScript\nHandling multiple submission types\nReference \n<form> \n\nTo create interactive controls for submitting information, render the built-in browser <form> component.\n\n<form action={search}>\n\n    <input name=\"query\" />\n\n    <button type=\"submit\">Search</button>\n\n</form>\n\nSee more examples below.\n\nProps \n\n<form> supports all common element props.\n\naction: a URL or function. When a URL is passed to action the form will behave like the HTML form component. When a function is passed to action the function will handle the form submission in a Transition following the Action prop pattern. The function passed to action may be async and will be called with a single argument containing the form data of the submitted form. The action prop can be overridden by a formAction attribute on a <button>, <input type=\"submit\">, or <input type=\"image\"> component.\n\nCaveats \nWhen a function is passed to action or formAction the HTTP method will be POST regardless of value of the method prop.\nUsage \nHandle form submission on the client \n\nPass a function to the action prop of form to run the function when the form is submitted. formData will be passed to the function as an argument so you can access the data submitted by the form. This differs from the conventional HTML action, which only accepts URLs. After the action function succeeds, all uncontrolled field elements in the form are reset.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function Search() {\n  function search(formData) {\n    const query = formData.get(\"query\");\n    alert(`You searched for '${query}'`);\n  }\n  return (\n    <form action={search}>\n      <input name=\"query\" />\n      <button type=\"submit\">Search</button>\n    </form>\n  );\n}\n\n\nHandle form submission with a Server Function \n\nRender a <form> with an input and submit button. Pass a Server Function (a function marked with 'use server') to the action prop of form to run the function when the form is submitted.\n\nPassing a Server Function to <form action> allow users to submit forms without JavaScript enabled or before the code has loaded. This is beneficial to users who have a slow connection, device, or have JavaScript disabled and is similar to the way forms work when a URL is passed to the action prop.\n\nYou can use hidden form fields to provide data to the <form>‚Äôs action. The Server Function will be called with the hidden form field data as an instance of FormData.\n\nimport { updateCart } from './lib.js';\n\n\n\nfunction AddToCart({productId}) {\n\n  async function addToCart(formData) {\n\n    'use server'\n\n    const productId = formData.get('productId')\n\n    await updateCart(productId)\n\n  }\n\n  return (\n\n    <form action={addToCart}>\n\n        <input type=\"hidden\" name=\"productId\" value={productId} />\n\n        <button type=\"submit\">Add to Cart</button>\n\n    </form>\n\n\n\n  );\n\n}\n\nIn lieu of using hidden form fields to provide data to the <form>‚Äôs action, you can call the bind method to supply it with extra arguments. This will bind a new argument (productId) to the function in addition to the formData that is passed as an argument to the function.\n\nimport { updateCart } from './lib.js';\n\n\n\nfunction AddToCart({productId}) {\n\n  async function addToCart(productId, formData) {\n\n    \"use server\";\n\n    await updateCart(productId)\n\n  }\n\n  const addProductToCart = addToCart.bind(null, productId);\n\n  return (\n\n    <form action={addProductToCart}>\n\n      <button type=\"submit\">Add to Cart</button>\n\n    </form>\n\n  );\n\n}\n\nWhen <form> is rendered by a Server Component, and a Server Function is passed to the <form>‚Äôs action prop, the form is progressively enhanced.\n\nDisplay a pending state during form submission \n\nTo display a pending state when a form is being submitted, you can call the useFormStatus Hook in a component rendered in a <form> and read the pending property returned.\n\nHere, we use the pending property to indicate the form is submitting.\n\nApp.js\nReload\nClear\nFork\nimport { useFormStatus } from \"react-dom\";\nimport { submitForm } from \"./actions.js\";\n\nfunction Submit() {\n  const { pending } = useFormStatus();\n  return (\n    <button type=\"submit\" disabled={pending}>\n      {pending ? \"Submitting...\" : \"Submit\"}\n    </button>\n  );\n}\n\nfunction Form({ action }) {\n  return (\n    <form action={action}>\n      <Submit />\n    </form>\n  );\n}\n\nexport default function App() {\n  return <Form action={submitForm} />;\n}\n\n\nShow more\n\nTo learn more about the useFormStatus Hook see the reference documentation.\n\nOptimistically updating form data \n\nThe useOptimistic Hook provides a way to optimistically update the user interface before a background operation, like a network request, completes. In the context of forms, this technique helps to make apps feel more responsive. When a user submits a form, instead of waiting for the server‚Äôs response to reflect the changes, the interface is immediately updated with the expected outcome.\n\nFor example, when a user types a message into the form and hits the ‚ÄúSend‚Äù button, the useOptimistic Hook allows the message to immediately appear in the list with a ‚ÄúSending‚Ä¶‚Äù label, even before the message is actually sent to a server. This ‚Äúoptimistic‚Äù approach gives the impression of speed and responsiveness. The form then attempts to truly send the message in the background. Once the server confirms the message has been received, the ‚ÄúSending‚Ä¶‚Äù label is removed.\n\nApp.js\nactions.js\nReload\nClear\nFork\nimport { useOptimistic, useState, useRef } from \"react\";\nimport { deliverMessage } from \"./actions.js\";\n\nfunction Thread({ messages, sendMessage }) {\n  const formRef = useRef();\n  async function formAction(formData) {\n    addOptimisticMessage(formData.get(\"message\"));\n    formRef.current.reset();\n    await sendMessage(formData);\n  }\n  const [optimisticMessages, addOptimisticMessage] = useOptimistic(\n    messages,\n    (state, newMessage) => [\n      ...state,\n      {\n        text: newMessage,\n        sending: true\n      }\n    ]\n  );\n\n  return (\n    <>\n      {optimisticMessages.map((message, index) => (\n        <div key={index}>\n          {message.text}\n          {!!message.sending && <small> (Sending...)</small>}\n        </div>\n      ))}\n      <form action={formAction} ref={formRef}>\n        <input type=\"text\" name=\"message\" placeholder=\"Hello!\" />\n        <button type=\"submit\">Send</button>\n      </form>\n    </>\n  );\n}\n\nexport default function App() {\n  const [messages, setMessages] = useState([\n    { text: \"Hello there!\", sending: false, key: 1 }\n  ]);\n  async function sendMessage(formData) {\n    const sentMessage = await deliverMessage(formData.get(\"message\"));\n    setMessages((messages) => [...messages, { text: sentMessage }]);\n  }\n  return <Thread messages={messages} sendMessage={sendMessage} />;\n}\n\n\nShow more\nHandling form submission errors \n\nIn some cases the function called by a <form>‚Äôs action prop throws an error. You can handle these errors by wrapping <form> in an Error Boundary. If the function called by a <form>‚Äôs action prop throws an error, the fallback for the error boundary will be displayed.\n\nApp.js\nReload\nClear\nFork\nimport { ErrorBoundary } from \"react-error-boundary\";\n\nexport default function Search() {\n  function search() {\n    throw new Error(\"search error\");\n  }\n  return (\n    <ErrorBoundary\n      fallback={<p>There was an error while submitting the form</p>}\n    >\n      <form action={search}>\n        <input name=\"query\" />\n        <button type=\"submit\">Search</button>\n      </form>\n    </ErrorBoundary>\n  );\n}\n\n\nShow more\nDisplay a form submission error without JavaScript \n\nDisplaying a form submission error message before the JavaScript bundle loads for progressive enhancement requires that:\n\n<form> be rendered by a Client Component\nthe function passed to the <form>‚Äôs action prop be a Server Function\nthe useActionState Hook be used to display the error message\n\nuseActionState takes two parameters: a Server Function and an initial state. useActionState returns two values, a state variable and an action. The action returned by useActionState should be passed to the action prop of the form. The state variable returned by useActionState can be used to display an error message. The value returned by the Server Function passed to useActionState will be used to update the state variable.\n\nApp.js\nReload\nClear\nFork\nimport { useActionState } from \"react\";\nimport { signUpNewUser } from \"./api\";\n\nexport default function Page() {\n  async function signup(prevState, formData) {\n    \"use server\";\n    const email = formData.get(\"email\");\n    try {\n      await signUpNewUser(email);\n      alert(`Added \"${email}\"`);\n    } catch (err) {\n      return err.toString();\n    }\n  }\n  const [message, signupAction] = useActionState(signup, null);\n  return (\n    <>\n      <h1>Signup for my newsletter</h1>\n      <p>Signup with the same email twice to see an error</p>\n      <form action={signupAction} id=\"signup-form\">\n        <label htmlFor=\"email\">Email: </label>\n        <input name=\"email\" id=\"email\" placeholder=\"react@example.com\" />\n        <button>Sign up</button>\n        {!!message && <p>{message}</p>}\n      </form>\n    </>\n  );\n}\n\n\nShow more\n\nLearn more about updating state from a form action with the useActionState docs\n\nHandling multiple submission types \n\nForms can be designed to handle multiple submission actions based on the button pressed by the user. Each button inside a form can be associated with a distinct action or behavior by setting the formAction prop.\n\nWhen a user taps a specific button, the form is submitted, and a corresponding action, defined by that button‚Äôs attributes and action, is executed. For instance, a form might submit an article for review by default but have a separate button with formAction set to save the article as a draft.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function Search() {\n  function publish(formData) {\n    const content = formData.get(\"content\");\n    const button = formData.get(\"button\");\n    alert(`'${content}' was published with the '${button}' button`);\n  }\n\n  function save(formData) {\n    const content = formData.get(\"content\");\n    alert(`Your draft of '${content}' has been saved!`);\n  }\n\n  return (\n    <form action={publish}>\n      <textarea name=\"content\" rows={4} cols={40} />\n      <br />\n      <button type=\"submit\" name=\"button\" value=\"submit\">Publish</button>\n      <button formAction={save}>Save draft</button>\n    </form>\n  );\n}\n\n\nShow more\nPREVIOUS\nCommon (e.g. <div>)\nNEXT\n<input>"
  },
  {
    "title": "<input> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/input",
    "html": "API REFERENCE\nCOMPONENTS\n<input>\n\nThe built-in browser <input> component lets you render different kinds of form inputs.\n\n<input />\nReference\n<input>\nUsage\nDisplaying inputs of different types\nProviding a label for an input\nProviding an initial value for an input\nReading the input values when submitting a form\nControlling an input with a state variable\nOptimizing re-rendering on every keystroke\nTroubleshooting\nMy text input doesn‚Äôt update when I type into it\nMy checkbox doesn‚Äôt update when I click on it\nMy input caret jumps to the beginning on every keystroke\nI‚Äôm getting an error: ‚ÄúA component is changing an uncontrolled input to be controlled‚Äù\nReference \n<input> \n\nTo display an input, render the built-in browser <input> component.\n\n<input name=\"myInput\" />\n\nSee more examples below.\n\nProps \n\n<input> supports all common element props.\n\nformAction: A string or function. Overrides the parent <form action> for type=\"submit\" and type=\"image\". When a URL is passed to action the form will behave like a standard HTML form. When a function is passed to formAction the function will handle the form submission. See <form action>.\n\nYou can make an input controlled by passing one of these props:\n\nchecked: A boolean. For a checkbox input or a radio button, controls whether it is selected.\nvalue: A string. For a text input, controls its text. (For a radio button, specifies its form data.)\n\nWhen you pass either of them, you must also pass an onChange handler that updates the passed value.\n\nThese <input> props are only relevant for uncontrolled inputs:\n\ndefaultChecked: A boolean. Specifies the initial value for type=\"checkbox\" and type=\"radio\" inputs.\ndefaultValue: A string. Specifies the initial value for a text input.\n\nThese <input> props are relevant both for uncontrolled and controlled inputs:\n\naccept: A string. Specifies which filetypes are accepted by a type=\"file\" input.\nalt: A string. Specifies the alternative image text for a type=\"image\" input.\ncapture: A string. Specifies the media (microphone, video, or camera) captured by a type=\"file\" input.\nautoComplete: A string. Specifies one of the possible autocomplete behaviors.\nautoFocus: A boolean. If true, React will focus the element on mount.\ndirname: A string. Specifies the form field name for the element‚Äôs directionality.\ndisabled: A boolean. If true, the input will not be interactive and will appear dimmed.\nchildren: <input> does not accept children.\nform: A string. Specifies the id of the <form> this input belongs to. If omitted, it‚Äôs the closest parent form.\nformAction: A string. Overrides the parent <form action> for type=\"submit\" and type=\"image\".\nformEnctype: A string. Overrides the parent <form enctype> for type=\"submit\" and type=\"image\".\nformMethod: A string. Overrides the parent <form method> for type=\"submit\" and type=\"image\".\nformNoValidate: A string. Overrides the parent <form noValidate> for type=\"submit\" and type=\"image\".\nformTarget: A string. Overrides the parent <form target> for type=\"submit\" and type=\"image\".\nheight: A string. Specifies the image height for type=\"image\".\nlist: A string. Specifies the id of the <datalist> with the autocomplete options.\nmax: A number. Specifies the maximum value of numerical and datetime inputs.\nmaxLength: A number. Specifies the maximum length of text and other inputs.\nmin: A number. Specifies the minimum value of numerical and datetime inputs.\nminLength: A number. Specifies the minimum length of text and other inputs.\nmultiple: A boolean. Specifies whether multiple values are allowed for <type=\"file\" and type=\"email\".\nname: A string. Specifies the name for this input that‚Äôs submitted with the form.\nonChange: An Event handler function. Required for controlled inputs. Fires immediately when the input‚Äôs value is changed by the user (for example, it fires on every keystroke). Behaves like the browser input event.\nonChangeCapture: A version of onChange that fires in the capture phase.\nonInput: An Event handler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use onChange instead which works similarly.\nonInputCapture: A version of onInput that fires in the capture phase.\nonInvalid: An Event handler function. Fires if an input fails validation on form submit. Unlike the built-in invalid event, the React onInvalid event bubbles.\nonInvalidCapture: A version of onInvalid that fires in the capture phase.\nonSelect: An Event handler function. Fires after the selection inside the <input> changes. React extends the onSelect event to also fire for empty selection and on edits (which may affect the selection).\nonSelectCapture: A version of onSelect that fires in the capture phase.\npattern: A string. Specifies the pattern that the value must match.\nplaceholder: A string. Displayed in a dimmed color when the input value is empty.\nreadOnly: A boolean. If true, the input is not editable by the user.\nrequired: A boolean. If true, the value must be provided for the form to submit.\nsize: A number. Similar to setting width, but the unit depends on the control.\nsrc: A string. Specifies the image source for a type=\"image\" input.\nstep: A positive number or an 'any' string. Specifies the distance between valid values.\ntype: A string. One of the input types.\nwidth: A string. Specifies the image width for a type=\"image\" input.\nCaveats \nCheckboxes need checked (or defaultChecked), not value (or defaultValue).\nIf a text input receives a string value prop, it will be treated as controlled.\nIf a checkbox or a radio button receives a boolean checked prop, it will be treated as controlled.\nAn input can‚Äôt be both controlled and uncontrolled at the same time.\nAn input cannot switch between being controlled or uncontrolled over its lifetime.\nEvery controlled input needs an onChange event handler that synchronously updates its backing value.\nUsage \nDisplaying inputs of different types \n\nTo display an input, render an <input> component. By default, it will be a text input. You can pass type=\"checkbox\" for a checkbox, type=\"radio\" for a radio button, or one of the other input types.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function MyForm() {\n  return (\n    <>\n      <label>\n        Text input: <input name=\"myInput\" />\n      </label>\n      <hr />\n      <label>\n        Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" />\n      </label>\n      <hr />\n      <p>\n        Radio buttons:\n        <label>\n          <input type=\"radio\" name=\"myRadio\" value=\"option1\" />\n          Option 1\n        </label>\n        <label>\n          <input type=\"radio\" name=\"myRadio\" value=\"option2\" />\n          Option 2\n        </label>\n        <label>\n          <input type=\"radio\" name=\"myRadio\" value=\"option3\" />\n          Option 3\n        </label>\n      </p>\n    </>\n  );\n}\n\n\nShow more\nProviding a label for an input \n\nTypically, you will place every <input> inside a <label> tag. This tells the browser that this label is associated with that input. When the user clicks the label, the browser will automatically focus the input. It‚Äôs also essential for accessibility: a screen reader will announce the label caption when the user focuses the associated input.\n\nIf you can‚Äôt nest <input> into a <label>, associate them by passing the same ID to <input id> and <label htmlFor>. To avoid conflicts between multiple instances of one component, generate such an ID with useId.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useId } from 'react';\n\nexport default function Form() {\n  const ageInputId = useId();\n  return (\n    <>\n      <label>\n        Your first name:\n        <input name=\"firstName\" />\n      </label>\n      <hr />\n      <label htmlFor={ageInputId}>Your age:</label>\n      <input id={ageInputId} name=\"age\" type=\"number\" />\n    </>\n  );\n}\n\n\nShow more\nProviding an initial value for an input \n\nYou can optionally specify the initial value for any input. Pass it as the defaultValue string for text inputs. Checkboxes and radio buttons should specify the initial value with the defaultChecked boolean instead.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function MyForm() {\n  return (\n    <>\n      <label>\n        Text input: <input name=\"myInput\" defaultValue=\"Some initial value\" />\n      </label>\n      <hr />\n      <label>\n        Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" defaultChecked={true} />\n      </label>\n      <hr />\n      <p>\n        Radio buttons:\n        <label>\n          <input type=\"radio\" name=\"myRadio\" value=\"option1\" />\n          Option 1\n        </label>\n        <label>\n          <input\n            type=\"radio\"\n            name=\"myRadio\"\n            value=\"option2\"\n            defaultChecked={true} \n          />\n          Option 2\n        </label>\n        <label>\n          <input type=\"radio\" name=\"myRadio\" value=\"option3\" />\n          Option 3\n        </label>\n      </p>\n    </>\n  );\n}\n\n\nShow more\nReading the input values when submitting a form \n\nAdd a <form> around your inputs with a <button type=\"submit\"> inside. It will call your <form onSubmit> event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault(). Read the form data with new FormData(e.target).\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function MyForm() {\n  function handleSubmit(e) {\n    // Prevent the browser from reloading the page\n    e.preventDefault();\n\n    // Read the form data\n    const form = e.target;\n    const formData = new FormData(form);\n\n    // You can pass formData as a fetch body directly:\n    fetch('/some-api', { method: form.method, body: formData });\n\n    // Or you can work with it as a plain object:\n    const formJson = Object.fromEntries(formData.entries());\n    console.log(formJson);\n  }\n\n  return (\n    <form method=\"post\" onSubmit={handleSubmit}>\n      <label>\n        Text input: <input name=\"myInput\" defaultValue=\"Some initial value\" />\n      </label>\n      <hr />\n      <label>\n        Checkbox: <input type=\"checkbox\" name=\"myCheckbox\" defaultChecked={true} />\n      </label>\n      <hr />\n      <p>\n        Radio buttons:\n        <label><input type=\"radio\" name=\"myRadio\" value=\"option1\" /> Option 1</label>\n        <label><input type=\"radio\" name=\"myRadio\" value=\"option2\" defaultChecked={true} /> Option 2</label>\n        <label><input type=\"radio\" name=\"myRadio\" value=\"option3\" /> Option 3</label>\n      </p>\n      <hr />\n      <button type=\"reset\">Reset form</button>\n      <button type=\"submit\">Submit form</button>\n    </form>\n  );\n}\n\n\nShow more\nNote\n\nGive a name to every <input>, for example <input name=\"firstName\" defaultValue=\"Taylor\" />. The name you specified will be used as a key in the form data, for example { firstName: \"Taylor\" }.\n\nPitfall\n\nBy default, a <button> inside a <form> without a type attribute will submit it. This can be surprising! If you have your own custom Button React component, consider using <button type=\"button\"> instead of <button> (with no type). Then, to be explicit, use <button type=\"submit\"> for buttons that are supposed to submit the form.\n\nControlling an input with a state variable \n\nAn input like <input /> is uncontrolled. Even if you pass an initial value like <input defaultValue=\"Initial text\" />, your JSX only specifies the initial value. It does not control what the value should be right now.\n\nTo render a controlled input, pass the value prop to it (or checked for checkboxes and radios). React will force the input to always have the value you passed. Usually, you would do this by declaring a state variable:\n\nfunction Form() {\n\n  const [firstName, setFirstName] = useState(''); // Declare a state variable...\n\n  // ...\n\n  return (\n\n    <input\n\n      value={firstName} // ...force the input's value to match the state variable...\n\n      onChange={e => setFirstName(e.target.value)} // ... and update the state variable on any edits!\n\n    />\n\n  );\n\n}\n\nA controlled input makes sense if you needed state anyway‚Äîfor example, to re-render your UI on every edit:\n\nfunction Form() {\n\n  const [firstName, setFirstName] = useState('');\n\n  return (\n\n    <>\n\n      <label>\n\n        First name:\n\n        <input value={firstName} onChange={e => setFirstName(e.target.value)} />\n\n      </label>\n\n      {firstName !== '' && <p>Your name is {firstName}.</p>}\n\n      ...\n\nIt‚Äôs also useful if you want to offer multiple ways to adjust the input state (for example, by clicking a button):\n\nfunction Form() {\n\n  // ...\n\n  const [age, setAge] = useState('');\n\n  const ageAsNumber = Number(age);\n\n  return (\n\n    <>\n\n      <label>\n\n        Age:\n\n        <input\n\n          value={age}\n\n          onChange={e => setAge(e.target.value)}\n\n          type=\"number\"\n\n        />\n\n        <button onClick={() => setAge(ageAsNumber + 10)}>\n\n          Add 10 years\n\n        </button>\n\nThe value you pass to controlled components should not be undefined or null. If you need the initial value to be empty (such as with the firstName field below), initialize your state variable to an empty string ('').\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function Form() {\n  const [firstName, setFirstName] = useState('');\n  const [age, setAge] = useState('20');\n  const ageAsNumber = Number(age);\n  return (\n    <>\n      <label>\n        First name:\n        <input\n          value={firstName}\n          onChange={e => setFirstName(e.target.value)}\n        />\n      </label>\n      <label>\n        Age:\n        <input\n          value={age}\n          onChange={e => setAge(e.target.value)}\n          type=\"number\"\n        />\n        <button onClick={() => setAge(ageAsNumber + 10)}>\n          Add 10 years\n        </button>\n      </label>\n      {firstName !== '' &&\n        <p>Your name is {firstName}.</p>\n      }\n      {ageAsNumber > 0 &&\n        <p>Your age is {ageAsNumber}.</p>\n      }\n    </>\n  );\n}\n\n\nShow more\nPitfall\n\nIf you pass value without onChange, it will be impossible to type into the input. When you control an input by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the input after every keystroke back to the value that you specified.\n\nOptimizing re-rendering on every keystroke \n\nWhen you use a controlled input, you set the state on every keystroke. If the component containing your state re-renders a large tree, this can get slow. There‚Äôs a few ways you can optimize re-rendering performance.\n\nFor example, suppose you start with a form that re-renders all page content on every keystroke:\n\nfunction App() {\n\n  const [firstName, setFirstName] = useState('');\n\n  return (\n\n    <>\n\n      <form>\n\n        <input value={firstName} onChange={e => setFirstName(e.target.value)} />\n\n      </form>\n\n      <PageContent />\n\n    </>\n\n  );\n\n}\n\nSince <PageContent /> doesn‚Äôt rely on the input state, you can move the input state into its own component:\n\nfunction App() {\n\n  return (\n\n    <>\n\n      <SignupForm />\n\n      <PageContent />\n\n    </>\n\n  );\n\n}\n\n\n\nfunction SignupForm() {\n\n  const [firstName, setFirstName] = useState('');\n\n  return (\n\n    <form>\n\n      <input value={firstName} onChange={e => setFirstName(e.target.value)} />\n\n    </form>\n\n  );\n\n}\n\nThis significantly improves performance because now only SignupForm re-renders on every keystroke.\n\nIf there is no way to avoid re-rendering (for example, if PageContent depends on the search input‚Äôs value), useDeferredValue lets you keep the controlled input responsive even in the middle of a large re-render.\n\nTroubleshooting \nMy text input doesn‚Äôt update when I type into it \n\nIf you render an input with value but no onChange, you will see an error in the console:\n\n// üî¥ Bug: controlled text input with no onChange handler\n\n<input value={something} />\nConsole\nYou provided a value prop to a form field without an onChange handler. This will render a read-only field. If the field should be mutable use defaultValue. Otherwise, set either onChange or readOnly.\n\nAs the error message suggests, if you only wanted to specify the initial value, pass defaultValue instead:\n\n// ‚úÖ Good: uncontrolled input with an initial value\n\n<input defaultValue={something} />\n\nIf you want to control this input with a state variable, specify an onChange handler:\n\n// ‚úÖ Good: controlled input with onChange\n\n<input value={something} onChange={e => setSomething(e.target.value)} />\n\nIf the value is intentionally read-only, add a readOnly prop to suppress the error:\n\n// ‚úÖ Good: readonly controlled input without on change\n\n<input value={something} readOnly={true} />\nMy checkbox doesn‚Äôt update when I click on it \n\nIf you render a checkbox with checked but no onChange, you will see an error in the console:\n\n// üî¥ Bug: controlled checkbox with no onChange handler\n\n<input type=\"checkbox\" checked={something} />\nConsole\nYou provided a checked prop to a form field without an onChange handler. This will render a read-only field. If the field should be mutable use defaultChecked. Otherwise, set either onChange or readOnly.\n\nAs the error message suggests, if you only wanted to specify the initial value, pass defaultChecked instead:\n\n// ‚úÖ Good: uncontrolled checkbox with an initial value\n\n<input type=\"checkbox\" defaultChecked={something} />\n\nIf you want to control this checkbox with a state variable, specify an onChange handler:\n\n// ‚úÖ Good: controlled checkbox with onChange\n\n<input type=\"checkbox\" checked={something} onChange={e => setSomething(e.target.checked)} />\nPitfall\n\nYou need to read e.target.checked rather than e.target.value for checkboxes.\n\nIf the checkbox is intentionally read-only, add a readOnly prop to suppress the error:\n\n// ‚úÖ Good: readonly controlled input without on change\n\n<input type=\"checkbox\" checked={something} readOnly={true} />\nMy input caret jumps to the beginning on every keystroke \n\nIf you control an input, you must update its state variable to the input‚Äôs value from the DOM during onChange.\n\nYou can‚Äôt update it to something other than e.target.value (or e.target.checked for checkboxes):\n\nfunction handleChange(e) {\n\n  // üî¥ Bug: updating an input to something other than e.target.value\n\n  setFirstName(e.target.value.toUpperCase());\n\n}\n\nYou also can‚Äôt update it asynchronously:\n\nfunction handleChange(e) {\n\n  // üî¥ Bug: updating an input asynchronously\n\n  setTimeout(() => {\n\n    setFirstName(e.target.value);\n\n  }, 100);\n\n}\n\nTo fix your code, update it synchronously to e.target.value:\n\nfunction handleChange(e) {\n\n  // ‚úÖ Updating a controlled input to e.target.value synchronously\n\n  setFirstName(e.target.value);\n\n}\n\nIf this doesn‚Äôt fix the problem, it‚Äôs possible that the input gets removed and re-added from the DOM on every keystroke. This can happen if you‚Äôre accidentally resetting state on every re-render, for example if the input or one of its parents always receives a different key attribute, or if you nest component function definitions (which is not supported and causes the ‚Äúinner‚Äù component to always be considered a different tree).\n\nI‚Äôm getting an error: ‚ÄúA component is changing an uncontrolled input to be controlled‚Äù \n\nIf you provide a value to the component, it must remain a string throughout its lifetime.\n\nYou cannot pass value={undefined} first and later pass value=\"some string\" because React won‚Äôt know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string value, not null or undefined.\n\nIf your value is coming from an API or a state variable, it might be initialized to null or undefined. In that case, either set it to an empty string ('') initially, or pass value={someValue ?? ''} to ensure value is a string.\n\nSimilarly, if you pass checked to a checkbox, ensure it‚Äôs always a boolean.\n\nPREVIOUS\n<form>\nNEXT\n<option>"
  },
  {
    "title": "<option> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/option",
    "html": "API REFERENCE\nCOMPONENTS\n<option>\n\nThe built-in browser <option> component lets you render an option inside a <select> box.\n\n<select>\n\n  <option value=\"someOption\">Some option</option>\n\n  <option value=\"otherOption\">Other option</option>\n\n</select>\nReference\n<option>\nUsage\nDisplaying a select box with options\nReference \n<option> \n\nThe built-in browser <option> component lets you render an option inside a <select> box.\n\n<select>\n\n  <option value=\"someOption\">Some option</option>\n\n  <option value=\"otherOption\">Other option</option>\n\n</select>\n\nSee more examples below.\n\nProps \n\n<option> supports all common element props.\n\nAdditionally, <option> supports these props:\n\ndisabled: A boolean. If true, the option will not be selectable and will appear dimmed.\nlabel: A string. Specifies the meaning of the option. If not specified, the text inside the option is used.\nvalue: The value to be used when submitting the parent <select> in a form if this option is selected.\nCaveats \nReact does not support the selected attribute on <option>. Instead, pass this option‚Äôs value to the parent <select defaultValue> for an uncontrolled select box, or <select value> for a controlled select.\nUsage \nDisplaying a select box with options \n\nRender a <select> with a list of <option> components inside to display a select box. Give each <option> a value representing the data to be submitted with the form.\n\nRead more about displaying a <select> with a list of <option> components.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function FruitPicker() {\n  return (\n    <label>\n      Pick a fruit:\n      <select name=\"selectedFruit\">\n        <option value=\"apple\">Apple</option>\n        <option value=\"banana\">Banana</option>\n        <option value=\"orange\">Orange</option>\n      </select>\n    </label>\n  );\n}\n\n\nPREVIOUS\n<input>\nNEXT\n<progress>"
  },
  {
    "title": "<progress> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/progress",
    "html": "API REFERENCE\nCOMPONENTS\n<progress>\n\nThe built-in browser <progress> component lets you render a progress indicator.\n\n<progress value={0.5} />\nReference\n<progress>\nUsage\nControlling a progress indicator\nReference \n<progress> \n\nTo display a progress indicator, render the built-in browser <progress> component.\n\n<progress value={0.5} />\n\nSee more examples below.\n\nProps \n\n<progress> supports all common element props.\n\nAdditionally, <progress> supports these props:\n\nmax: A number. Specifies the maximum value. Defaults to 1.\nvalue: A number between 0 and max, or null for indeterminate progress. Specifies how much was done.\nUsage \nControlling a progress indicator \n\nTo display a progress indicator, render a <progress> component. You can pass a number value between 0 and the max value you specify. If you don‚Äôt pass a max value, it will assumed to be 1 by default.\n\nIf the operation is not ongoing, pass value={null} to put the progress indicator into an indeterminate state.\n\nApp.js\nDownload\nReload\nClear\nFork\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nexport default function App() {\n  return (\n    <>\n      <progress value={0} />\n      <progress value={0.5} />\n      <progress value={0.7} />\n      <progress value={75} max={100} />\n      <progress value={1} />\n      <progress value={null} />\n    </>\n  );\n}\n\n\nPREVIOUS\n<option>\nNEXT\n<select>"
  },
  {
    "title": "<select> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/select",
    "html": "API REFERENCE\nCOMPONENTS\n<select>\n\nThe built-in browser <select> component lets you render a select box with options.\n\n<select>\n\n  <option value=\"someOption\">Some option</option>\n\n  <option value=\"otherOption\">Other option</option>\n\n</select>\nReference\n<select>\nUsage\nDisplaying a select box with options\nProviding a label for a select box\nProviding an initially selected option\nEnabling multiple selection\nReading the select box value when submitting a form\nControlling a select box with a state variable\nReference \n<select> \n\nTo display a select box, render the built-in browser <select> component.\n\n<select>\n\n  <option value=\"someOption\">Some option</option>\n\n  <option value=\"otherOption\">Other option</option>\n\n</select>\n\nSee more examples below.\n\nProps \n\n<select> supports all common element props.\n\nYou can make a select box controlled by passing a value prop:\n\nvalue: A string (or an array of strings for multiple={true}). Controls which option is selected. Every value string match the value of some <option> nested inside the <select>.\n\nWhen you pass value, you must also pass an onChange handler that updates the passed value.\n\nIf your <select> is uncontrolled, you may pass the defaultValue prop instead:\n\ndefaultValue: A string (or an array of strings for multiple={true}). Specifies the initially selected option.\n\nThese <select> props are relevant both for uncontrolled and controlled select boxes:\n\nautoComplete: A string. Specifies one of the possible autocomplete behaviors.\nautoFocus: A boolean. If true, React will focus the element on mount.\nchildren: <select> accepts <option>, <optgroup>, and <datalist> components as children. You can also pass your own components as long as they eventually render one of the allowed components. If you pass your own components that eventually render <option> tags, each <option> you render must have a value.\ndisabled: A boolean. If true, the select box will not be interactive and will appear dimmed.\nform: A string. Specifies the id of the <form> this select box belongs to. If omitted, it‚Äôs the closest parent form.\nmultiple: A boolean. If true, the browser allows multiple selection.\nname: A string. Specifies the name for this select box that‚Äôs submitted with the form.\nonChange: An Event handler function. Required for controlled select boxes. Fires immediately when the user picks a different option. Behaves like the browser input event.\nonChangeCapture: A version of onChange that fires in the capture phase.\nonInput: An Event handler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use onChange instead which works similarly.\nonInputCapture: A version of onInput that fires in the capture phase.\nonInvalid: An Event handler function. Fires if an input fails validation on form submit. Unlike the built-in invalid event, the React onInvalid event bubbles.\nonInvalidCapture: A version of onInvalid that fires in the capture phase.\nrequired: A boolean. If true, the value must be provided for the form to submit.\nsize: A number. For multiple={true} selects, specifies the preferred number of initially visible items.\nCaveats \nUnlike in HTML, passing a selected attribute to <option> is not supported. Instead, use <select defaultValue> for uncontrolled select boxes and <select value> for controlled select boxes.\nIf a select box receives a value prop, it will be treated as controlled.\nA select box can‚Äôt be both controlled and uncontrolled at the same time.\nA select box cannot switch between being controlled or uncontrolled over its lifetime.\nEvery controlled select box needs an onChange event handler that synchronously updates its backing value.\nUsage \nDisplaying a select box with options \n\nRender a <select> with a list of <option> components inside to display a select box. Give each <option> a value representing the data to be submitted with the form.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function FruitPicker() {\n  return (\n    <label>\n      Pick a fruit:\n      <select name=\"selectedFruit\">\n        <option value=\"apple\">Apple</option>\n        <option value=\"banana\">Banana</option>\n        <option value=\"orange\">Orange</option>\n      </select>\n    </label>\n  );\n}\n\n\nProviding a label for a select box \n\nTypically, you will place every <select> inside a <label> tag. This tells the browser that this label is associated with that select box. When the user clicks the label, the browser will automatically focus the select box. It‚Äôs also essential for accessibility: a screen reader will announce the label caption when the user focuses the select box.\n\nIf you can‚Äôt nest <select> into a <label>, associate them by passing the same ID to <select id> and <label htmlFor>. To avoid conflicts between multiple instances of one component, generate such an ID with useId.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useId } from 'react';\n\nexport default function Form() {\n  const vegetableSelectId = useId();\n  return (\n    <>\n      <label>\n        Pick a fruit:\n        <select name=\"selectedFruit\">\n          <option value=\"apple\">Apple</option>\n          <option value=\"banana\">Banana</option>\n          <option value=\"orange\">Orange</option>\n        </select>\n      </label>\n      <hr />\n      <label htmlFor={vegetableSelectId}>\n        Pick a vegetable:\n      </label>\n      <select id={vegetableSelectId} name=\"selectedVegetable\">\n        <option value=\"cucumber\">Cucumber</option>\n        <option value=\"corn\">Corn</option>\n        <option value=\"tomato\">Tomato</option>\n      </select>\n    </>\n  );\n}\n\n\nShow more\nProviding an initially selected option \n\nBy default, the browser will select the first <option> in the list. To select a different option by default, pass that <option>‚Äôs value as the defaultValue to the <select> element.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function FruitPicker() {\n  return (\n    <label>\n      Pick a fruit:\n      <select name=\"selectedFruit\" defaultValue=\"orange\">\n        <option value=\"apple\">Apple</option>\n        <option value=\"banana\">Banana</option>\n        <option value=\"orange\">Orange</option>\n      </select>\n    </label>\n  );\n}\n\n\nPitfall\n\nUnlike in HTML, passing a selected attribute to an individual <option> is not supported.\n\nEnabling multiple selection \n\nPass multiple={true} to the <select> to let the user select multiple options. In that case, if you also specify defaultValue to choose the initially selected options, it must be an array.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function FruitPicker() {\n  return (\n    <label>\n      Pick some fruits:\n      <select\n        name=\"selectedFruit\"\n        defaultValue={['orange', 'banana']}\n        multiple={true}\n      >\n        <option value=\"apple\">Apple</option>\n        <option value=\"banana\">Banana</option>\n        <option value=\"orange\">Orange</option>\n      </select>\n    </label>\n  );\n}\n\n\nShow more\nReading the select box value when submitting a form \n\nAdd a <form> around your select box with a <button type=\"submit\"> inside. It will call your <form onSubmit> event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault(). Read the form data with new FormData(e.target).\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function EditPost() {\n  function handleSubmit(e) {\n    // Prevent the browser from reloading the page\n    e.preventDefault();\n    // Read the form data\n    const form = e.target;\n    const formData = new FormData(form);\n    // You can pass formData as a fetch body directly:\n    fetch('/some-api', { method: form.method, body: formData });\n    // You can generate a URL out of it, as the browser does by default:\n    console.log(new URLSearchParams(formData).toString());\n    // You can work with it as a plain object.\n    const formJson = Object.fromEntries(formData.entries());\n    console.log(formJson); // (!) This doesn't include multiple select values\n    // Or you can get an array of name-value pairs.\n    console.log([...formData.entries()]);\n  }\n\n  return (\n    <form method=\"post\" onSubmit={handleSubmit}>\n      <label>\n        Pick your favorite fruit:\n        <select name=\"selectedFruit\" defaultValue=\"orange\">\n          <option value=\"apple\">Apple</option>\n          <option value=\"banana\">Banana</option>\n          <option value=\"orange\">Orange</option>\n        </select>\n      </label>\n      <label>\n        Pick all your favorite vegetables:\n        <select\n          name=\"selectedVegetables\"\n          multiple={true}\n          defaultValue={['corn', 'tomato']}\n        >\n          <option value=\"cucumber\">Cucumber</option>\n          <option value=\"corn\">Corn</option>\n          <option value=\"tomato\">Tomato</option>\n        </select>\n      </label>\n      <hr />\n      <button type=\"reset\">Reset</button>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n\n\nShow more\nNote\n\nGive a name to your <select>, for example <select name=\"selectedFruit\" />. The name you specified will be used as a key in the form data, for example { selectedFruit: \"orange\" }.\n\nIf you use <select multiple={true}>, the FormData you‚Äôll read from the form will include each selected value as a separate name-value pair. Look closely at the console logs in the example above.\n\nPitfall\n\nBy default, any <button> inside a <form> will submit it. This can be surprising! If you have your own custom Button React component, consider returning <button type=\"button\"> instead of <button>. Then, to be explicit, use <button type=\"submit\"> for buttons that are supposed to submit the form.\n\nControlling a select box with a state variable \n\nA select box like <select /> is uncontrolled. Even if you pass an initially selected value like <select defaultValue=\"orange\" />, your JSX only specifies the initial value, not the value right now.\n\nTo render a controlled select box, pass the value prop to it. React will force the select box to always have the value you passed. Typically, you will control a select box by declaring a state variable:\n\nfunction FruitPicker() {\n\n  const [selectedFruit, setSelectedFruit] = useState('orange'); // Declare a state variable...\n\n  // ...\n\n  return (\n\n    <select\n\n      value={selectedFruit} // ...force the select's value to match the state variable...\n\n      onChange={e => setSelectedFruit(e.target.value)} // ... and update the state variable on any change!\n\n    >\n\n      <option value=\"apple\">Apple</option>\n\n      <option value=\"banana\">Banana</option>\n\n      <option value=\"orange\">Orange</option>\n\n    </select>\n\n  );\n\n}\n\nThis is useful if you want to re-render some part of the UI in response to every selection.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState } from 'react';\n\nexport default function FruitPicker() {\n  const [selectedFruit, setSelectedFruit] = useState('orange');\n  const [selectedVegs, setSelectedVegs] = useState(['corn', 'tomato']);\n  return (\n    <>\n      <label>\n        Pick a fruit:\n        <select\n          value={selectedFruit}\n          onChange={e => setSelectedFruit(e.target.value)}\n        >\n          <option value=\"apple\">Apple</option>\n          <option value=\"banana\">Banana</option>\n          <option value=\"orange\">Orange</option>\n        </select>\n      </label>\n      <hr />\n      <label>\n        Pick all your favorite vegetables:\n        <select\n          multiple={true}\n          value={selectedVegs}\n          onChange={e => {\n            const options = [...e.target.selectedOptions];\n            const values = options.map(option => option.value);\n            setSelectedVegs(values);\n          }}\n        >\n          <option value=\"cucumber\">Cucumber</option>\n          <option value=\"corn\">Corn</option>\n          <option value=\"tomato\">Tomato</option>\n        </select>\n      </label>\n      <hr />\n      <p>Your favorite fruit: {selectedFruit}</p>\n      <p>Your favorite vegetables: {selectedVegs.join(', ')}</p>\n    </>\n  );\n}\n\n\nShow more\nPitfall\n\nIf you pass value without onChange, it will be impossible to select an option. When you control a select box by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the select box after every keystroke back to the value that you specified.\n\nUnlike in HTML, passing a selected attribute to an individual <option> is not supported.\n\nPREVIOUS\n<progress>\nNEXT\n<textarea>"
  },
  {
    "title": "<textarea> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/textarea",
    "html": "API REFERENCE\nCOMPONENTS\n<textarea>\n\nThe built-in browser <textarea> component lets you render a multiline text input.\n\n<textarea />\nReference\n<textarea>\nUsage\nDisplaying a text area\nProviding a label for a text area\nProviding an initial value for a text area\nReading the text area value when submitting a form\nControlling a text area with a state variable\nTroubleshooting\nMy text area doesn‚Äôt update when I type into it\nMy text area caret jumps to the beginning on every keystroke\nI‚Äôm getting an error: ‚ÄúA component is changing an uncontrolled input to be controlled‚Äù\nReference \n<textarea> \n\nTo display a text area, render the built-in browser <textarea> component.\n\n<textarea name=\"postContent\" />\n\nSee more examples below.\n\nProps \n\n<textarea> supports all common element props.\n\nYou can make a text area controlled by passing a value prop:\n\nvalue: A string. Controls the text inside the text area.\n\nWhen you pass value, you must also pass an onChange handler that updates the passed value.\n\nIf your <textarea> is uncontrolled, you may pass the defaultValue prop instead:\n\ndefaultValue: A string. Specifies the initial value for a text area.\n\nThese <textarea> props are relevant both for uncontrolled and controlled text areas:\n\nautoComplete: Either 'on' or 'off'. Specifies the autocomplete behavior.\nautoFocus: A boolean. If true, React will focus the element on mount.\nchildren: <textarea> does not accept children. To set the initial value, use defaultValue.\ncols: A number. Specifies the default width in average character widths. Defaults to 20.\ndisabled: A boolean. If true, the input will not be interactive and will appear dimmed.\nform: A string. Specifies the id of the <form> this input belongs to. If omitted, it‚Äôs the closest parent form.\nmaxLength: A number. Specifies the maximum length of text.\nminLength: A number. Specifies the minimum length of text.\nname: A string. Specifies the name for this input that‚Äôs submitted with the form.\nonChange: An Event handler function. Required for controlled text areas. Fires immediately when the input‚Äôs value is changed by the user (for example, it fires on every keystroke). Behaves like the browser input event.\nonChangeCapture: A version of onChange that fires in the capture phase.\nonInput: An Event handler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use onChange instead which works similarly.\nonInputCapture: A version of onInput that fires in the capture phase.\nonInvalid: An Event handler function. Fires if an input fails validation on form submit. Unlike the built-in invalid event, the React onInvalid event bubbles.\nonInvalidCapture: A version of onInvalid that fires in the capture phase.\nonSelect: An Event handler function. Fires after the selection inside the <textarea> changes. React extends the onSelect event to also fire for empty selection and on edits (which may affect the selection).\nonSelectCapture: A version of onSelect that fires in the capture phase.\nplaceholder: A string. Displayed in a dimmed color when the text area value is empty.\nreadOnly: A boolean. If true, the text area is not editable by the user.\nrequired: A boolean. If true, the value must be provided for the form to submit.\nrows: A number. Specifies the default height in average character heights. Defaults to 2.\nwrap: Either 'hard', 'soft', or 'off'. Specifies how the text should be wrapped when submitting a form.\nCaveats \nPassing children like <textarea>something</textarea> is not allowed. Use defaultValue for initial content.\nIf a text area receives a string value prop, it will be treated as controlled.\nA text area can‚Äôt be both controlled and uncontrolled at the same time.\nA text area cannot switch between being controlled or uncontrolled over its lifetime.\nEvery controlled text area needs an onChange event handler that synchronously updates its backing value.\nUsage \nDisplaying a text area \n\nRender <textarea> to display a text area. You can specify its default size with the rows and cols attributes, but by default the user will be able to resize it. To disable resizing, you can specify resize: none in the CSS.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function NewPost() {\n  return (\n    <label>\n      Write your post:\n      <textarea name=\"postContent\" rows={4} cols={40} />\n    </label>\n  );\n}\n\n\nProviding a label for a text area \n\nTypically, you will place every <textarea> inside a <label> tag. This tells the browser that this label is associated with that text area. When the user clicks the label, the browser will focus the text area. It‚Äôs also essential for accessibility: a screen reader will announce the label caption when the user focuses the text area.\n\nIf you can‚Äôt nest <textarea> into a <label>, associate them by passing the same ID to <textarea id> and <label htmlFor>. To avoid conflicts between instances of one component, generate such an ID with useId.\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useId } from 'react';\n\nexport default function Form() {\n  const postTextAreaId = useId();\n  return (\n    <>\n      <label htmlFor={postTextAreaId}>\n        Write your post:\n      </label>\n      <textarea\n        id={postTextAreaId}\n        name=\"postContent\"\n        rows={4}\n        cols={40}\n      />\n    </>\n  );\n}\n\n\nShow more\nProviding an initial value for a text area \n\nYou can optionally specify the initial value for the text area. Pass it as the defaultValue string.\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function EditPost() {\n  return (\n    <label>\n      Edit your post:\n      <textarea\n        name=\"postContent\"\n        defaultValue=\"I really enjoyed biking yesterday!\"\n        rows={4}\n        cols={40}\n      />\n    </label>\n  );\n}\n\n\nPitfall\n\nUnlike in HTML, passing initial text like <textarea>Some content</textarea> is not supported.\n\nReading the text area value when submitting a form \n\nAdd a <form> around your textarea with a <button type=\"submit\"> inside. It will call your <form onSubmit> event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling e.preventDefault(). Read the form data with new FormData(e.target).\n\nApp.js\nDownload\nReload\nClear\nFork\nexport default function EditPost() {\n  function handleSubmit(e) {\n    // Prevent the browser from reloading the page\n    e.preventDefault();\n\n    // Read the form data\n    const form = e.target;\n    const formData = new FormData(form);\n\n    // You can pass formData as a fetch body directly:\n    fetch('/some-api', { method: form.method, body: formData });\n\n    // Or you can work with it as a plain object:\n    const formJson = Object.fromEntries(formData.entries());\n    console.log(formJson);\n  }\n\n  return (\n    <form method=\"post\" onSubmit={handleSubmit}>\n      <label>\n        Post title: <input name=\"postTitle\" defaultValue=\"Biking\" />\n      </label>\n      <label>\n        Edit your post:\n        <textarea\n          name=\"postContent\"\n          defaultValue=\"I really enjoyed biking yesterday!\"\n          rows={4}\n          cols={40}\n        />\n      </label>\n      <hr />\n      <button type=\"reset\">Reset edits</button>\n      <button type=\"submit\">Save post</button>\n    </form>\n  );\n}\n\n\nShow more\nNote\n\nGive a name to your <textarea>, for example <textarea name=\"postContent\" />. The name you specified will be used as a key in the form data, for example { postContent: \"Your post\" }.\n\nPitfall\n\nBy default, any <button> inside a <form> will submit it. This can be surprising! If you have your own custom Button React component, consider returning <button type=\"button\"> instead of <button>. Then, to be explicit, use <button type=\"submit\"> for buttons that are supposed to submit the form.\n\nControlling a text area with a state variable \n\nA text area like <textarea /> is uncontrolled. Even if you pass an initial value like <textarea defaultValue=\"Initial text\" />, your JSX only specifies the initial value, not the value right now.\n\nTo render a controlled text area, pass the value prop to it. React will force the text area to always have the value you passed. Typically, you will control a text area by declaring a state variable:\n\nfunction NewPost() {\n\n  const [postContent, setPostContent] = useState(''); // Declare a state variable...\n\n  // ...\n\n  return (\n\n    <textarea\n\n      value={postContent} // ...force the input's value to match the state variable...\n\n      onChange={e => setPostContent(e.target.value)} // ... and update the state variable on any edits!\n\n    />\n\n  );\n\n}\n\nThis is useful if you want to re-render some part of the UI in response to every keystroke.\n\npackage.json\nApp.js\nMarkdownPreview.js\nReload\nClear\nFork\n{\n  \"dependencies\": {\n    \"react\": \"latest\",\n    \"react-dom\": \"latest\",\n    \"react-scripts\": \"latest\",\n    \"remarkable\": \"2.0.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test --env=jsdom\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"devDependencies\": {}\n}\nPitfall\n\nIf you pass value without onChange, it will be impossible to type into the text area. When you control a text area by passing some value to it, you force it to always have the value you passed. So if you pass a state variable as a value but forget to update that state variable synchronously during the onChange event handler, React will revert the text area after every keystroke back to the value that you specified.\n\nTroubleshooting \nMy text area doesn‚Äôt update when I type into it \n\nIf you render a text area with value but no onChange, you will see an error in the console:\n\n// üî¥ Bug: controlled text area with no onChange handler\n\n<textarea value={something} />\nConsole\nYou provided a value prop to a form field without an onChange handler. This will render a read-only field. If the field should be mutable use defaultValue. Otherwise, set either onChange or readOnly.\n\nAs the error message suggests, if you only wanted to specify the initial value, pass defaultValue instead:\n\n// ‚úÖ Good: uncontrolled text area with an initial value\n\n<textarea defaultValue={something} />\n\nIf you want to control this text area with a state variable, specify an onChange handler:\n\n// ‚úÖ Good: controlled text area with onChange\n\n<textarea value={something} onChange={e => setSomething(e.target.value)} />\n\nIf the value is intentionally read-only, add a readOnly prop to suppress the error:\n\n// ‚úÖ Good: readonly controlled text area without on change\n\n<textarea value={something} readOnly={true} />\nMy text area caret jumps to the beginning on every keystroke \n\nIf you control a text area, you must update its state variable to the text area‚Äôs value from the DOM during onChange.\n\nYou can‚Äôt update it to something other than e.target.value:\n\nfunction handleChange(e) {\n\n  // üî¥ Bug: updating an input to something other than e.target.value\n\n  setFirstName(e.target.value.toUpperCase());\n\n}\n\nYou also can‚Äôt update it asynchronously:\n\nfunction handleChange(e) {\n\n  // üî¥ Bug: updating an input asynchronously\n\n  setTimeout(() => {\n\n    setFirstName(e.target.value);\n\n  }, 100);\n\n}\n\nTo fix your code, update it synchronously to e.target.value:\n\nfunction handleChange(e) {\n\n  // ‚úÖ Updating a controlled input to e.target.value synchronously\n\n  setFirstName(e.target.value);\n\n}\n\nIf this doesn‚Äôt fix the problem, it‚Äôs possible that the text area gets removed and re-added from the DOM on every keystroke. This can happen if you‚Äôre accidentally resetting state on every re-render. For example, this can happen if the text area or one of its parents always receives a different key attribute, or if you nest component definitions (which is not allowed in React and causes the ‚Äúinner‚Äù component to remount on every render).\n\nI‚Äôm getting an error: ‚ÄúA component is changing an uncontrolled input to be controlled‚Äù \n\nIf you provide a value to the component, it must remain a string throughout its lifetime.\n\nYou cannot pass value={undefined} first and later pass value=\"some string\" because React won‚Äôt know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string value, not null or undefined.\n\nIf your value is coming from an API or a state variable, it might be initialized to null or undefined. In that case, either set it to an empty string ('') initially, or pass value={someValue ?? ''} to ensure value is a string.\n\nPREVIOUS\n<select>\nNEXT\n<link>"
  },
  {
    "title": "<link> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/link",
    "html": "API REFERENCE\nCOMPONENTS\n<link>\n\nThe built-in browser <link> component lets you use external resources such as stylesheets or annotate the document with link metadata.\n\n<link rel=\"icon\" href=\"favicon.ico\" />\nReference\n<link>\nUsage\nLinking to related resources\nLinking to a stylesheet\nControlling stylesheet precedence\nDeduplicated stylesheet rendering\nAnnotating specific items within the document with links\nReference \n<link> \n\nTo link to external resources such as stylesheets, fonts, and icons, or to annotate the document with link metadata, render the built-in browser <link> component. You can render <link> from any component and React will in most cases place the corresponding DOM element in the document head.\n\n<link rel=\"icon\" href=\"favicon.ico\" />\n\nSee more examples below.\n\nProps \n\n<link> supports all common element props.\n\nrel: a string, required. Specifies the relationship to the resource. React treats links with rel=\"stylesheet\" differently from other links.\n\nThese props apply when rel=\"stylesheet\":\n\nprecedence: a string. Tells React where to rank the <link> DOM node relative to others in the document <head>, which determines which stylesheet can override the other. React will infer that precedence values it discovers first are ‚Äúlower‚Äù and precedence values it discovers later are ‚Äúhigher‚Äù. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are <link> or inline <style> tags or loaded using preinit functions.\nmedia: a string. Restricts the stylesheet to a certain media query.\ntitle: a string. Specifies the name of an alternative stylesheet.\n\nThese props apply when rel=\"stylesheet\" but disable React‚Äôs special treatment of stylesheets:\n\ndisabled: a boolean. Disables the stylesheet.\nonError: a function. Called when the stylesheet fails to load.\nonLoad: a function. Called when the stylesheet finishes being loaded.\n\nThese props apply when rel=\"preload\" or rel=\"modulepreload\":\n\nas: a string. The type of resource. Its possible values are audio, document, embed, fetch, font, image, object, script, style, track, video, worker.\nimageSrcSet: a string. Applicable only when as=\"image\". Specifies the source set of the image.\nimageSizes: a string. Applicable only when as=\"image\". Specifies the sizes of the image.\n\nThese props apply when rel=\"icon\" or rel=\"apple-touch-icon\":\n\nsizes: a string. The sizes of the icon.\n\nThese props apply in all cases:\n\nhref: a string. The URL of the linked resource.\ncrossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials. It is required when as is set to \"fetch\".\nreferrerPolicy: a string. The Referrer header to send when fetching. Its possible values are no-referrer-when-downgrade (the default), no-referrer, origin, origin-when-cross-origin, and unsafe-url.\nfetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values are auto (the default), high, and low.\nhrefLang: a string. The language of the linked resource.\nintegrity: a string. A cryptographic hash of the resource, to verify its authenticity.\ntype: a string. The MIME type of the linked resource.\n\nProps that are not recommended for use with React:\n\nblocking: a string. If set to \"render\", instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense.\nSpecial rendering behavior \n\nReact will always place the DOM element corresponding to the <link> component within the document‚Äôs <head>, regardless of where in the React tree it is rendered. The <head> is the only valid place for <link> to exist within the DOM, yet it‚Äôs convenient and keeps things composable if a component representing a specific page can render <link> components itself.\n\nThere are a few exceptions to this:\n\nIf the <link> has a rel=\"stylesheet\" prop, then it has to also have a precedence prop to get this special behavior. This is because the order of stylesheets within the document is significant, so React needs to know how to order this stylesheet relative to others, which you specify using the precedence prop. If the precedence prop is omitted, there is no special behavior.\nIf the <link> has an itemProp prop, there is no special behavior, because in this case it doesn‚Äôt apply to the document but instead represents metadata about a specific part of the page.\nIf the <link> has an onLoad or onError prop, because in that case you are managing the loading of the linked resource manually within your React component.\nSpecial behavior for stylesheets \n\nIn addition, if the <link> is to a stylesheet (namely, it has rel=\"stylesheet\" in its props), React treats it specially in the following ways:\n\nThe component that renders <link> will suspend while the stylesheet is loading.\nIf multiple components render links to the same stylesheet, React will de-duplicate them and only put a single link into the DOM. Two links are considered the same if they have the same href prop.\n\nThere are two exception to this special behavior:\n\nIf the link doesn‚Äôt have a precedence prop, there is no special behavior, because the order of stylesheets within the document is significant, so React needs to know how to order this stylesheet relative to others, which you specify using the precedence prop.\nIf you supply any of the onLoad, onError, or disabled props, there is no special behavior, because these props indicate that you are managing the loading of the stylesheet manually within your component.\n\nThis special treatment comes with two caveats:\n\nReact will ignore changes to props after the link has been rendered. (React will issue a warning in development if this happens.)\nReact may leave the link in the DOM even after the component that rendered it has been unmounted.\nUsage \nLinking to related resources \n\nYou can annotate the document with links to related resources such as an icon, canonical URL, or pingback. React will place this metadata within the document <head> regardless of where in the React tree it is rendered.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\n\nexport default function BlogPage() {\n  return (\n    <ShowRenderedHTML>\n      <link rel=\"icon\" href=\"favicon.ico\" />\n      <link rel=\"pingback\" href=\"http://www.example.com/xmlrpc.php\" />\n      <h1>My Blog</h1>\n      <p>...</p>\n    </ShowRenderedHTML>\n  );\n}\n\n\nLinking to a stylesheet \n\nIf a component depends on a certain stylesheet in order to be displayed correctly, you can render a link to that stylesheet within the component. Your component will suspend while the stylesheet is loading. You must supply the precedence prop, which tells React where to place this stylesheet relative to others ‚Äî stylesheets with higher precedence can override those with lower precedence.\n\nNote\n\nWhen you want to use a stylesheet, it can be beneficial to call the preinit function. Calling this function may allow the browser to start fetching the stylesheet earlier than if you just render a <link> component, for example by sending an HTTP Early Hints response.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\n\nexport default function SiteMapPage() {\n  return (\n    <ShowRenderedHTML>\n      <link rel=\"stylesheet\" href=\"sitemap.css\" precedence=\"medium\" />\n      <p>...</p>\n    </ShowRenderedHTML>\n  );\n}\n\n\nControlling stylesheet precedence \n\nStylesheets can conflict with each other, and when they do, the browser goes with the one that comes later in the document. React lets you control the order of stylesheets with the precedence prop. In this example, three components render stylesheets, and the ones with the same precedence are grouped together in the <head>.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\n\nexport default function HomePage() {\n  return (\n    <ShowRenderedHTML>\n      <FirstComponent />\n      <SecondComponent />\n      <ThirdComponent/>\n      ...\n    </ShowRenderedHTML>\n  );\n}\n\nfunction FirstComponent() {\n  return <link rel=\"stylesheet\" href=\"first.css\" precedence=\"first\" />;\n}\n\nfunction SecondComponent() {\n  return <link rel=\"stylesheet\" href=\"second.css\" precedence=\"second\" />;\n}\n\nfunction ThirdComponent() {\n  return <link rel=\"stylesheet\" href=\"third.css\" precedence=\"first\" />;\n}\n\n\nShow more\n\nNote the precedence values themselves are arbitrary and their naming is up to you. React will infer that precedence values it discovers first are ‚Äúlower‚Äù and precedence values it discovers later are ‚Äúhigher‚Äù.\n\nDeduplicated stylesheet rendering \n\nIf you render the same stylesheet from multiple components, React will place only a single <link> in the document head.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\n\nexport default function HomePage() {\n  return (\n    <ShowRenderedHTML>\n      <Component />\n      <Component />\n      ...\n    </ShowRenderedHTML>\n  );\n}\n\nfunction Component() {\n  return <link rel=\"stylesheet\" href=\"styles.css\" precedence=\"medium\" />;\n}\n\n\nAnnotating specific items within the document with links \n\nYou can use the <link> component with the itemProp prop to annotate specific items within the document with links to related resources. In this case, React will not place these annotations within the document <head> but will place them like any other React component.\n\n<section itemScope>\n\n  <h3>Annotating specific items</h3>\n\n  <link itemProp=\"author\" href=\"http://example.com/\" />\n\n  <p>...</p>\n\n</section>\nPREVIOUS\n<textarea>\nNEXT\n<meta>"
  },
  {
    "title": "<meta> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/meta",
    "html": "API REFERENCE\nCOMPONENTS\n<meta>\n\nThe built-in browser <meta> component lets you add metadata to the document.\n\n<meta name=\"keywords\" content=\"React, JavaScript, semantic markup, html\" />\nReference\n<meta>\nUsage\nAnnotating the document with metadata\nAnnotating specific items within the document with metadata\nReference \n<meta> \n\nTo add document metadata, render the built-in browser <meta> component. You can render <meta> from any component and React will always place the corresponding DOM element in the document head.\n\n<meta name=\"keywords\" content=\"React, JavaScript, semantic markup, html\" />\n\nSee more examples below.\n\nProps \n\n<meta> supports all common element props.\n\nIt should have exactly one of the following props: name, httpEquiv, charset, itemProp. The <meta> component does something different depending on which of these props is specified.\n\nname: a string. Specifies the kind of metadata to be attached to the document.\ncharset: a string. Specifies the character set used by the document. The only valid value is \"utf-8\".\nhttpEquiv: a string. Specifies a directive for processing the document.\nitemProp: a string. Specifies metadata about a particular item within the document rather than the document as a whole.\ncontent: a string. Specifies the metadata to be attached when used with the name or itemProp props or the behavior of the directive when used with the httpEquiv prop.\nSpecial rendering behavior \n\nReact will always place the DOM element corresponding to the <meta> component within the document‚Äôs <head>, regardless of where in the React tree it is rendered. The <head> is the only valid place for <meta> to exist within the DOM, yet it‚Äôs convenient and keeps things composable if a component representing a specific page can render <meta> components itself.\n\nThere is one exception to this: if <meta> has an itemProp prop, there is no special behavior, because in this case it doesn‚Äôt represent metadata about the document but rather metadata about a specific part of the page.\n\nUsage \nAnnotating the document with metadata \n\nYou can annotate the document with metadata such as keywords, a summary, or the author‚Äôs name. React will place this metadata within the document <head> regardless of where in the React tree it is rendered.\n\n<meta name=\"author\" content=\"John Smith\" />\n\n<meta name=\"keywords\" content=\"React, JavaScript, semantic markup, html\" />\n\n<meta name=\"description\" content=\"API reference for the <meta> component in React DOM\" />\n\nYou can render the <meta> component from any component. React will put a <meta> DOM node in the document <head>.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\n\nexport default function SiteMapPage() {\n  return (\n    <ShowRenderedHTML>\n      <meta name=\"keywords\" content=\"React\" />\n      <meta name=\"description\" content=\"A site map for the React website\" />\n      <h1>Site Map</h1>\n      <p>...</p>\n    </ShowRenderedHTML>\n  );\n}\n\n\nAnnotating specific items within the document with metadata \n\nYou can use the <meta> component with the itemProp prop to annotate specific items within the document with metadata. In this case, React will not place these annotations within the document <head> but will place them like any other React component.\n\n<section itemScope>\n\n  <h3>Annotating specific items</h3>\n\n  <meta itemProp=\"description\" content=\"API reference for using <meta> with itemProp\" />\n\n  <p>...</p>\n\n</section>\nPREVIOUS\n<link>\nNEXT\n<script>"
  },
  {
    "title": "<script> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/script",
    "html": "API REFERENCE\nCOMPONENTS\n<script>\n\nThe built-in browser <script> component lets you add a script to your document.\n\n<script> alert(\"hi!\") </script>\nReference\n<script>\nUsage\nRendering an external script\nRendering an inline script\nReference \n<script> \n\nTo add inline or external scripts to your document, render the built-in browser <script> component. You can render <script> from any component and React will in certain cases place the corresponding DOM element in the document head and de-duplicate identical scripts.\n\n<script> alert(\"hi!\") </script>\n\n<script src=\"script.js\" />\n\nSee more examples below.\n\nProps \n\n<script> supports all common element props.\n\nIt should have either children or a src prop.\n\nchildren: a string. The source code of an inline script.\nsrc: a string. The URL of an external script.\n\nOther supported props:\n\nasync: a boolean. Allows the browser to defer execution of the script until the rest of the document has been processed ‚Äî the preferred behavior for performance.\ncrossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials.\nfetchPriority: a string. Lets the browser rank scripts in priority when fetching multiple scripts at the same time. Can be \"high\", \"low\", or \"auto\" (the default).\nintegrity: a string. A cryptographic hash of the script, to verify its authenticity.\nnoModule: a boolean. Disables the script in browsers that support ES modules ‚Äî allowing for a fallback script for browsers that do not.\nnonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.\nreferrer: a string. Says what Referer header to send when fetching the script and any resources that the script fetches in turn.\ntype: a string. Says whether the script is a classic script, ES module, or import map.\n\nProps that disable React‚Äôs special treatment of scripts:\n\nonError: a function. Called when the script fails to load.\nonLoad: a function. Called when the script finishes being loaded.\n\nProps that are not recommended for use with React:\n\nblocking: a string. If set to \"render\", instructs the browser not to render the page until the scriptsheet is loaded. React provides more fine-grained control using Suspense.\ndefer: a string. Prevents the browser from executing the script until the document is done loading. Not compatible with streaming server-rendered components. Use the async prop instead.\nSpecial rendering behavior \n\nReact can move <script> components to the document‚Äôs <head> and de-duplicate identical scripts.\n\nTo opt into this behavior, provide the src and async={true} props. React will de-duplicate scripts if they have the same src. The async prop must be true to allow scripts to be safely moved.\n\nThis special treatment comes with two caveats:\n\nReact will ignore changes to props after the script has been rendered. (React will issue a warning in development if this happens.)\nReact may leave the script in the DOM even after the component that rendered it has been unmounted. (This has no effect as scripts just execute once when they are inserted into the DOM.)\nUsage \nRendering an external script \n\nIf a component depends on certain scripts in order to be displayed correctly, you can render a <script> within the component.\nHowever, the component might be committed before the script has finished loading.\nYou can start depending on the script content once the load event is fired e.g. by using the onLoad prop.\n\nReact will de-duplicate scripts that have the same src, inserting only one of them into the DOM even if multiple components render it.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\n\nfunction Map({lat, long}) {\n  return (\n    <>\n      <script async src=\"map-api.js\" onLoad={() => console.log('script loaded')} />\n      <div id=\"map\" data-lat={lat} data-long={long} />\n    </>\n  );\n}\n\nexport default function Page() {\n  return (\n    <ShowRenderedHTML>\n      <Map />\n    </ShowRenderedHTML>\n  );\n}\n\n\nShow more\nNote\n\nWhen you want to use a script, it can be beneficial to call the preinit function. Calling this function may allow the browser to start fetching the script earlier than if you just render a <script> component, for example by sending an HTTP Early Hints response.\n\nRendering an inline script \n\nTo include an inline script, render the <script> component with the script source code as its children. Inline scripts are not de-duplicated or moved to the document <head>.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\n\nfunction Tracking() {\n  return (\n    <script>\n      ga('send', 'pageview');\n    </script>\n  );\n}\n\nexport default function Page() {\n  return (\n    <ShowRenderedHTML>\n      <h1>My Website</h1>\n      <Tracking />\n      <p>Welcome</p>\n    </ShowRenderedHTML>\n  );\n}\n\n\nShow more\nPREVIOUS\n<meta>\nNEXT\n<style>"
  },
  {
    "title": "<style> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/style",
    "html": "API REFERENCE\nCOMPONENTS\n<style>\n\nThe built-in browser <style> component lets you add inline CSS stylesheets to your document.\n\n<style>{` p { color: red; } `}</style>\nReference\n<style>\nUsage\nRendering an inline CSS stylesheet\nReference \n<style> \n\nTo add inline styles to your document, render the built-in browser <style> component. You can render <style> from any component and React will in certain cases place the corresponding DOM element in the document head and de-duplicate identical styles.\n\n<style>{` p { color: red; } `}</style>\n\nSee more examples below.\n\nProps \n\n<style> supports all common element props.\n\nchildren: a string, required. The contents of the stylesheet.\nprecedence: a string. Tells React where to rank the <style> DOM node relative to others in the document <head>, which determines which stylesheet can override the other. React will infer that precedence values it discovers first are ‚Äúlower‚Äù and precedence values it discovers later are ‚Äúhigher‚Äù. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are <link> or inline <style> tags or loaded using preinit functions.\nhref: a string. Allows React to de-duplicate styles that have the same href.\nmedia: a string. Restricts the stylesheet to a certain media query.\nnonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.\ntitle: a string. Specifies the name of an alternative stylesheet.\n\nProps that are not recommended for use with React:\n\nblocking: a string. If set to \"render\", instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense.\nSpecial rendering behavior \n\nReact can move <style> components to the document‚Äôs <head>, de-duplicate identical stylesheets, and suspend while the stylesheet is loading.\n\nTo opt into this behavior, provide the href and precedence props. React will de-duplicate styles if they have the same href. The precedence prop tells React where to rank the <style> DOM node relative to others in the document <head>, which determines which stylesheet can override the other.\n\nThis special treatment comes with three caveats:\n\nReact will ignore changes to props after the style has been rendered. (React will issue a warning in development if this happens.)\nReact will drop all extraneous props when using the precedence prop (beyond href and precedence).\nReact may leave the style in the DOM even after the component that rendered it has been unmounted.\nUsage \nRendering an inline CSS stylesheet \n\nIf a component depends on certain CSS styles in order to be displayed correctly, you can render an inline stylesheet within the component.\n\nThe href prop should uniquely identify the stylesheet, because React will de-duplicate stylesheets that have the same href.\nIf you supply a precedence prop, React will reorder inline stylesheets based on the order these values appear in the component tree.\n\nInline stylesheets will not trigger Suspense boundaries while they‚Äôre loading.\nEven if they load async resources like fonts or images.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\nimport { useId } from 'react';\n\nfunction PieChart({data, colors}) {\n  const id = useId();\n  const stylesheet = colors.map((color, index) =>\n    `#${id} .color-${index}: \\{ color: \"${color}\"; \\}`\n  ).join();\n  return (\n    <>\n      <style href={\"PieChart-\" + JSON.stringify(colors)} precedence=\"medium\">\n        {stylesheet}\n      </style>\n      <svg id={id}>\n        ‚Ä¶\n      </svg>\n    </>\n  );\n}\n\nexport default function App() {\n  return (\n    <ShowRenderedHTML>\n      <PieChart data=\"...\" colors={['red', 'green', 'blue']} />\n    </ShowRenderedHTML>\n  );\n}\n\n\nShow more\nPREVIOUS\n<script>\nNEXT\n<title>"
  },
  {
    "title": "<title> ‚Äì React",
    "url": "https://react.dev/reference/react-dom/components/title",
    "html": "API REFERENCE\nCOMPONENTS\n<title>\n\nThe built-in browser <title> component lets you specify the title of the document.\n\n<title>My Blog</title>\nReference\n<title>\nUsage\nSet the document title\nUse variables in the title\nReference \n<title> \n\nTo specify the title of the document, render the built-in browser <title> component. You can render <title> from any component and React will always place the corresponding DOM element in the document head.\n\n<title>My Blog</title>\n\nSee more examples below.\n\nProps \n\n<title> supports all common element props.\n\nchildren: <title> accepts only text as a child. This text will become the title of the document. You can also pass your own components as long as they only render text.\nSpecial rendering behavior \n\nReact will always place the DOM element corresponding to the <title> component within the document‚Äôs <head>, regardless of where in the React tree it is rendered. The <head> is the only valid place for <title> to exist within the DOM, yet it‚Äôs convenient and keeps things composable if a component representing a specific page can render its <title> itself.\n\nThere are two exception to this:\n\nIf <title> is within an <svg> component, then there is no special behavior, because in this context it doesn‚Äôt represent the document‚Äôs title but rather is an accessibility annotation for that SVG graphic.\nIf the <title> has an itemProp prop, there is no special behavior, because in this case it doesn‚Äôt represent the document‚Äôs title but rather metadata about a specific part of the page.\nPitfall\n\nOnly render a single <title> at a time. If more than one component renders a <title> tag at the same time, React will place all of those titles in the document head. When this happens, the behavior of browsers and search engines is undefined.\n\nUsage \nSet the document title \n\nRender the <title> component from any component with text as its children. React will put a <title> DOM node in the document <head>.\n\nApp.js\nShowRenderedHTML.js\nReload\nClear\nFork\nimport ShowRenderedHTML from './ShowRenderedHTML.js';\n\nexport default function ContactUsPage() {\n  return (\n    <ShowRenderedHTML>\n      <title>My Site: Contact Us</title>\n      <h1>Contact Us</h1>\n      <p>Email us at support@example.com</p>\n    </ShowRenderedHTML>\n  );\n}\n\n\nUse variables in the title \n\nThe children of the <title> component must be a single string of text. (Or a single number or a single object with a toString method.) It might not be obvious, but using JSX curly braces like this:\n\n<title>Results page {pageNumber}</title> // üî¥ Problem: This is not a single string\n\n‚Ä¶ actually causes the <title> component to get a two-element array as its children (the string \"Results page\" and the value of pageNumber). This will cause an error. Instead, use string interpolation to pass <title> a single string:\n\n<title>{`Results page ${pageNumber}`}</title>\nPREVIOUS\n<style>\nNEXT\nAPIs"
  },
  {
    "title": "createPortal ‚Äì React",
    "url": "https://react.dev/reference/react-dom/createPortal",
    "html": "API REFERENCE\nAPIS\ncreatePortal\n\ncreatePortal lets you render some children into a different part of the DOM.\n\n<div>\n\n  <SomeComponent />\n\n  {createPortal(children, domNode, key?)}\n\n</div>\nReference\ncreatePortal(children, domNode, key?)\nUsage\nRendering to a different part of the DOM\nRendering a modal dialog with a portal\nRendering React components into non-React server markup\nRendering React components into non-React DOM nodes\nReference \ncreatePortal(children, domNode, key?) \n\nTo create a portal, call createPortal, passing some JSX, and the DOM node where it should be rendered:\n\nimport { createPortal } from 'react-dom';\n\n\n\n// ...\n\n\n\n<div>\n\n  <p>This child is placed in the parent div.</p>\n\n  {createPortal(\n\n    <p>This child is placed in the document body.</p>,\n\n    document.body\n\n  )}\n\n</div>\n\nSee more examples below.\n\nA portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events bubble up from children to parents according to the React tree.\n\nParameters \n\nchildren: Anything that can be rendered with React, such as a piece of JSX (e.g. <div /> or <SomeComponent />), a Fragment (<>...</>), a string or a number, or an array of these.\n\ndomNode: Some DOM node, such as those returned by document.getElementById(). The node must already exist. Passing a different DOM node during an update will cause the portal content to be recreated.\n\noptional key: A unique string or number to be used as the portal‚Äôs key.\n\nReturns \n\ncreatePortal returns a React node that can be included into JSX or returned from a React component. If React encounters it in the render output, it will place the provided children inside the provided domNode.\n\nCaveats \nEvents from portals propagate according to the React tree rather than the DOM tree. For example, if you click inside a portal, and the portal is wrapped in <div onClick>, that onClick handler will fire. If this causes issues, either stop the event propagation from inside the portal, or move the portal itself up in the React tree.\nUsage \nRendering to a different part of the DOM \n\nPortals let your components render some of their children into a different place in the DOM. This lets a part of your component ‚Äúescape‚Äù from whatever containers it may be in. For example, a component can display a modal dialog or a tooltip that appears above and outside of the rest of the page.\n\nTo create a portal, render the result of createPortal with some JSX and the DOM node where it should go:\n\nimport { createPortal } from 'react-dom';\n\n\n\nfunction MyComponent() {\n\n  return (\n\n    <div style={{ border: '2px solid black' }}>\n\n      <p>This child is placed in the parent div.</p>\n\n      {createPortal(\n\n        <p>This child is placed in the document body.</p>,\n\n        document.body\n\n      )}\n\n    </div>\n\n  );\n\n}\n\nReact will put the DOM nodes for the JSX you passed inside of the DOM node you provided.\n\nWithout a portal, the second <p> would be placed inside the parent <div>, but the portal ‚Äúteleported‚Äù it into the document.body:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { createPortal } from 'react-dom';\n\nexport default function MyComponent() {\n  return (\n    <div style={{ border: '2px solid black' }}>\n      <p>This child is placed in the parent div.</p>\n      {createPortal(\n        <p>This child is placed in the document body.</p>,\n        document.body\n      )}\n    </div>\n  );\n}\n\n\n\nNotice how the second paragraph visually appears outside the parent <div> with the border. If you inspect the DOM structure with developer tools, you‚Äôll see that the second <p> got placed directly into the <body>:\n\n<body>\n\n  <div id=\"root\">\n\n    ...\n\n      <div style=\"border: 2px solid black\">\n\n        <p>This child is placed inside the parent div.</p>\n\n      </div>\n\n    ...\n\n  </div>\n\n  <p>This child is placed in the document body.</p>\n\n</body>\n\nA portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events still bubble up from children to parents according to the React tree.\n\nRendering a modal dialog with a portal \n\nYou can use a portal to create a modal dialog that floats above the rest of the page, even if the component that summons the dialog is inside a container with overflow: hidden or other styles that interfere with the dialog.\n\nIn this example, the two containers have styles that disrupt the modal dialog, but the one rendered into a portal is unaffected because, in the DOM, the modal is not contained within the parent JSX elements.\n\nApp.js\nNoPortalExample.js\nPortalExample.js\nModalContent.js\nReload\nClear\nFork\nimport NoPortalExample from './NoPortalExample';\nimport PortalExample from './PortalExample';\n\nexport default function App() {\n  return (\n    <>\n      <div className=\"clipping-container\">\n        <NoPortalExample  />\n      </div>\n      <div className=\"clipping-container\">\n        <PortalExample />\n      </div>\n    </>\n  );\n}\n\n\nPitfall\n\nIt‚Äôs important to make sure that your app is accessible when using portals. For instance, you may need to manage keyboard focus so that the user can move the focus in and out of the portal in a natural way.\n\nFollow the WAI-ARIA Modal Authoring Practices when creating modals. If you use a community package, ensure that it is accessible and follows these guidelines.\n\nRendering React components into non-React server markup \n\nPortals can be useful if your React root is only part of a static or server-rendered page that isn‚Äôt built with React. For example, if your page is built with a server framework like Rails, you can create areas of interactivity within static areas such as sidebars. Compared with having multiple separate React roots, portals let you treat the app as a single React tree with shared state even though its parts render to different parts of the DOM.\n\nindex.js\nindex.html\nApp.js\nReload\nClear\nFork\nimport { createPortal } from 'react-dom';\n\nconst sidebarContentEl = document.getElementById('sidebar-content');\n\nexport default function App() {\n  return (\n    <>\n      <MainContent />\n      {createPortal(\n        <SidebarContent />,\n        sidebarContentEl\n      )}\n    </>\n  );\n}\n\nfunction MainContent() {\n  return <p>This part is rendered by React</p>;\n}\n\nfunction SidebarContent() {\n  return <p>This part is also rendered by React!</p>;\n}\n\n\nShow more\nRendering React components into non-React DOM nodes \n\nYou can also use a portal to manage the content of a DOM node that‚Äôs managed outside of React. For example, suppose you‚Äôre integrating with a non-React map widget and you want to render React content inside a popup. To do this, declare a popupContainer state variable to store the DOM node you‚Äôre going to render into:\n\nconst [popupContainer, setPopupContainer] = useState(null);\n\nWhen you create the third-party widget, store the DOM node returned by the widget so you can render into it:\n\nuseEffect(() => {\n\n  if (mapRef.current === null) {\n\n    const map = createMapWidget(containerRef.current);\n\n    mapRef.current = map;\n\n    const popupDiv = addPopupToMapWidget(map);\n\n    setPopupContainer(popupDiv);\n\n  }\n\n}, []);\n\nThis lets you use createPortal to render React content into popupContainer once it becomes available:\n\nreturn (\n\n  <div style={{ width: 250, height: 250 }} ref={containerRef}>\n\n    {popupContainer !== null && createPortal(\n\n      <p>Hello from React!</p>,\n\n      popupContainer\n\n    )}\n\n  </div>\n\n);\n\nHere is a complete example you can play with:\n\nApp.js\nmap-widget.js\nReload\nClear\nFork\nimport { useRef, useEffect, useState } from 'react';\nimport { createPortal } from 'react-dom';\nimport { createMapWidget, addPopupToMapWidget } from './map-widget.js';\n\nexport default function Map() {\n  const containerRef = useRef(null);\n  const mapRef = useRef(null);\n  const [popupContainer, setPopupContainer] = useState(null);\n\n  useEffect(() => {\n    if (mapRef.current === null) {\n      const map = createMapWidget(containerRef.current);\n      mapRef.current = map;\n      const popupDiv = addPopupToMapWidget(map);\n      setPopupContainer(popupDiv);\n    }\n  }, []);\n\n  return (\n    <div style={{ width: 250, height: 250 }} ref={containerRef}>\n      {popupContainer !== null && createPortal(\n        <p>Hello from React!</p>,\n        popupContainer\n      )}\n    </div>\n  );\n}\n\n\nShow more\nPREVIOUS\nAPIs\nNEXT\nflushSync"
  },
  {
    "title": "flushSync ‚Äì React",
    "url": "https://react.dev/reference/react-dom/flushSync",
    "html": "API REFERENCE\nAPIS\nflushSync\nPitfall\n\nUsing flushSync is uncommon and can hurt the performance of your app.\n\nflushSync lets you force React to flush any updates inside the provided callback synchronously. This ensures that the DOM is updated immediately.\n\nflushSync(callback)\nReference\nflushSync(callback)\nUsage\nFlushing updates for third-party integrations\nTroubleshooting\nI‚Äôm getting an error: ‚ÄúflushSync was called from inside a lifecycle method‚Äù\nReference \nflushSync(callback) \n\nCall flushSync to force React to flush any pending work and update the DOM synchronously.\n\nimport { flushSync } from 'react-dom';\n\n\n\nflushSync(() => {\n\n  setSomething(123);\n\n});\n\nMost of the time, flushSync can be avoided. Use flushSync as last resort.\n\nSee more examples below.\n\nParameters \ncallback: A function. React will immediately call this callback and flush any updates it contains synchronously. It may also flush any pending updates, or Effects, or updates inside of Effects. If an update suspends as a result of this flushSync call, the fallbacks may be re-shown.\nReturns \n\nflushSync returns undefined.\n\nCaveats \nflushSync can significantly hurt performance. Use sparingly.\nflushSync may force pending Suspense boundaries to show their fallback state.\nflushSync may run pending Effects and synchronously apply any updates they contain before returning.\nflushSync may flush updates outside the callback when necessary to flush the updates inside the callback. For example, if there are pending updates from a click, React may flush those before flushing the updates inside the callback.\nUsage \nFlushing updates for third-party integrations \n\nWhen integrating with third-party code such as browser APIs or UI libraries, it may be necessary to force React to flush updates. Use flushSync to force React to flush any state updates inside the callback synchronously:\n\nflushSync(() => {\n\n  setSomething(123);\n\n});\n\n// By this line, the DOM is updated.\n\nThis ensures that, by the time the next line of code runs, React has already updated the DOM.\n\nUsing flushSync is uncommon, and using it often can significantly hurt the performance of your app. If your app only uses React APIs, and does not integrate with third-party libraries, flushSync should be unnecessary.\n\nHowever, it can be helpful for integrating with third-party code like browser APIs.\n\nSome browser APIs expect results inside of callbacks to be written to the DOM synchronously, by the end of the callback, so the browser can do something with the rendered DOM. In most cases, React handles this for you automatically. But in some cases it may be necessary to force a synchronous update.\n\nFor example, the browser onbeforeprint API allows you to change the page immediately before the print dialog opens. This is useful for applying custom print styles that allow the document to display better for printing. In the example below, you use flushSync inside of the onbeforeprint callback to immediately ‚Äúflush‚Äù the React state to the DOM. Then, by the time the print dialog opens, isPrinting displays ‚Äúyes‚Äù:\n\nApp.js\nDownload\nReload\nClear\nFork\nimport { useState, useEffect } from 'react';\nimport { flushSync } from 'react-dom';\n\nexport default function PrintApp() {\n  const [isPrinting, setIsPrinting] = useState(false);\n\n  useEffect(() => {\n    function handleBeforePrint() {\n      flushSync(() => {\n        setIsPrinting(true);\n      })\n    }\n\n    function handleAfterPrint() {\n      setIsPrinting(false);\n    }\n\n    window.addEventListener('beforeprint', handleBeforePrint);\n    window.addEventListener('afterprint', handleAfterPrint);\n    return () => {\n      window.removeEventListener('beforeprint', handleBeforePrint);\n      window.removeEventListener('afterprint', handleAfterPrint);\n    }\n  }, []);\n\n  return (\n    <>\n      <h1>isPrinting: {isPrinting ? 'yes' : 'no'}</h1>\n      <button onClick={() => window.print()}>\n        Print\n      </button>\n    </>\n  );\n}\n\n\nShow more\n\nWithout flushSync, the print dialog will display isPrinting as ‚Äúno‚Äù. This is because React batches the updates asynchronously and the print dialog is displayed before the state is updated.\n\nPitfall\n\nflushSync can significantly hurt performance, and may unexpectedly force pending Suspense boundaries to show their fallback state.\n\nMost of the time, flushSync can be avoided, so use flushSync as a last resort.\n\nTroubleshooting \nI‚Äôm getting an error: ‚ÄúflushSync was called from inside a lifecycle method‚Äù \n\nReact cannot flushSync in the middle of a render. If you do, it will noop and warn:\n\nConsole\nWarning: flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.\n\nThis includes calling flushSync inside:\n\nrendering a component.\nuseLayoutEffect or useEffect hooks.\nClass component lifecycle methods.\n\nFor example, calling flushSync in an Effect will noop and warn:\n\nimport { useEffect } from 'react';\n\nimport { flushSync } from 'react-dom';\n\n\n\nfunction MyComponent() {\n\n  useEffect(() => {\n\n    // üö© Wrong: calling flushSync inside an effect\n\n    flushSync(() => {\n\n      setSomething(newValue);\n\n    });\n\n  }, []);\n\n\n\n  return <div>{/* ... */}</div>;\n\n}\n\nTo fix this, you usually want to move the flushSync call to an event:\n\nfunction handleClick() {\n\n  // ‚úÖ Correct: flushSync in event handlers is safe\n\n  flushSync(() => {\n\n    setSomething(newValue);\n\n  });\n\n}\n\nIf it‚Äôs difficult to move to an event, you can defer flushSync in a microtask:\n\nuseEffect(() => {\n\n  // ‚úÖ Correct: defer flushSync to a microtask\n\n  queueMicrotask(() => {\n\n    flushSync(() => {\n\n      setSomething(newValue);\n\n    });\n\n  });\n\n}, []);\n\nThis will allow the current render to finish and schedule another syncronous render to flush the updates.\n\nPitfall\n\nflushSync can significantly hurt performance, but this particular pattern is even worse for performance. Exhaust all other options before calling flushSync in a microtask as an escape hatch.\n\nPREVIOUS\ncreatePortal\nNEXT\npreconnect"
  },
  {
    "title": "preconnect ‚Äì React",
    "url": "https://react.dev/reference/react-dom/preconnect",
    "html": "API REFERENCE\nAPIS\npreconnect\n\npreconnect lets you eagerly connect to a server that you expect to load resources from.\n\npreconnect(\"https://example.com\");\nReference\npreconnect(href)\nUsage\nPreconnecting when rendering\nPreconnecting in an event handler\nReference \npreconnect(href) \n\nTo preconnect to a host, call the preconnect function from react-dom.\n\nimport { preconnect } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preconnect(\"https://example.com\");\n\n  // ...\n\n}\n\nSee more examples below.\n\nThe preconnect function provides the browser with a hint that it should open a connection to the given server. If the browser chooses to do so, this can speed up the loading of resources from that server.\n\nParameters \nhref: a string. The URL of the server you want to connect to.\nReturns \n\npreconnect returns nothing.\n\nCaveats \nMultiple calls to preconnect with the same server have the same effect as a single call.\nIn the browser, you can call preconnect in any situation: while rendering a component, in an Effect, in an event handler, and so on.\nIn server-side rendering or when rendering Server Components, preconnect only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\nIf you know the specific resources you‚Äôll need, you can call other functions instead that will start loading the resources right away.\nThere is no benefit to preconnecting to the same server the webpage itself is hosted from because it‚Äôs already been connected to by the time the hint would be given.\nUsage \nPreconnecting when rendering \n\nCall preconnect when rendering a component if you know that its children will load external resources from that host.\n\nimport { preconnect } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preconnect(\"https://example.com\");\n\n  return ...;\n\n}\nPreconnecting in an event handler \n\nCall preconnect in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\n\nimport { preconnect } from 'react-dom';\n\n\n\nfunction CallToAction() {\n\n  const onClick = () => {\n\n    preconnect('http://example.com');\n\n    startWizard();\n\n  }\n\n  return (\n\n    <button onClick={onClick}>Start Wizard</button>\n\n  );\n\n}\nPREVIOUS\nflushSync\nNEXT\nprefetchDNS"
  },
  {
    "title": "prefetchDNS ‚Äì React",
    "url": "https://react.dev/reference/react-dom/prefetchDNS",
    "html": "API REFERENCE\nAPIS\nprefetchDNS\n\nprefetchDNS lets you eagerly look up the IP of a server that you expect to load resources from.\n\nprefetchDNS(\"https://example.com\");\nReference\nprefetchDNS(href)\nUsage\nPrefetching DNS when rendering\nPrefetching DNS in an event handler\nReference \nprefetchDNS(href) \n\nTo look up a host, call the prefetchDNS function from react-dom.\n\nimport { prefetchDNS } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  prefetchDNS(\"https://example.com\");\n\n  // ...\n\n}\n\nSee more examples below.\n\nThe prefetchDNS function provides the browser with a hint that it should look up the IP address of a given server. If the browser chooses to do so, this can speed up the loading of resources from that server.\n\nParameters \nhref: a string. The URL of the server you want to connect to.\nReturns \n\nprefetchDNS returns nothing.\n\nCaveats \nMultiple calls to prefetchDNS with the same server have the same effect as a single call.\nIn the browser, you can call prefetchDNS in any situation: while rendering a component, in an Effect, in an event handler, and so on.\nIn server-side rendering or when rendering Server Components, prefetchDNS only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\nIf you know the specific resources you‚Äôll need, you can call other functions instead that will start loading the resources right away.\nThere is no benefit to prefetching the same server the webpage itself is hosted from because it‚Äôs already been looked up by the time the hint would be given.\nCompared with preconnect, prefetchDNS may be better if you are speculatively connecting to a large number of domains, in which case the overhead of preconnections might outweigh the benefit.\nUsage \nPrefetching DNS when rendering \n\nCall prefetchDNS when rendering a component if you know that its children will load external resources from that host.\n\nimport { prefetchDNS } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  prefetchDNS(\"https://example.com\");\n\n  return ...;\n\n}\nPrefetching DNS in an event handler \n\nCall prefetchDNS in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\n\nimport { prefetchDNS } from 'react-dom';\n\n\n\nfunction CallToAction() {\n\n  const onClick = () => {\n\n    prefetchDNS('http://example.com');\n\n    startWizard();\n\n  }\n\n  return (\n\n    <button onClick={onClick}>Start Wizard</button>\n\n  );\n\n}\nPREVIOUS\npreconnect\nNEXT\npreinit"
  },
  {
    "title": "preinit ‚Äì React",
    "url": "https://react.dev/reference/react-dom/preinit",
    "html": "API REFERENCE\nAPIS\npreinit\nNote\n\nReact-based frameworks frequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework‚Äôs documentation for details.\n\npreinit lets you eagerly fetch and evaluate a stylesheet or external script.\n\npreinit(\"https://example.com/script.js\", {as: \"script\"});\nReference\npreinit(href, options)\nUsage\nPreiniting when rendering\nPreiniting in an event handler\nReference \npreinit(href, options) \n\nTo preinit a script or stylesheet, call the preinit function from react-dom.\n\nimport { preinit } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preinit(\"https://example.com/script.js\", {as: \"script\"});\n\n  // ...\n\n}\n\nSee more examples below.\n\nThe preinit function provides the browser with a hint that it should start downloading and executing the given resource, which can save time. Scripts that you preinit are executed when they finish downloading. Stylesheets that you preinit are inserted into the document, which causes them to go into effect right away.\n\nParameters \nhref: a string. The URL of the resource you want to download and execute.\noptions: an object. It contains the following properties:\nas: a required string. The type of resource. Its possible values are script and style.\nprecedence: a string. Required with stylesheets. Says where to insert the stylesheet relative to others. Stylesheets with higher precedence can override those with lower precedence. The possible values are reset, low, medium, high.\ncrossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials.\nintegrity: a string. A cryptographic hash of the resource, to verify its authenticity.\nnonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.\nfetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values are auto (the default), high, and low.\nReturns \n\npreinit returns nothing.\n\nCaveats \nMultiple calls to preinit with the same href have the same effect as a single call.\nIn the browser, you can call preinit in any situation: while rendering a component, in an Effect, in an event handler, and so on.\nIn server-side rendering or when rendering Server Components, preinit only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\nUsage \nPreiniting when rendering \n\nCall preinit when rendering a component if you know that it or its children will use a specific resource, and you‚Äôre OK with the resource being evaluated and thereby taking effect immediately upon being downloaded.\n\nExamples of preiniting\n1. Preiniting an external script\n2. Preiniting a stylesheet\nExample 1 of 2: Preiniting an external script \nimport { preinit } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preinit(\"https://example.com/script.js\", {as: \"script\"});\n\n  return ...;\n\n}\n\nIf you want the browser to download the script but not to execute it right away, use preload instead. If you want to load an ESM module, use preinitModule.\n\nNext Example\nPreiniting in an event handler \n\nCall preinit in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\n\nimport { preinit } from 'react-dom';\n\n\n\nfunction CallToAction() {\n\n  const onClick = () => {\n\n    preinit(\"https://example.com/wizardStyles.css\", {as: \"style\"});\n\n    startWizard();\n\n  }\n\n  return (\n\n    <button onClick={onClick}>Start Wizard</button>\n\n  );\n\n}\nPREVIOUS\nprefetchDNS\nNEXT\npreinitModule"
  },
  {
    "title": "preinitModule ‚Äì React",
    "url": "https://react.dev/reference/react-dom/preinitModule",
    "html": "API REFERENCE\nAPIS\npreinitModule\nNote\n\nReact-based frameworks frequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework‚Äôs documentation for details.\n\npreinitModule lets you eagerly fetch and evaluate an ESM module.\n\npreinitModule(\"https://example.com/module.js\", {as: \"script\"});\nReference\npreinitModule(href, options)\nUsage\nPreloading when rendering\nPreloading in an event handler\nReference \npreinitModule(href, options) \n\nTo preinit an ESM module, call the preinitModule function from react-dom.\n\nimport { preinitModule } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preinitModule(\"https://example.com/module.js\", {as: \"script\"});\n\n  // ...\n\n}\n\nSee more examples below.\n\nThe preinitModule function provides the browser with a hint that it should start downloading and executing the given module, which can save time. Modules that you preinit are executed when they finish downloading.\n\nParameters \nhref: a string. The URL of the module you want to download and execute.\noptions: an object. It contains the following properties:\nas: a required string. It must be 'script'.\ncrossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials.\nintegrity: a string. A cryptographic hash of the module, to verify its authenticity.\nnonce: a string. A cryptographic nonce to allow the module when using a strict Content Security Policy.\nReturns \n\npreinitModule returns nothing.\n\nCaveats \nMultiple calls to preinitModule with the same href have the same effect as a single call.\nIn the browser, you can call preinitModule in any situation: while rendering a component, in an Effect, in an event handler, and so on.\nIn server-side rendering or when rendering Server Components, preinitModule only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\nUsage \nPreloading when rendering \n\nCall preinitModule when rendering a component if you know that it or its children will use a specific module and you‚Äôre OK with the module being evaluated and thereby taking effect immediately upon being downloaded.\n\nimport { preinitModule } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preinitModule(\"https://example.com/module.js\", {as: \"script\"});\n\n  return ...;\n\n}\n\nIf you want the browser to download the module but not to execute it right away, use preloadModule instead. If you want to preinit a script that isn‚Äôt an ESM module, use preinit.\n\nPreloading in an event handler \n\nCall preinitModule in an event handler before transitioning to a page or state where the module will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\n\nimport { preinitModule } from 'react-dom';\n\n\n\nfunction CallToAction() {\n\n  const onClick = () => {\n\n    preinitModule(\"https://example.com/module.js\", {as: \"script\"});\n\n    startWizard();\n\n  }\n\n  return (\n\n    <button onClick={onClick}>Start Wizard</button>\n\n  );\n\n}\nPREVIOUS\npreinit\nNEXT\npreload"
  },
  {
    "title": "preload ‚Äì React",
    "url": "https://react.dev/reference/react-dom/preload",
    "html": "API REFERENCE\nAPIS\npreload\nNote\n\nReact-based frameworks frequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework‚Äôs documentation for details.\n\npreload lets you eagerly fetch a resource such as a stylesheet, font, or external script that you expect to use.\n\npreload(\"https://example.com/font.woff2\", {as: \"font\"});\nReference\npreload(href, options)\nUsage\nPreloading when rendering\nPreloading in an event handler\nReference \npreload(href, options) \n\nTo preload a resource, call the preload function from react-dom.\n\nimport { preload } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preload(\"https://example.com/font.woff2\", {as: \"font\"});\n\n  // ...\n\n}\n\nSee more examples below.\n\nThe preload function provides the browser with a hint that it should start downloading the given resource, which can save time.\n\nParameters \nhref: a string. The URL of the resource you want to download.\noptions: an object. It contains the following properties:\nas: a required string. The type of resource. Its possible values are audio, document, embed, fetch, font, image, object, script, style, track, video, worker.\ncrossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials. It is required when as is set to \"fetch\".\nreferrerPolicy: a string. The Referrer header to send when fetching. Its possible values are no-referrer-when-downgrade (the default), no-referrer, origin, origin-when-cross-origin, and unsafe-url.\nintegrity: a string. A cryptographic hash of the resource, to verify its authenticity.\ntype: a string. The MIME type of the resource.\nnonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy.\nfetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values are auto (the default), high, and low.\nimageSrcSet: a string. For use only with as: \"image\". Specifies the source set of the image.\nimageSizes: a string. For use only with as: \"image\". Specifies the sizes of the image.\nReturns \n\npreload returns nothing.\n\nCaveats \nMultiple equivalent calls to preload have the same effect as a single call. Calls to preload are considered equivalent according to the following rules:\nTwo calls are equivalent if they have the same href, except:\nIf as is set to image, two calls are equivalent if they have the same href, imageSrcSet, and imageSizes.\nIn the browser, you can call preload in any situation: while rendering a component, in an Effect, in an event handler, and so on.\nIn server-side rendering or when rendering Server Components, preload only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\nUsage \nPreloading when rendering \n\nCall preload when rendering a component if you know that it or its children will use a specific resource.\n\nExamples of preloading\n1. Preloading an external script\n2. Preloading a stylesheet\n3. Preloading a font\n4. Preloading an image\nExample 1 of 4: Preloading an external script \nimport { preload } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preload(\"https://example.com/script.js\", {as: \"script\"});\n\n  return ...;\n\n}\n\nIf you want the browser to start executing the script immediately (rather than just downloading it), use preinit instead. If you want to load an ESM module, use preloadModule.\n\nNext Example\nPreloading in an event handler \n\nCall preload in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\n\nimport { preload } from 'react-dom';\n\n\n\nfunction CallToAction() {\n\n  const onClick = () => {\n\n    preload(\"https://example.com/wizardStyles.css\", {as: \"style\"});\n\n    startWizard();\n\n  }\n\n  return (\n\n    <button onClick={onClick}>Start Wizard</button>\n\n  );\n\n}\nPREVIOUS\npreinitModule\nNEXT\npreloadModule"
  },
  {
    "title": "preloadModule ‚Äì React",
    "url": "https://react.dev/reference/react-dom/preloadModule",
    "html": "API REFERENCE\nAPIS\npreloadModule\nNote\n\nReact-based frameworks frequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework‚Äôs documentation for details.\n\npreloadModule lets you eagerly fetch an ESM module that you expect to use.\n\npreloadModule(\"https://example.com/module.js\", {as: \"script\"});\nReference\npreloadModule(href, options)\nUsage\nPreloading when rendering\nPreloading in an event handler\nReference \npreloadModule(href, options) \n\nTo preload an ESM module, call the preloadModule function from react-dom.\n\nimport { preloadModule } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preloadModule(\"https://example.com/module.js\", {as: \"script\"});\n\n  // ...\n\n}\n\nSee more examples below.\n\nThe preloadModule function provides the browser with a hint that it should start downloading the given module, which can save time.\n\nParameters \nhref: a string. The URL of the module you want to download.\noptions: an object. It contains the following properties:\nas: a required string. It must be 'script'.\ncrossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials.\nintegrity: a string. A cryptographic hash of the module, to verify its authenticity.\nnonce: a string. A cryptographic nonce to allow the module when using a strict Content Security Policy.\nReturns \n\npreloadModule returns nothing.\n\nCaveats \nMultiple calls to preloadModule with the same href have the same effect as a single call.\nIn the browser, you can call preloadModule in any situation: while rendering a component, in an Effect, in an event handler, and so on.\nIn server-side rendering or when rendering Server Components, preloadModule only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\nUsage \nPreloading when rendering \n\nCall preloadModule when rendering a component if you know that it or its children will use a specific module.\n\nimport { preloadModule } from 'react-dom';\n\n\n\nfunction AppRoot() {\n\n  preloadModule(\"https://example.com/module.js\", {as: \"script\"});\n\n  return ...;\n\n}\n\nIf you want the browser to start executing the module immediately (rather than just downloading it), use preinitModule instead. If you want to load a script that isn‚Äôt an ESM module, use preload.\n\nPreloading in an event handler \n\nCall preloadModule in an event handler before transitioning to a page or state where the module will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.\n\nimport { preloadModule } from 'react-dom';\n\n\n\nfunction CallToAction() {\n\n  const onClick = () => {\n\n    preloadModule(\"https://example.com/module.js\", {as: \"script\"});\n\n    startWizard();\n\n  }\n\n  return (\n\n    <button onClick={onClick}>Start Wizard</button>\n\n  );\n\n}\nPREVIOUS\npreload\nNEXT\nClient APIs"
  },
  {
    "title": "Client React DOM APIs ‚Äì React",
    "url": "https://react.dev/reference/react-dom/client",
    "html": "API REFERENCE\nClient React DOM APIs\n\nThe react-dom/client APIs let you render React components on the client (in the browser). These APIs are typically used at the top level of your app to initialize your React tree. A framework may call them for you. Most of your components don‚Äôt need to import or use them.\n\nClient APIs \ncreateRoot lets you create a root to display React components inside a browser DOM node.\nhydrateRoot lets you display React components inside a browser DOM node whose HTML content was previously generated by react-dom/server.\nBrowser support \n\nReact supports all popular browsers, including Internet Explorer 9 and above. Some polyfills are required for older browsers such as IE 9 and IE 10.\n\nPREVIOUS\npreloadModule\nNEXT\ncreateRoot"
  },
  {
    "title": "hydrateRoot ‚Äì React",
    "url": "https://react.dev/reference/react-dom/client/hydrateRoot",
    "html": "API REFERENCE\nCLIENT APIS\nhydrateRoot\n\nhydrateRoot lets you display React components inside a browser DOM node whose HTML content was previously generated by react-dom/server.\n\nconst root = hydrateRoot(domNode, reactNode, options?)\nReference\nhydrateRoot(domNode, reactNode, options?)\nroot.render(reactNode)\nroot.unmount()\nUsage\nHydrating server-rendered HTML\nHydrating an entire document\nSuppressing unavoidable hydration mismatch errors\nHandling different client and server content\nUpdating a hydrated root component\nError logging in production\nTroubleshooting\nI‚Äôm getting an error: ‚ÄúYou passed a second argument to root.render‚Äù\nReference \nhydrateRoot(domNode, reactNode, options?) \n\nCall hydrateRoot to ‚Äúattach‚Äù React to existing HTML that was already rendered by React in a server environment.\n\nimport { hydrateRoot } from 'react-dom/client';\n\n\n\nconst domNode = document.getElementById('root');\n\nconst root = hydrateRoot(domNode, reactNode);\n\nReact will attach to the HTML that exists inside the domNode, and take over managing the DOM inside it. An app fully built with React will usually only have one hydrateRoot call with its root component.\n\nSee more examples below.\n\nParameters \n\ndomNode: A DOM element that was rendered as the root element on the server.\n\nreactNode: The ‚ÄúReact node‚Äù used to render the existing HTML. This will usually be a piece of JSX like <App /> which was rendered with a ReactDOM Server method such as renderToPipeableStream(<App />).\n\noptional options: An object with options for this React root.\n\noptional onCaughtError: Callback called when React catches an error in an Error Boundary. Called with the error caught by the Error Boundary, and an errorInfo object containing the componentStack.\noptional onUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with the error that was thrown and an errorInfo object containing the componentStack.\noptional onRecoverableError: Callback called when React automatically recovers from errors. Called with the error React throws, and an errorInfo object containing the componentStack. Some recoverable errors may include the original error cause as error.cause.\noptional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as used on the server.\nReturns \n\nhydrateRoot returns an object with two methods: render and unmount.\n\nCaveats \nhydrateRoot() expects the rendered content to be identical with the server-rendered content. You should treat mismatches as bugs and fix them.\nIn development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.\nYou‚Äôll likely have only one hydrateRoot call in your app. If you use a framework, it might do this call for you.\nIf your app is client-rendered with no HTML rendered already, using hydrateRoot() is not supported. Use createRoot() instead.\nroot.render(reactNode) \n\nCall root.render to update a React component inside a hydrated React root for a browser DOM element.\n\nroot.render(<App />);\n\nReact will update <App /> in the hydrated root.\n\nSee more examples below.\n\nParameters \nreactNode: A ‚ÄúReact node‚Äù that you want to update. This will usually be a piece of JSX like <App />, but you can also pass a React element constructed with createElement(), a string, a number, null, or undefined.\nReturns \n\nroot.render returns undefined.\n\nCaveats \nIf you call root.render before the root has finished hydrating, React will clear the existing server-rendered HTML content and switch the entire root to client rendering.\nroot.unmount() \n\nCall root.unmount to destroy a rendered tree inside a React root.\n\nroot.unmount();\n\nAn app fully built with React will usually not have any calls to root.unmount.\n\nThis is mostly useful if your React root‚Äôs DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. You need to tell React to ‚Äústop‚Äù managing the removed root‚Äôs content by calling root.unmount. Otherwise, the components inside the removed root won‚Äôt clean up and free up resources like subscriptions.\n\nCalling root.unmount will unmount all the components in the root and ‚Äúdetach‚Äù React from the root DOM node, including removing any event handlers or state in the tree.\n\nParameters \n\nroot.unmount does not accept any parameters.\n\nReturns \n\nroot.unmount returns undefined.\n\nCaveats \n\nCalling root.unmount will unmount all the components in the tree and ‚Äúdetach‚Äù React from the root DOM node.\n\nOnce you call root.unmount you cannot call root.render again on the root. Attempting to call root.render on an unmounted root will throw a ‚ÄúCannot update an unmounted root‚Äù error.\n\nUsage \nHydrating server-rendered HTML \n\nIf your app‚Äôs HTML was generated by react-dom/server, you need to hydrate it on the client.\n\nimport { hydrateRoot } from 'react-dom/client';\n\n\n\nhydrateRoot(document.getElementById('root'), <App />);\n\nThis will hydrate the server HTML inside the browser DOM node with the React component for your app. Usually, you will do it once at startup. If you use a framework, it might do this behind the scenes for you.\n\nTo hydrate your app, React will ‚Äúattach‚Äù your components‚Äô logic to the initial generated HTML from the server. Hydration turns the initial HTML snapshot from the server into a fully interactive app that runs in the browser.\n\nindex.js\nindex.html\nApp.js\nReload\nClear\nFork\nimport './styles.css';\nimport { hydrateRoot } from 'react-dom/client';\nimport App from './App.js';\n\nhydrateRoot(\n  document.getElementById('root'),\n  <App />\n);\n\n\n\nYou shouldn‚Äôt need to call hydrateRoot again or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components will use state instead.\n\nPitfall\n\nThe React tree you pass to hydrateRoot needs to produce the same output as it did on the server.\n\nThis is important for the user experience. The user will spend some time looking at the server-generated HTML before your JavaScript code loads. Server rendering creates an illusion that the app loads faster by showing the HTML snapshot of its output. Suddenly showing different content breaks that illusion. This is why the server render output must match the initial render output on the client.\n\nThe most common causes leading to hydration errors include:\n\nExtra whitespace (like newlines) around the React-generated HTML inside the root node.\nUsing checks like typeof window !== 'undefined' in your rendering logic.\nUsing browser-only APIs like window.matchMedia in your rendering logic.\nRendering different data on the server and the client.\n\nReact recovers from some hydration errors, but you must fix them like other bugs. In the best case, they‚Äôll lead to a slowdown; in the worst case, event handlers can get attached to the wrong elements.\n\nHydrating an entire document \n\nApps fully built with React can render the entire document as JSX, including the <html> tag:\n\nfunction App() {\n\n  return (\n\n    <html>\n\n      <head>\n\n        <meta charSet=\"utf-8\" />\n\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\n        <link rel=\"stylesheet\" href=\"/styles.css\"></link>\n\n        <title>My app</title>\n\n      </head>\n\n      <body>\n\n        <Router />\n\n      </body>\n\n    </html>\n\n  );\n\n}\n\nTo hydrate the entire document, pass the document global as the first argument to hydrateRoot:\n\nimport { hydrateRoot } from 'react-dom/client';\n\nimport App from './App.js';\n\n\n\nhydrateRoot(document, <App />);\nSuppressing unavoidable hydration mismatch errors \n\nIf a single element‚Äôs attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the hydration mismatch warning.\n\nTo silence hydration warnings on an element, add suppressHydrationWarning={true}:\n\nindex.js\nindex.html\nApp.js\nReload\nClear\nFork\nexport default function App() {\n  return (\n    <h1 suppressHydrationWarning={true}>\n      Current Date: {new Date().toLocaleDateString()}\n    </h1>\n  );\n}\n\n\n\nThis only works one level deep, and is intended to be an escape hatch. Don‚Äôt overuse it. React will not attempt to patch mismatched text content.\n\nHandling different client and server content \n\nIf you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a state variable like isClient, which you can set to true in an Effect:\n\nindex.js\nindex.html\nApp.js\nReload\nClear\nFork\nimport { useState, useEffect } from \"react\";\n\nexport default function App() {\n  const [isClient, setIsClient] = useState(false);\n\n  useEffect(() => {\n    setIsClient(true);\n  }, []);\n\n  return (\n    <h1>\n      {isClient ? 'Is Client' : 'Is Server'}\n    </h1>\n  );\n}\n\n\n\nThis way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration.\n\nPitfall\n\nThis approach makes hydration slower because your components have to render twice. Be mindful of the user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so rendering a different UI immediately after hydration may also feel jarring to the user.\n\nUpdating a hydrated root component \n\nAfter the root has finished hydrating, you can call root.render to update the root React component. Unlike with createRoot, you don‚Äôt usually need to do this because the initial content was already rendered as HTML.\n\nIf you call root.render at some point after hydration, and the component tree structure matches up with what was previously rendered, React will preserve the state. Notice how you can type in the input, which means that the updates from repeated render calls every second in this example are not destructive:\n\nindex.js\nindex.html\nApp.js\nReload\nClear\nFork\nimport { hydrateRoot } from 'react-dom/client';\nimport './styles.css';\nimport App from './App.js';\n\nconst root = hydrateRoot(\n  document.getElementById('root'),\n  <App counter={0} />\n);\n\nlet i = 0;\nsetInterval(() => {\n  root.render(<App counter={i} />);\n  i++;\n}, 1000);\n\n\n\nIt is uncommon to call root.render on a hydrated root. Usually, you‚Äôll update state inside one of the components instead.\n\nError logging in production \n\nBy default, React will log all errors to the console. To implement your own error reporting, you can provide the optional error handler root options onUncaughtError, onCaughtError and onRecoverableError:\n\nimport { hydrateRoot } from \"react-dom/client\";\n\nimport App from \"./App.js\";\n\nimport { reportCaughtError } from \"./reportError\";\n\n\n\nconst container = document.getElementById(\"root\");\n\nconst root = hydrateRoot(container, <App />, {\n\n  onCaughtError: (error, errorInfo) => {\n\n    if (error.message !== \"Known error\") {\n\n      reportCaughtError({\n\n        error,\n\n        componentStack: errorInfo.componentStack,\n\n      });\n\n    }\n\n  },\n\n});\n\nThe onCaughtError option is a function called with two arguments:\n\nThe error that was thrown.\nAn errorInfo object that contains the componentStack of the error.\n\nTogether with onUncaughtError and onRecoverableError, you can implement your own error reporting system:\n\nindex.js\nreportError.js\nApp.js\nReload\nClear\nFork\nimport { hydrateRoot } from \"react-dom/client\";\nimport App from \"./App.js\";\nimport {\n  onCaughtErrorProd,\n  onRecoverableErrorProd,\n  onUncaughtErrorProd,\n} from \"./reportError\";\n\nconst container = document.getElementById(\"root\");\nhydrateRoot(container, <App />, {\n  // Keep in mind to remove these options in development to leverage\n  // React's default handlers or implement your own overlay for development.\n  // The handlers are only specfied unconditionally here for demonstration purposes.\n  onCaughtError: onCaughtErrorProd,\n  onRecoverableError: onRecoverableErrorProd,\n  onUncaughtError: onUncaughtErrorProd,\n});\n\n\nShow more\nTroubleshooting \nI‚Äôm getting an error: ‚ÄúYou passed a second argument to root.render‚Äù \n\nA common mistake is to pass the options for hydrateRoot to root.render(...):\n\nConsole\nWarning: You passed a second argument to root.render(‚Ä¶) but it only accepts one argument.\n\nTo fix, pass the root options to hydrateRoot(...), not root.render(...):\n\n// üö© Wrong: root.render only takes one argument.\n\nroot.render(App, {onUncaughtError});\n\n\n\n// ‚úÖ Correct: pass options to createRoot.\n\nconst root = hydrateRoot(container, <App />, {onUncaughtError});\nPREVIOUS\ncreateRoot\nNEXT\nServer APIs"
  },
  {
    "title": "createRoot ‚Äì React",
    "url": "https://react.dev/reference/react-dom/client/createRoot",
    "html": "API REFERENCE\nCLIENT APIS\ncreateRoot\n\ncreateRoot lets you create a root to display React components inside a browser DOM node.\n\nconst root = createRoot(domNode, options?)\nReference\ncreateRoot(domNode, options?)\nroot.render(reactNode)\nroot.unmount()\nUsage\nRendering an app fully built with React\nRendering a page partially built with React\nUpdating a root component\nError logging in production\nTroubleshooting\nI‚Äôve created a root, but nothing is displayed\nI‚Äôm getting an error: ‚ÄúYou passed a second argument to root.render‚Äù\nI‚Äôm getting an error: ‚ÄúTarget container is not a DOM element‚Äù\nI‚Äôm getting an error: ‚ÄúFunctions are not valid as a React child.‚Äù\nMy server-rendered HTML gets re-created from scratch\nReference \ncreateRoot(domNode, options?) \n\nCall createRoot to create a React root for displaying content inside a browser DOM element.\n\nimport { createRoot } from 'react-dom/client';\n\n\n\nconst domNode = document.getElementById('root');\n\nconst root = createRoot(domNode);\n\nReact will create a root for the domNode, and take over managing the DOM inside it. After you‚Äôve created a root, you need to call root.render to display a React component inside of it:\n\nroot.render(<App />);\n\nAn app fully built with React will usually only have one createRoot call for its root component. A page that uses ‚Äúsprinkles‚Äù of React for parts of the page may have as many separate roots as needed.\n\nSee more examples below.\n\nParameters \n\ndomNode: A DOM element. React will create a root for this DOM element and allow you to call functions on the root, such as render to display rendered React content.\n\noptional options: An object with options for this React root.\n\noptional onCaughtError: Callback called when React catches an error in an Error Boundary. Called with the error caught by the Error Boundary, and an errorInfo object containing the componentStack.\noptional onUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with the error that was thrown, and an errorInfo object containing the componentStack.\noptional onRecoverableError: Callback called when React automatically recovers from errors. Called with an error React throws, and an errorInfo object containing the componentStack. Some recoverable errors may include the original error cause as error.cause.\noptional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page.\nReturns \n\ncreateRoot returns an object with two methods: render and unmount.\n\nCaveats \nIf your app is server-rendered, using createRoot() is not supported. Use hydrateRoot() instead.\nYou‚Äôll likely have only one createRoot call in your app. If you use a framework, it might do this call for you.\nWhen you want to render a piece of JSX in a different part of the DOM tree that isn‚Äôt a child of your component (for example, a modal or a tooltip), use createPortal instead of createRoot.\nroot.render(reactNode) \n\nCall root.render to display a piece of JSX (‚ÄúReact node‚Äù) into the React root‚Äôs browser DOM node.\n\nroot.render(<App />);\n\nReact will display <App /> in the root, and take over managing the DOM inside it.\n\nSee more examples below.\n\nParameters \nreactNode: A React node that you want to display. This will usually be a piece of JSX like <App />, but you can also pass a React element constructed with createElement(), a string, a number, null, or undefined.\nReturns \n\nroot.render returns undefined.\n\nCaveats \n\nThe first time you call root.render, React will clear all the existing HTML content inside the React root before rendering the React component into it.\n\nIf your root‚Äôs DOM node contains HTML generated by React on the server or during the build, use hydrateRoot() instead, which attaches the event handlers to the existing HTML.\n\nIf you call render on the same root more than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by ‚Äúmatching it up‚Äù with the previously rendered tree. Calling render on the same root again is similar to calling the set function on the root component: React avoids unnecessary DOM updates.\n\nAlthough rendering is synchronous once it starts, root.render(...) is not. This means code after root.render() may run before any effects (useLayoutEffect, useEffect) of that specific render are fired. This is usually fine and rarely needs adjustment. In rare cases where effect timing matters, you can wrap root.render(...) in flushSync to ensure the initial render runs fully synchronously.\n\nconst root = createRoot(document.getElementById('root'));\n\nroot.render(<App />);\n\n// üö© The HTML will not include the rendered <App /> yet:\n\nconsole.log(document.body.innerHTML);\nroot.unmount() \n\nCall root.unmount to destroy a rendered tree inside a React root.\n\nroot.unmount();\n\nAn app fully built with React will usually not have any calls to root.unmount.\n\nThis is mostly useful if your React root‚Äôs DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. In that case, you need to tell React to ‚Äústop‚Äù managing the removed root‚Äôs content by calling root.unmount. Otherwise, the components inside the removed root won‚Äôt know to clean up and free up global resources like subscriptions.\n\nCalling root.unmount will unmount all the components in the root and ‚Äúdetach‚Äù React from the root DOM node, including removing any event handlers or state in the tree.\n\nParameters \n\nroot.unmount does not accept any parameters.\n\nReturns \n\nroot.unmount returns undefined.\n\nCaveats \n\nCalling root.unmount will unmount all the components in the tree and ‚Äúdetach‚Äù React from the root DOM node.\n\nOnce you call root.unmount you cannot call root.render again on the same root. Attempting to call root.render on an unmounted root will throw a ‚ÄúCannot update an unmounted root‚Äù error. However, you can create a new root for the same DOM node after the previous root for that node has been unmounted.\n\nUsage \nRendering an app fully built with React \n\nIf your app is fully built with React, create a single root for your entire app.\n\nimport { createRoot } from 'react-dom/client';\n\n\n\nconst root = createRoot(document.getElementById('root'));\n\nroot.render(<App />);\n\nUsually, you only need to run this code once at startup. It will:\n\nFind the browser DOM node defined in your HTML.\nDisplay the React component for your app inside.\nindex.js\nindex.html\nApp.js\nReload\nClear\nFork\nimport { createRoot } from 'react-dom/client';\nimport App from './App.js';\nimport './styles.css';\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App />);\n\n\n\nIf your app is fully built with React, you shouldn‚Äôt need to create any more roots, or to call root.render again.\n\nFrom this point on, React will manage the DOM of your entire app. To add more components, nest them inside the App component. When you need to update the UI, each of your components can do this by using state. When you need to display extra content like a modal or a tooltip outside the DOM node, render it with a portal.\n\nNote\n\nWhen your HTML is empty, the user sees a blank page until the app‚Äôs JavaScript code loads and runs:\n\n<div id=\"root\"></div>\n\nThis can feel very slow! To solve this, you can generate the initial HTML from your components on the server or during the build. Then your visitors can read text, see images, and click links before any of the JavaScript code loads. We recommend using a framework that does this optimization out of the box. Depending on when it runs, this is called server-side rendering (SSR) or static site generation (SSG).\n\nPitfall\n\nApps using server rendering or static generation must call hydrateRoot instead of createRoot. React will then hydrate (reuse) the DOM nodes from your HTML instead of destroying and re-creating them.\n\nRendering a page partially built with React \n\nIf your page isn‚Äôt fully built with React, you can call createRoot multiple times to create a root for each top-level piece of UI managed by React. You can display different content in each root by calling root.render.\n\nHere, two different React components are rendered into two DOM nodes defined in the index.html file:\n\nindex.js\nindex.html\nComponents.js\nReload\nClear\nFork\nimport './styles.css';\nimport { createRoot } from 'react-dom/client';\nimport { Comments, Navigation } from './Components.js';\n\nconst navDomNode = document.getElementById('navigation');\nconst navRoot = createRoot(navDomNode); \nnavRoot.render(<Navigation />);\n\nconst commentDomNode = document.getElementById('comments');\nconst commentRoot = createRoot(commentDomNode); \ncommentRoot.render(<Comments />);\n\n\n\nYou could also create a new DOM node with document.createElement() and add it to the document manually.\n\nconst domNode = document.createElement('div');\n\nconst root = createRoot(domNode); \n\nroot.render(<Comment />);\n\ndocument.body.appendChild(domNode); // You can add it anywhere in the document\n\nTo remove the React tree from the DOM node and clean up all the resources used by it, call root.unmount.\n\nroot.unmount();\n\nThis is mostly useful if your React components are inside an app written in a different framework.\n\nUpdating a root component \n\nYou can call render more than once on the same root. As long as the component tree structure matches up with what was previously rendered, React will preserve the state. Notice how you can type in the input, which means that the updates from repeated render calls every second in this example are not destructive:\n\nindex.js\nApp.js\nReload\nClear\nFork\nimport { createRoot } from 'react-dom/client';\nimport './styles.css';\nimport App from './App.js';\n\nconst root = createRoot(document.getElementById('root'));\n\nlet i = 0;\nsetInterval(() => {\n  root.render(<App counter={i} />);\n  i++;\n}, 1000);\n\n\n\nIt is uncommon to call render multiple times. Usually, your components will update state instead.\n\nError logging in production \n\nBy default, React will log all errors to the console. To implement your own error reporting, you can provide the optional error handler root options onUncaughtError, onCaughtError and onRecoverableError:\n\nimport { createRoot } from \"react-dom/client\";\n\nimport { reportCaughtError } from \"./reportError\";\n\n\n\nconst container = document.getElementById(\"root\");\n\nconst root = createRoot(container, {\n\n  onCaughtError: (error, errorInfo) => {\n\n    if (error.message !== \"Known error\") {\n\n      reportCaughtError({\n\n        error,\n\n        componentStack: errorInfo.componentStack,\n\n      });\n\n    }\n\n  },\n\n});\n\nThe onCaughtError option is a function called with two arguments:\n\nThe error that was thrown.\nAn errorInfo object that contains the componentStack of the error.\n\nTogether with onUncaughtError and onRecoverableError, you can can implement your own error reporting system:\n\nindex.js\nreportError.js\nApp.js\nReload\nClear\nFork\nimport { createRoot } from \"react-dom/client\";\nimport App from \"./App.js\";\nimport {\n  onCaughtErrorProd,\n  onRecoverableErrorProd,\n  onUncaughtErrorProd,\n} from \"./reportError\";\n\nconst container = document.getElementById(\"root\");\nconst root = createRoot(container, {\n  // Keep in mind to remove these options in development to leverage\n  // React's default handlers or implement your own overlay for development.\n  // The handlers are only specfied unconditionally here for demonstration purposes.\n  onCaughtError: onCaughtErrorProd,\n  onRecoverableError: onRecoverableErrorProd,\n  onUncaughtError: onUncaughtErrorProd,\n});\nroot.render(<App />);\n\n\nShow more\nTroubleshooting \nI‚Äôve created a root, but nothing is displayed \n\nMake sure you haven‚Äôt forgotten to actually render your app into the root:\n\nimport { createRoot } from 'react-dom/client';\n\nimport App from './App.js';\n\n\n\nconst root = createRoot(document.getElementById('root'));\n\nroot.render(<App />);\n\nUntil you do that, nothing is displayed.\n\nI‚Äôm getting an error: ‚ÄúYou passed a second argument to root.render‚Äù \n\nA common mistake is to pass the options for createRoot to root.render(...):\n\nConsole\nWarning: You passed a second argument to root.render(‚Ä¶) but it only accepts one argument.\n\nTo fix, pass the root options to createRoot(...), not root.render(...):\n\n// üö© Wrong: root.render only takes one argument.\n\nroot.render(App, {onUncaughtError});\n\n\n\n// ‚úÖ Correct: pass options to createRoot.\n\nconst root = createRoot(container, {onUncaughtError}); \n\nroot.render(<App />);\nI‚Äôm getting an error: ‚ÄúTarget container is not a DOM element‚Äù \n\nThis error means that whatever you‚Äôre passing to createRoot is not a DOM node.\n\nIf you‚Äôre not sure what‚Äôs happening, try logging it:\n\nconst domNode = document.getElementById('root');\n\nconsole.log(domNode); // ???\n\nconst root = createRoot(domNode);\n\nroot.render(<App />);\n\nFor example, if domNode is null, it means that getElementById returned null. This will happen if there is no node in the document with the given ID at the time of your call. There may be a few reasons for it:\n\nThe ID you‚Äôre looking for might differ from the ID you used in the HTML file. Check for typos!\nYour bundle‚Äôs <script> tag cannot ‚Äúsee‚Äù any DOM nodes that appear after it in the HTML.\n\nAnother common way to get this error is to write createRoot(<App />) instead of createRoot(domNode).\n\nI‚Äôm getting an error: ‚ÄúFunctions are not valid as a React child.‚Äù \n\nThis error means that whatever you‚Äôre passing to root.render is not a React component.\n\nThis may happen if you call root.render with Component instead of <Component />:\n\n// üö© Wrong: App is a function, not a Component.\n\nroot.render(App);\n\n\n\n// ‚úÖ Correct: <App /> is a component.\n\nroot.render(<App />);\n\nOr if you pass a function to root.render, instead of the result of calling it:\n\n// üö© Wrong: createApp is a function, not a component.\n\nroot.render(createApp);\n\n\n\n// ‚úÖ Correct: call createApp to return a component.\n\nroot.render(createApp());\nMy server-rendered HTML gets re-created from scratch \n\nIf your app is server-rendered and includes the initial HTML generated by React, you might notice that creating a root and calling root.render deletes all that HTML, and then re-creates all the DOM nodes from scratch. This can be slower, resets focus and scroll positions, and may lose other user input.\n\nServer-rendered apps must use hydrateRoot instead of createRoot:\n\nimport { hydrateRoot } from 'react-dom/client';\n\nimport App from './App.js';\n\n\n\nhydrateRoot(\n\n  document.getElementById('root'),\n\n  <App />\n\n);\n\nNote that its API is different. In particular, usually there will be no further root.render call.\n\nPREVIOUS\nClient APIs\nNEXT\nhydrateRoot"
  },
  {
    "title": "Server React DOM APIs ‚Äì React",
    "url": "https://react.dev/reference/react-dom/server",
    "html": "API REFERENCE\nServer React DOM APIs\n\nThe react-dom/server APIs let you server-side render React components to HTML. These APIs are only used on the server at the top level of your app to generate the initial HTML. A framework may call them for you. Most of your components don‚Äôt need to import or use them.\n\nServer APIs for Web Streams \n\nThese methods are only available in the environments with Web Streams, which includes browsers, Deno, and some modern edge runtimes:\n\nrenderToReadableStream renders a React tree to a Readable Web Stream.\nresume resumes prerender to a Readable Web Stream.\nNote\n\nNode.js also includes these methods for compatibility, but they are not recommended due to worse performance. Use the dedicated Node.js APIs instead.\n\nServer APIs for Node.js Streams \n\nThese methods are only available in the environments with Node.js Streams:\n\nrenderToPipeableStream renders a React tree to a pipeable Node.js Stream.\nresumeToPipeableStream resumes prerenderToNodeStream to a pipeable Node.js Stream.\nLegacy Server APIs for non-streaming environments \n\nThese methods can be used in the environments that don‚Äôt support streams:\n\nrenderToString renders a React tree to a string.\nrenderToStaticMarkup renders a non-interactive React tree to a string.\n\nThey have limited functionality compared to the streaming APIs.\n\nPREVIOUS\nhydrateRoot\nNEXT\nrenderToPipeableStream"
  },
  {
    "title": "renderToPipeableStream ‚Äì React",
    "url": "https://react.dev/reference/react-dom/server/renderToPipeableStream",
    "html": "API REFERENCE\nSERVER APIS\nrenderToPipeableStream\n\nrenderToPipeableStream renders a React tree to a pipeable Node.js Stream.\n\nconst { pipe, abort } = renderToPipeableStream(reactNode, options?)\nReference\nrenderToPipeableStream(reactNode, options?)\nUsage\nRendering a React tree as HTML to a Node.js Stream\nStreaming more content as it loads\nSpecifying what goes into the shell\nLogging crashes on the server\nRecovering from errors inside the shell\nRecovering from errors outside the shell\nSetting the status code\nHandling different errors in different ways\nWaiting for all content to load for crawlers and static generation\nAborting server rendering\nNote\n\nThis API is specific to Node.js. Environments with Web Streams, like Deno and modern edge runtimes, should use renderToReadableStream instead.\n\nReference \nrenderToPipeableStream(reactNode, options?) \n\nCall renderToPipeableStream to render your React tree as HTML into a Node.js Stream.\n\nimport { renderToPipeableStream } from 'react-dom/server';\n\n\n\nconst { pipe } = renderToPipeableStream(<App />, {\n\n  bootstrapScripts: ['/main.js'],\n\n  onShellReady() {\n\n    response.setHeader('content-type', 'text/html');\n\n    pipe(response);\n\n  }\n\n});\n\nOn the client, call hydrateRoot to make the server-generated HTML interactive.\n\nSee more examples below.\n\nParameters \n\nreactNode: A React node you want to render to HTML. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.\n\noptional options: An object with streaming options.\n\noptional bootstrapScriptContent: If specified, this string will be placed in an inline <script> tag.\noptional bootstrapScripts: An array of string URLs for the <script> tags to emit on the page. Use this to include the <script> that calls hydrateRoot. Omit it if you don‚Äôt want to run React on the client at all.\noptional bootstrapModules: Like bootstrapScripts, but emits <script type=\"module\"> instead.\noptional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.\noptional namespaceURI: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass 'http://www.w3.org/2000/svg' for SVG or 'http://www.w3.org/1998/Math/MathML' for MathML.\noptional nonce: A nonce string to allow scripts for script-src Content-Security-Policy.\noptional onAllReady: A callback that fires when all rendering is complete, including both the shell and all additional content. You can use this instead of onShellReady for crawlers and static generation. If you start streaming here, you won‚Äôt get any progressive loading. The stream will contain the final HTML.\noptional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error. You can also use it to adjust the status code before the shell is emitted.\noptional onShellReady: A callback that fires right after the initial shell has been rendered. You can set the status code and call pipe here to start streaming. React will stream the additional content after the shell along with the inline <script> tags that replace the HTML loading fallbacks with the content.\noptional onShellError: A callback that fires if there was an error rendering the initial shell. It receives the error as an argument. No bytes were emitted from the stream yet, and neither onShellReady nor onAllReady will get called, so you can output a fallback HTML shell.\noptional progressiveChunkSize: The number of bytes in a chunk. Read more about the default heuristic.\nReturns \n\nrenderToPipeableStream returns an object with two methods:\n\npipe outputs the HTML into the provided Writable Node.js Stream. Call pipe in onShellReady if you want to enable streaming, or in onAllReady for crawlers and static generation.\nabort lets you abort server rendering and render the rest on the client.\nUsage \nRendering a React tree as HTML to a Node.js Stream \n\nCall renderToPipeableStream to render your React tree as HTML into a Node.js Stream:\n\nimport { renderToPipeableStream } from 'react-dom/server';\n\n\n\n// The route handler syntax depends on your backend framework\n\napp.use('/', (request, response) => {\n\n  const { pipe } = renderToPipeableStream(<App />, {\n\n    bootstrapScripts: ['/main.js'],\n\n    onShellReady() {\n\n      response.setHeader('content-type', 'text/html');\n\n      pipe(response);\n\n    }\n\n  });\n\n});\n\nAlong with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag.\n\nFor example, it might look like this:\n\nexport default function App() {\n\n  return (\n\n    <html>\n\n      <head>\n\n        <meta charSet=\"utf-8\" />\n\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\n        <link rel=\"stylesheet\" href=\"/styles.css\"></link>\n\n        <title>My app</title>\n\n      </head>\n\n      <body>\n\n        <Router />\n\n      </body>\n\n    </html>\n\n  );\n\n}\n\nReact will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:\n\n<!DOCTYPE html>\n\n<html>\n\n  <!-- ... HTML from your components ... -->\n\n</html>\n\n<script src=\"/main.js\" async=\"\"></script>\n\nOn the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:\n\nimport { hydrateRoot } from 'react-dom/client';\n\nimport App from './App.js';\n\n\n\nhydrateRoot(document, <App />);\n\nThis will attach event listeners to the server-generated HTML and make it interactive.\n\nDEEP DIVE\nReading CSS and JS asset paths from the build output \nShow Details\nStreaming more content as it loads \n\nStreaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Sidebar>\n\n        <Friends />\n\n        <Photos />\n\n      </Sidebar>\n\n      <Posts />\n\n    </ProfileLayout>\n\n  );\n\n}\n\nImagine that loading data for <Posts /> takes some time. Ideally, you‚Äôd want to show the rest of the profile page content to the user without waiting for the posts. To do this, wrap Posts in a <Suspense> boundary:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Sidebar>\n\n        <Friends />\n\n        <Photos />\n\n      </Sidebar>\n\n      <Suspense fallback={<PostsGlimmer />}>\n\n        <Posts />\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nThis tells React to start streaming the HTML before Posts loads its data. React will send the HTML for the loading fallback (PostsGlimmer) first, and then, when Posts finishes loading its data, React will send the remaining HTML along with an inline <script> tag that replaces the loading fallback with that HTML. From the user‚Äôs perspective, the page will first appear with the PostsGlimmer, later replaced by the Posts.\n\nYou can further nest <Suspense> boundaries to create a more granular loading sequence:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Suspense fallback={<BigSpinner />}>\n\n        <Sidebar>\n\n          <Friends />\n\n          <Photos />\n\n        </Sidebar>\n\n        <Suspense fallback={<PostsGlimmer />}>\n\n          <Posts />\n\n        </Suspense>\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nIn this example, React can start streaming the page even earlier. Only ProfileLayout and ProfileCover must finish rendering first because they are not wrapped in any <Suspense> boundary. However, if Sidebar, Friends, or Photos need to load some data, React will send the HTML for the BigSpinner fallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.\n\nStreaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the <script> tags load.\n\nRead more about how streaming HTML works.\n\nNote\n\nOnly Suspense-enabled data sources will activate the Suspense component. They include:\n\nData fetching with Suspense-enabled frameworks like Relay and Next.js\nLazy-loading component code with lazy\nReading the value of a Promise with use\n\nSuspense does not detect when data is fetched inside an Effect or event handler.\n\nThe exact way you would load data in the Posts component above depends on your framework. If you use a Suspense-enabled framework, you‚Äôll find the details in its data fetching documentation.\n\nSuspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.\n\nSpecifying what goes into the shell \n\nThe part of your app outside of any <Suspense> boundaries is called the shell:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Suspense fallback={<BigSpinner />}>\n\n        <Sidebar>\n\n          <Friends />\n\n          <Photos />\n\n        </Sidebar>\n\n        <Suspense fallback={<PostsGlimmer />}>\n\n          <Posts />\n\n        </Suspense>\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nIt determines the earliest loading state that the user may see:\n\n<ProfileLayout>\n\n  <ProfileCover />\n\n  <BigSpinner />\n\n</ProfileLayout>\n\nIf you wrap the whole app into a <Suspense> boundary at the root, the shell will only contain that spinner. However, that‚Äôs not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you‚Äôll want to place the <Suspense> boundaries so that the shell feels minimal but complete‚Äîlike a skeleton of the entire page layout.\n\nThe onShellReady callback fires when the entire shell has been rendered. Usually, you‚Äôll start streaming then:\n\nconst { pipe } = renderToPipeableStream(<App />, {\n\n  bootstrapScripts: ['/main.js'],\n\n  onShellReady() {\n\n    response.setHeader('content-type', 'text/html');\n\n    pipe(response);\n\n  }\n\n});\n\nBy the time onShellReady fires, components in nested <Suspense> boundaries might still be loading data.\n\nLogging crashes on the server \n\nBy default, all errors on the server are logged to console. You can override this behavior to log crash reports:\n\nconst { pipe } = renderToPipeableStream(<App />, {\n\n  bootstrapScripts: ['/main.js'],\n\n  onShellReady() {\n\n    response.setHeader('content-type', 'text/html');\n\n    pipe(response);\n\n  },\n\n  onError(error) {\n\n    console.error(error);\n\n    logServerCrashReport(error);\n\n  }\n\n});\n\nIf you provide a custom onError implementation, don‚Äôt forget to also log errors to the console like above.\n\nRecovering from errors inside the shell \n\nIn this example, the shell contains ProfileLayout, ProfileCover, and PostsGlimmer:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Suspense fallback={<PostsGlimmer />}>\n\n        <Posts />\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nIf an error occurs while rendering those components, React won‚Äôt have any meaningful HTML to send to the client. Override onShellError to send a fallback HTML that doesn‚Äôt rely on server rendering as the last resort:\n\nconst { pipe } = renderToPipeableStream(<App />, {\n\n  bootstrapScripts: ['/main.js'],\n\n  onShellReady() {\n\n    response.setHeader('content-type', 'text/html');\n\n    pipe(response);\n\n  },\n\n  onShellError(error) {\n\n    response.statusCode = 500;\n\n    response.setHeader('content-type', 'text/html');\n\n    response.send('<h1>Something went wrong</h1>'); \n\n  },\n\n  onError(error) {\n\n    console.error(error);\n\n    logServerCrashReport(error);\n\n  }\n\n});\n\nIf there is an error while generating the shell, both onError and onShellError will fire. Use onError for error reporting and use onShellError to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.\n\nRecovering from errors outside the shell \n\nIn this example, the <Posts /> component is wrapped in <Suspense> so it is not a part of the shell:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Suspense fallback={<PostsGlimmer />}>\n\n        <Posts />\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nIf an error happens in the Posts component or somewhere inside it, React will try to recover from it:\n\nIt will emit the loading fallback for the closest <Suspense> boundary (PostsGlimmer) into the HTML.\nIt will ‚Äúgive up‚Äù on trying to render the Posts content on the server anymore.\nWhen the JavaScript code loads on the client, React will retry rendering Posts on the client.\n\nIf retrying rendering Posts on the client also fails, React will throw the error on the client. As with all the errors thrown during rendering, the closest parent error boundary determines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.\n\nIf retrying rendering Posts on the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server onError callback and the client onRecoverableError callbacks will fire so that you can get notified about the error.\n\nSetting the status code \n\nStreaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.\n\nBy dividing your app into the shell (above all <Suspense> boundaries) and the rest of the content, you‚Äôve already solved a part of this problem. If the shell errors, you‚Äôll get the onShellError callback which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send ‚ÄúOK‚Äù.\n\nconst { pipe } = renderToPipeableStream(<App />, {\n\n  bootstrapScripts: ['/main.js'],\n\n  onShellReady() {\n\n    response.statusCode = 200;\n\n    response.setHeader('content-type', 'text/html');\n\n    pipe(response);\n\n  },\n\n  onShellError(error) {\n\n    response.statusCode = 500;\n\n    response.setHeader('content-type', 'text/html');\n\n    response.send('<h1>Something went wrong</h1>'); \n\n  },\n\n  onError(error) {\n\n    console.error(error);\n\n    logServerCrashReport(error);\n\n  }\n\n});\n\nIf a component outside the shell (i.e. inside a <Suspense> boundary) throws an error, React will not stop rendering. This means that the onError callback will fire, but you will still get onShellReady instead of onShellError. This is because React will try to recover from that error on the client, as described above.\n\nHowever, if you‚Äôd like, you can use the fact that something has errored to set the status code:\n\nlet didError = false;\n\n\n\nconst { pipe } = renderToPipeableStream(<App />, {\n\n  bootstrapScripts: ['/main.js'],\n\n  onShellReady() {\n\n    response.statusCode = didError ? 500 : 200;\n\n    response.setHeader('content-type', 'text/html');\n\n    pipe(response);\n\n  },\n\n  onShellError(error) {\n\n    response.statusCode = 500;\n\n    response.setHeader('content-type', 'text/html');\n\n    response.send('<h1>Something went wrong</h1>'); \n\n  },\n\n  onError(error) {\n\n    didError = true;\n\n    console.error(error);\n\n    logServerCrashReport(error);\n\n  }\n\n});\n\nThis will only catch errors outside the shell that happened while generating the initial shell content, so it‚Äôs not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.\n\nHandling different errors in different ways \n\nYou can create your own Error subclasses and use the instanceof operator to check which error is thrown. For example, you can define a custom NotFoundError and throw it from your component. Then your onError, onShellReady, and onShellError callbacks can do something different depending on the error type:\n\nlet didError = false;\n\nlet caughtError = null;\n\n\n\nfunction getStatusCode() {\n\n  if (didError) {\n\n    if (caughtError instanceof NotFoundError) {\n\n      return 404;\n\n    } else {\n\n      return 500;\n\n    }\n\n  } else {\n\n    return 200;\n\n  }\n\n}\n\n\n\nconst { pipe } = renderToPipeableStream(<App />, {\n\n  bootstrapScripts: ['/main.js'],\n\n  onShellReady() {\n\n    response.statusCode = getStatusCode();\n\n    response.setHeader('content-type', 'text/html');\n\n    pipe(response);\n\n  },\n\n  onShellError(error) {\n\n   response.statusCode = getStatusCode();\n\n   response.setHeader('content-type', 'text/html');\n\n   response.send('<h1>Something went wrong</h1>'); \n\n  },\n\n  onError(error) {\n\n    didError = true;\n\n    caughtError = error;\n\n    console.error(error);\n\n    logServerCrashReport(error);\n\n  }\n\n});\n\nKeep in mind that once you emit the shell and start streaming, you can‚Äôt change the status code.\n\nWaiting for all content to load for crawlers and static generation \n\nStreaming offers a better user experience because the user can see the content as it becomes available.\n\nHowever, when a crawler visits your page, or if you‚Äôre generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.\n\nYou can wait for all the content to load using the onAllReady callback:\n\nlet didError = false;\n\nlet isCrawler = // ... depends on your bot detection strategy ...\n\n\n\nconst { pipe } = renderToPipeableStream(<App />, {\n\n  bootstrapScripts: ['/main.js'],\n\n  onShellReady() {\n\n    if (!isCrawler) {\n\n      response.statusCode = didError ? 500 : 200;\n\n      response.setHeader('content-type', 'text/html');\n\n      pipe(response);\n\n    }\n\n  },\n\n  onShellError(error) {\n\n    response.statusCode = 500;\n\n    response.setHeader('content-type', 'text/html');\n\n    response.send('<h1>Something went wrong</h1>'); \n\n  },\n\n  onAllReady() {\n\n    if (isCrawler) {\n\n      response.statusCode = didError ? 500 : 200;\n\n      response.setHeader('content-type', 'text/html');\n\n      pipe(response);      \n\n    }\n\n  },\n\n  onError(error) {\n\n    didError = true;\n\n    console.error(error);\n\n    logServerCrashReport(error);\n\n  }\n\n});\n\nA regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for all data, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.\n\nAborting server rendering \n\nYou can force the server rendering to ‚Äúgive up‚Äù after a timeout:\n\nconst { pipe, abort } = renderToPipeableStream(<App />, {\n\n  // ...\n\n});\n\n\n\nsetTimeout(() => {\n\n  abort();\n\n}, 10000);\n\nReact will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client.\n\nPREVIOUS\nServer APIs\nNEXT\nrenderToReadableStream"
  },
  {
    "title": "renderToReadableStream ‚Äì React",
    "url": "https://react.dev/reference/react-dom/server/renderToReadableStream",
    "html": "API REFERENCE\nSERVER APIS\nrenderToReadableStream\n\nrenderToReadableStream renders a React tree to a Readable Web Stream.\n\nconst stream = await renderToReadableStream(reactNode, options?)\nReference\nrenderToReadableStream(reactNode, options?)\nUsage\nRendering a React tree as HTML to a Readable Web Stream\nStreaming more content as it loads\nSpecifying what goes into the shell\nLogging crashes on the server\nRecovering from errors inside the shell\nRecovering from errors outside the shell\nSetting the status code\nHandling different errors in different ways\nWaiting for all content to load for crawlers and static generation\nAborting server rendering\nNote\n\nThis API depends on Web Streams. For Node.js, use renderToPipeableStream instead.\n\nReference \nrenderToReadableStream(reactNode, options?) \n\nCall renderToReadableStream to render your React tree as HTML into a Readable Web Stream.\n\nimport { renderToReadableStream } from 'react-dom/server';\n\n\n\nasync function handler(request) {\n\n  const stream = await renderToReadableStream(<App />, {\n\n    bootstrapScripts: ['/main.js']\n\n  });\n\n  return new Response(stream, {\n\n    headers: { 'content-type': 'text/html' },\n\n  });\n\n}\n\nOn the client, call hydrateRoot to make the server-generated HTML interactive.\n\nSee more examples below.\n\nParameters \n\nreactNode: A React node you want to render to HTML. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.\n\noptional options: An object with streaming options.\n\noptional bootstrapScriptContent: If specified, this string will be placed in an inline <script> tag.\noptional bootstrapScripts: An array of string URLs for the <script> tags to emit on the page. Use this to include the <script> that calls hydrateRoot. Omit it if you don‚Äôt want to run React on the client at all.\noptional bootstrapModules: Like bootstrapScripts, but emits <script type=\"module\"> instead.\noptional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.\noptional namespaceURI: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass 'http://www.w3.org/2000/svg' for SVG or 'http://www.w3.org/1998/Math/MathML' for MathML.\noptional nonce: A nonce string to allow scripts for script-src Content-Security-Policy.\noptional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error. You can also use it to adjust the status code before the shell is emitted.\noptional progressiveChunkSize: The number of bytes in a chunk. Read more about the default heuristic.\noptional signal: An abort signal that lets you abort server rendering and render the rest on the client.\nReturns \n\nrenderToReadableStream returns a Promise:\n\nIf rendering the shell is successful, that Promise will resolve to a Readable Web Stream.\nIf rendering the shell fails, the Promise will be rejected. Use this to output a fallback shell.\n\nThe returned stream has an additional property:\n\nallReady: A Promise that resolves when all rendering is complete, including both the shell and all additional content. You can await stream.allReady before returning a response for crawlers and static generation. If you do that, you won‚Äôt get any progressive loading. The stream will contain the final HTML.\nUsage \nRendering a React tree as HTML to a Readable Web Stream \n\nCall renderToReadableStream to render your React tree as HTML into a Readable Web Stream:\n\nimport { renderToReadableStream } from 'react-dom/server';\n\n\n\nasync function handler(request) {\n\n  const stream = await renderToReadableStream(<App />, {\n\n    bootstrapScripts: ['/main.js']\n\n  });\n\n  return new Response(stream, {\n\n    headers: { 'content-type': 'text/html' },\n\n  });\n\n}\n\nAlong with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag.\n\nFor example, it might look like this:\n\nexport default function App() {\n\n  return (\n\n    <html>\n\n      <head>\n\n        <meta charSet=\"utf-8\" />\n\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\n        <link rel=\"stylesheet\" href=\"/styles.css\"></link>\n\n        <title>My app</title>\n\n      </head>\n\n      <body>\n\n        <Router />\n\n      </body>\n\n    </html>\n\n  );\n\n}\n\nReact will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:\n\n<!DOCTYPE html>\n\n<html>\n\n  <!-- ... HTML from your components ... -->\n\n</html>\n\n<script src=\"/main.js\" async=\"\"></script>\n\nOn the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:\n\nimport { hydrateRoot } from 'react-dom/client';\n\nimport App from './App.js';\n\n\n\nhydrateRoot(document, <App />);\n\nThis will attach event listeners to the server-generated HTML and make it interactive.\n\nDEEP DIVE\nReading CSS and JS asset paths from the build output \nShow Details\nStreaming more content as it loads \n\nStreaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Sidebar>\n\n        <Friends />\n\n        <Photos />\n\n      </Sidebar>\n\n      <Posts />\n\n    </ProfileLayout>\n\n  );\n\n}\n\nImagine that loading data for <Posts /> takes some time. Ideally, you‚Äôd want to show the rest of the profile page content to the user without waiting for the posts. To do this, wrap Posts in a <Suspense> boundary:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Sidebar>\n\n        <Friends />\n\n        <Photos />\n\n      </Sidebar>\n\n      <Suspense fallback={<PostsGlimmer />}>\n\n        <Posts />\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nThis tells React to start streaming the HTML before Posts loads its data. React will send the HTML for the loading fallback (PostsGlimmer) first, and then, when Posts finishes loading its data, React will send the remaining HTML along with an inline <script> tag that replaces the loading fallback with that HTML. From the user‚Äôs perspective, the page will first appear with the PostsGlimmer, later replaced by the Posts.\n\nYou can further nest <Suspense> boundaries to create a more granular loading sequence:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Suspense fallback={<BigSpinner />}>\n\n        <Sidebar>\n\n          <Friends />\n\n          <Photos />\n\n        </Sidebar>\n\n        <Suspense fallback={<PostsGlimmer />}>\n\n          <Posts />\n\n        </Suspense>\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nIn this example, React can start streaming the page even earlier. Only ProfileLayout and ProfileCover must finish rendering first because they are not wrapped in any <Suspense> boundary. However, if Sidebar, Friends, or Photos need to load some data, React will send the HTML for the BigSpinner fallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.\n\nStreaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the <script> tags load.\n\nRead more about how streaming HTML works.\n\nNote\n\nOnly Suspense-enabled data sources will activate the Suspense component. They include:\n\nData fetching with Suspense-enabled frameworks like Relay and Next.js\nLazy-loading component code with lazy\nReading the value of a Promise with use\n\nSuspense does not detect when data is fetched inside an Effect or event handler.\n\nThe exact way you would load data in the Posts component above depends on your framework. If you use a Suspense-enabled framework, you‚Äôll find the details in its data fetching documentation.\n\nSuspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.\n\nSpecifying what goes into the shell \n\nThe part of your app outside of any <Suspense> boundaries is called the shell:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Suspense fallback={<BigSpinner />}>\n\n        <Sidebar>\n\n          <Friends />\n\n          <Photos />\n\n        </Sidebar>\n\n        <Suspense fallback={<PostsGlimmer />}>\n\n          <Posts />\n\n        </Suspense>\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nIt determines the earliest loading state that the user may see:\n\n<ProfileLayout>\n\n  <ProfileCover />\n\n  <BigSpinner />\n\n</ProfileLayout>\n\nIf you wrap the whole app into a <Suspense> boundary at the root, the shell will only contain that spinner. However, that‚Äôs not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you‚Äôll want to place the <Suspense> boundaries so that the shell feels minimal but complete‚Äîlike a skeleton of the entire page layout.\n\nThe async call to renderToReadableStream will resolve to a stream as soon as the entire shell has been rendered. Usually, you‚Äôll start streaming then by creating and returning a response with that stream:\n\nasync function handler(request) {\n\n  const stream = await renderToReadableStream(<App />, {\n\n    bootstrapScripts: ['/main.js']\n\n  });\n\n  return new Response(stream, {\n\n    headers: { 'content-type': 'text/html' },\n\n  });\n\n}\n\nBy the time the stream is returned, components in nested <Suspense> boundaries might still be loading data.\n\nLogging crashes on the server \n\nBy default, all errors on the server are logged to console. You can override this behavior to log crash reports:\n\nasync function handler(request) {\n\n  const stream = await renderToReadableStream(<App />, {\n\n    bootstrapScripts: ['/main.js'],\n\n    onError(error) {\n\n      console.error(error);\n\n      logServerCrashReport(error);\n\n    }\n\n  });\n\n  return new Response(stream, {\n\n    headers: { 'content-type': 'text/html' },\n\n  });\n\n}\n\nIf you provide a custom onError implementation, don‚Äôt forget to also log errors to the console like above.\n\nRecovering from errors inside the shell \n\nIn this example, the shell contains ProfileLayout, ProfileCover, and PostsGlimmer:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Suspense fallback={<PostsGlimmer />}>\n\n        <Posts />\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nIf an error occurs while rendering those components, React won‚Äôt have any meaningful HTML to send to the client. Wrap your renderToReadableStream call in a try...catch to send a fallback HTML that doesn‚Äôt rely on server rendering as the last resort:\n\nasync function handler(request) {\n\n  try {\n\n    const stream = await renderToReadableStream(<App />, {\n\n      bootstrapScripts: ['/main.js'],\n\n      onError(error) {\n\n        console.error(error);\n\n        logServerCrashReport(error);\n\n      }\n\n    });\n\n    return new Response(stream, {\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  } catch (error) {\n\n    return new Response('<h1>Something went wrong</h1>', {\n\n      status: 500,\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  }\n\n}\n\nIf there is an error while generating the shell, both onError and your catch block will fire. Use onError for error reporting and use the catch block to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.\n\nRecovering from errors outside the shell \n\nIn this example, the <Posts /> component is wrapped in <Suspense> so it is not a part of the shell:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Suspense fallback={<PostsGlimmer />}>\n\n        <Posts />\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nIf an error happens in the Posts component or somewhere inside it, React will try to recover from it:\n\nIt will emit the loading fallback for the closest <Suspense> boundary (PostsGlimmer) into the HTML.\nIt will ‚Äúgive up‚Äù on trying to render the Posts content on the server anymore.\nWhen the JavaScript code loads on the client, React will retry rendering Posts on the client.\n\nIf retrying rendering Posts on the client also fails, React will throw the error on the client. As with all the errors thrown during rendering, the closest parent error boundary determines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.\n\nIf retrying rendering Posts on the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server onError callback and the client onRecoverableError callbacks will fire so that you can get notified about the error.\n\nSetting the status code \n\nStreaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.\n\nBy dividing your app into the shell (above all <Suspense> boundaries) and the rest of the content, you‚Äôve already solved a part of this problem. If the shell errors, your catch block will run which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send ‚ÄúOK‚Äù.\n\nasync function handler(request) {\n\n  try {\n\n    const stream = await renderToReadableStream(<App />, {\n\n      bootstrapScripts: ['/main.js'],\n\n      onError(error) {\n\n        console.error(error);\n\n        logServerCrashReport(error);\n\n      }\n\n    });\n\n    return new Response(stream, {\n\n      status: 200,\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  } catch (error) {\n\n    return new Response('<h1>Something went wrong</h1>', {\n\n      status: 500,\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  }\n\n}\n\nIf a component outside the shell (i.e. inside a <Suspense> boundary) throws an error, React will not stop rendering. This means that the onError callback will fire, but your code will continue running without getting into the catch block. This is because React will try to recover from that error on the client, as described above.\n\nHowever, if you‚Äôd like, you can use the fact that something has errored to set the status code:\n\nasync function handler(request) {\n\n  try {\n\n    let didError = false;\n\n    const stream = await renderToReadableStream(<App />, {\n\n      bootstrapScripts: ['/main.js'],\n\n      onError(error) {\n\n        didError = true;\n\n        console.error(error);\n\n        logServerCrashReport(error);\n\n      }\n\n    });\n\n    return new Response(stream, {\n\n      status: didError ? 500 : 200,\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  } catch (error) {\n\n    return new Response('<h1>Something went wrong</h1>', {\n\n      status: 500,\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  }\n\n}\n\nThis will only catch errors outside the shell that happened while generating the initial shell content, so it‚Äôs not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.\n\nHandling different errors in different ways \n\nYou can create your own Error subclasses and use the instanceof operator to check which error is thrown. For example, you can define a custom NotFoundError and throw it from your component. Then you can save the error in onError and do something different before returning the response depending on the error type:\n\nasync function handler(request) {\n\n  let didError = false;\n\n  let caughtError = null;\n\n\n\n  function getStatusCode() {\n\n    if (didError) {\n\n      if (caughtError instanceof NotFoundError) {\n\n        return 404;\n\n      } else {\n\n        return 500;\n\n      }\n\n    } else {\n\n      return 200;\n\n    }\n\n  }\n\n\n\n  try {\n\n    const stream = await renderToReadableStream(<App />, {\n\n      bootstrapScripts: ['/main.js'],\n\n      onError(error) {\n\n        didError = true;\n\n        caughtError = error;\n\n        console.error(error);\n\n        logServerCrashReport(error);\n\n      }\n\n    });\n\n    return new Response(stream, {\n\n      status: getStatusCode(),\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  } catch (error) {\n\n    return new Response('<h1>Something went wrong</h1>', {\n\n      status: getStatusCode(),\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  }\n\n}\n\nKeep in mind that once you emit the shell and start streaming, you can‚Äôt change the status code.\n\nWaiting for all content to load for crawlers and static generation \n\nStreaming offers a better user experience because the user can see the content as it becomes available.\n\nHowever, when a crawler visits your page, or if you‚Äôre generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.\n\nYou can wait for all the content to load by awaiting the stream.allReady Promise:\n\nasync function handler(request) {\n\n  try {\n\n    let didError = false;\n\n    const stream = await renderToReadableStream(<App />, {\n\n      bootstrapScripts: ['/main.js'],\n\n      onError(error) {\n\n        didError = true;\n\n        console.error(error);\n\n        logServerCrashReport(error);\n\n      }\n\n    });\n\n    let isCrawler = // ... depends on your bot detection strategy ...\n\n    if (isCrawler) {\n\n      await stream.allReady;\n\n    }\n\n    return new Response(stream, {\n\n      status: didError ? 500 : 200,\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  } catch (error) {\n\n    return new Response('<h1>Something went wrong</h1>', {\n\n      status: 500,\n\n      headers: { 'content-type': 'text/html' },\n\n    });\n\n  }\n\n}\n\nA regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for all data, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.\n\nAborting server rendering \n\nYou can force the server rendering to ‚Äúgive up‚Äù after a timeout:\n\nasync function handler(request) {\n\n  try {\n\n    const controller = new AbortController();\n\n    setTimeout(() => {\n\n      controller.abort();\n\n    }, 10000);\n\n\n\n    const stream = await renderToReadableStream(<App />, {\n\n      signal: controller.signal,\n\n      bootstrapScripts: ['/main.js'],\n\n      onError(error) {\n\n        didError = true;\n\n        console.error(error);\n\n        logServerCrashReport(error);\n\n      }\n\n    });\n\n    // ...\n\nReact will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client.\n\nPREVIOUS\nrenderToPipeableStream\nNEXT\nrenderToStaticMarkup"
  },
  {
    "title": "renderToStaticMarkup ‚Äì React",
    "url": "https://react.dev/reference/react-dom/server/renderToStaticMarkup",
    "html": "API REFERENCE\nSERVER APIS\nrenderToStaticMarkup\n\nrenderToStaticMarkup renders a non-interactive React tree to an HTML string.\n\nconst html = renderToStaticMarkup(reactNode, options?)\nReference\nrenderToStaticMarkup(reactNode, options?)\nUsage\nRendering a non-interactive React tree as HTML to a string\nReference \nrenderToStaticMarkup(reactNode, options?) \n\nOn the server, call renderToStaticMarkup to render your app to HTML.\n\nimport { renderToStaticMarkup } from 'react-dom/server';\n\n\n\nconst html = renderToStaticMarkup(<Page />);\n\nIt will produce non-interactive HTML output of your React components.\n\nSee more examples below.\n\nParameters \nreactNode: A React node you want to render to HTML. For example, a JSX node like <Page />.\noptional options: An object for server render.\noptional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page.\nReturns \n\nAn HTML string.\n\nCaveats \n\nrenderToStaticMarkup output cannot be hydrated.\n\nrenderToStaticMarkup has limited Suspense support. If a component suspends, renderToStaticMarkup immediately sends its fallback as HTML.\n\nrenderToStaticMarkup works in the browser, but using it in the client code is not recommended. If you need to render a component to HTML in the browser, get the HTML by rendering it into a DOM node.\n\nUsage \nRendering a non-interactive React tree as HTML to a string \n\nCall renderToStaticMarkup to render your app to an HTML string which you can send with your server response:\n\nimport { renderToStaticMarkup } from 'react-dom/server';\n\n\n\n// The route handler syntax depends on your backend framework\n\napp.use('/', (request, response) => {\n\n  const html = renderToStaticMarkup(<Page />);\n\n  response.send(html);\n\n});\n\nThis will produce the initial non-interactive HTML output of your React components.\n\nPitfall\n\nThis method renders non-interactive HTML that cannot be hydrated.  This is useful if you want to use React as a simple static page generator, or if you‚Äôre rendering completely static content like emails.\n\nInteractive apps should use renderToString on the server and hydrateRoot on the client.\n\nPREVIOUS\nrenderToReadableStream\nNEXT\nrenderToString"
  },
  {
    "title": "renderToString ‚Äì React",
    "url": "https://react.dev/reference/react-dom/server/renderToString",
    "html": "API REFERENCE\nSERVER APIS\nrenderToString\nPitfall\n\nrenderToString does not support streaming or waiting for data. See the alternatives.\n\nrenderToString renders a React tree to an HTML string.\n\nconst html = renderToString(reactNode, options?)\nReference\nrenderToString(reactNode, options?)\nUsage\nRendering a React tree as HTML to a string\nAlternatives\nMigrating from renderToString to a streaming render on the server\nMigrating from renderToString to a static prerender on the server\nRemoving renderToString from the client code\nTroubleshooting\nWhen a component suspends, the HTML always contains a fallback\nReference \nrenderToString(reactNode, options?) \n\nOn the server, call renderToString to render your app to HTML.\n\nimport { renderToString } from 'react-dom/server';\n\n\n\nconst html = renderToString(<App />);\n\nOn the client, call hydrateRoot to make the server-generated HTML interactive.\n\nSee more examples below.\n\nParameters \n\nreactNode: A React node you want to render to HTML. For example, a JSX node like <App />.\n\noptional options: An object for server render.\n\noptional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.\nReturns \n\nAn HTML string.\n\nCaveats \n\nrenderToString has limited Suspense support. If a component suspends, renderToString immediately sends its fallback as HTML.\n\nrenderToString works in the browser, but using it in the client code is not recommended.\n\nUsage \nRendering a React tree as HTML to a string \n\nCall renderToString to render your app to an HTML string which you can send with your server response:\n\nimport { renderToString } from 'react-dom/server';\n\n\n\n// The route handler syntax depends on your backend framework\n\napp.use('/', (request, response) => {\n\n  const html = renderToString(<App />);\n\n  response.send(html);\n\n});\n\nThis will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot to hydrate that server-generated HTML and make it interactive.\n\nPitfall\n\nrenderToString does not support streaming or waiting for data. See the alternatives.\n\nAlternatives \nMigrating from renderToString to a streaming render on the server \n\nrenderToString returns a string immediately, so it does not support streaming content as it loads.\n\nWhen possible, we recommend using these fully-featured alternatives:\n\nIf you use Node.js, use renderToPipeableStream.\nIf you use Deno or a modern edge runtime with Web Streams, use renderToReadableStream.\n\nYou can continue using renderToString if your server environment does not support streams.\n\nMigrating from renderToString to a static prerender on the server \n\nrenderToString returns a string immediately, so it does not support waiting for data to load for static HTML generation.\n\nWe recommend using these fully-featured alternatives:\n\nIf you use Node.js, use prerenderToNodeStream.\nIf you use Deno or a modern edge runtime with Web Streams, use prerender.\n\nYou can continue using renderToString if your static site generation environment does not support streams.\n\nRemoving renderToString from the client code \n\nSometimes, renderToString is used on the client to convert some component to HTML.\n\n// üö© Unnecessary: using renderToString on the client\n\nimport { renderToString } from 'react-dom/server';\n\n\n\nconst html = renderToString(<MyIcon />);\n\nconsole.log(html); // For example, \"<svg>...</svg>\"\n\nImporting react-dom/server on the client unnecessarily increases your bundle size and should be avoided. If you need to render some component to HTML in the browser, use createRoot and read HTML from the DOM:\n\nimport { createRoot } from 'react-dom/client';\n\nimport { flushSync } from 'react-dom';\n\n\n\nconst div = document.createElement('div');\n\nconst root = createRoot(div);\n\nflushSync(() => {\n\n  root.render(<MyIcon />);\n\n});\n\nconsole.log(div.innerHTML); // For example, \"<svg>...</svg>\"\n\nThe flushSync call is necessary so that the DOM is updated before reading its innerHTML property.\n\nTroubleshooting \nWhen a component suspends, the HTML always contains a fallback \n\nrenderToString does not fully support Suspense.\n\nIf some component suspends (for example, because it‚Äôs defined with lazy or fetches data), renderToString will not wait for its content to resolve. Instead, renderToString will find the closest <Suspense> boundary above it and render its fallback prop in the HTML. The content will not appear until the client code loads.\n\nTo solve this, use one of the recommended streaming solutions. For server side rendering, they can stream content in chunks as it resolves on the server so that the user sees the page being progressively filled in before the client code loads. For static site generation, they can wait for all the content to resolve before generating the static HTML.\n\nPREVIOUS\nrenderToStaticMarkup\nNEXT\nresume"
  },
  {
    "title": "resume ‚Äì React",
    "url": "https://react.dev/reference/react-dom/server/resume",
    "html": "API REFERENCE\nSERVER APIS\nresume\n\nresume streams a pre-rendered React tree to a Readable Web Stream.\n\nconst stream = await resume(reactNode, postponedState, options?)\nReference\nresume(node, postponedState, options?)\nUsage\nResuming a prerender\nFurther reading\nNote\n\nThis API depends on Web Streams. For Node.js, use resumeToNodeStream instead.\n\nReference \nresume(node, postponedState, options?) \n\nCall resume to resume rendering a pre-rendered React tree as HTML into a Readable Web Stream.\n\nimport { resume } from 'react-dom/server';\n\nimport {getPostponedState} from './storage';\n\n\n\nasync function handler(request, writable) {\n\n  const postponed = await getPostponedState(request);\n\n  const resumeStream = await resume(<App />, postponed);\n\n  return resumeStream.pipeTo(writable)\n\n}\n\nSee more examples below.\n\nParameters \nreactNode: The React node you called prerender with. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.\npostponedState: The opaque postpone object returned from a prerender API, loaded from wherever you stored it (e.g. redis, a file, or S3).\noptional options: An object with streaming options.\noptional nonce: A nonce string to allow scripts for script-src Content-Security-Policy.\noptional signal: An abort signal that lets you abort server rendering and render the rest on the client.\noptional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error.\nReturns \n\nresume returns a Promise:\n\nIf resume successfully produced a shell, that Promise will resolve to a Readable Web Stream. that can be piped to a Writable Web Stream..\nIf an error happens in the shell, the Promise will reject with that error.\n\nThe returned stream has an additional property:\n\nallReady: A Promise that resolves when all rendering is complete. You can await stream.allReady before returning a response for crawlers and static generation. If you do that, you won‚Äôt get any progressive loading. The stream will contain the final HTML.\nCaveats \nresume does not accept options for bootstrapScripts, bootstrapScriptContent, or bootstrapModules. Instead, you need to pass these options to the prerender call that generates the postponedState. You can also inject bootstrap content into the writable stream manually.\nresume does not accept identifierPrefix since the prefix needs to be the same in both prerender and resume.\nSince nonce cannot be provided to prerender, you should only provide nonce to resume if you‚Äôre not providing scripts to prerender.\nresume re-renders from the root until it finds a component that was not fully pre-rendered. Only fully prerendered Components (the Component and its children finished prerendering) are skipped entirely.\nUsage \nResuming a prerender \nindex.js\nindex.html\ndemo-helpers.js\nReload\nClear\nFork\nimport {\n  flushReadableStreamToFrame,\n  getUser,\n  Postponed,\n  sleep,\n} from \"./demo-helpers\";\nimport { StrictMode, Suspense, use, useEffect } from \"react\";\nimport { prerender } from \"react-dom/static\";\nimport { resume } from \"react-dom/server\";\nimport { hydrateRoot } from \"react-dom/client\";\n\nfunction Header() {\n  return <header>Me and my descendants can be prerendered</header>;\n}\n\nconst { promise: cookies, resolve: resolveCookies } = Promise.withResolvers();\n\nfunction Main() {\n  const { sessionID } = use(cookies);\n  const user = getUser(sessionID);\n\n  useEffect(() => {\n    console.log(\"reached interactivity!\");\n  }, []);\n\n  return (\n    <main>\n      Hello, {user.name}!\n      <button onClick={() => console.log(\"hydrated!\")}>\n        Clicking me requires hydration.\n      </button>\n    </main>\n  );\n}\n\nfunction Shell({ children }) {\n  // In a real app, this is where you would put your html and body.\n  // We're just using tags here we can include in an existing body for demonstration purposes\n  return (\n    <html>\n      <body>{children}</body>\n    </html>\n  );\n}\n\nfunction App() {\n  return (\n    <Shell>\n      <Suspense fallback=\"loading header\">\n        <Header />\n      </Suspense>\n      <Suspense fallback=\"loading main\">\n        <Main />\n      </Suspense>\n    </Shell>\n  );\n}\n\nasync function main(frame) {\n  // Layer 1\n  const controller = new AbortController();\n  const prerenderedApp = prerender(<App />, {\n    signal: controller.signal,\n    onError(error) {\n      if (error instanceof Postponed) {\n      } else {\n        console.error(error);\n      }\n    },\n  });\n  // We're immediately aborting in a macrotask.\n  // Any data fetching that's not available synchronously, or in a microtask, will not have finished.\n  setTimeout(() => {\n    controller.abort(new Postponed());\n  });\n\n  const { prelude, postponed } = await prerenderedApp;\n  await flushReadableStreamToFrame(prelude, frame);\n\n  // Layer 2\n  // Just waiting here for demonstration purposes.\n  // In a real app, the prelude and postponed state would've been serialized in Layer 1 and Layer would deserialize them.\n  // The prelude content could be flushed immediated as plain HTML while\n  // React is continuing to render from where the prerender left off.\n  await sleep(2000);\n\n  // You would get the cookies from the incoming HTTP request\n  resolveCookies({ sessionID: \"abc\" });\n\n  const stream = await resume(<App />, postponed);\n\n  await flushReadableStreamToFrame(stream, frame);\n\n  // Layer 3\n  // Just waiting here for demonstration purposes.\n  await sleep(2000);\n\n  hydrateRoot(frame.contentWindow.document, <App />);\n}\n\nmain(document.getElementById(\"container\"));\n\n\nShow more\nFurther reading \n\nResuming behaves like renderToReadableStream. For more examples, check out the usage section of renderToReadableStream.\nThe usage section of prerender includes examples of how to use prerender specifically.\n\nPREVIOUS\nrenderToString\nNEXT\nresumeToPipeableStream"
  },
  {
    "title": "resumeToPipeableStream ‚Äì React",
    "url": "https://react.dev/reference/react-dom/server/resumeToPipeableStream",
    "html": "API REFERENCE\nSERVER APIS\nresumeToPipeableStream\n\nresumeToPipeableStream streams a pre-rendered React tree  to a pipeable Node.js Stream.\n\nconst {pipe, abort} = await resumeToPipeableStream(reactNode, postponedState, options?)\nReference\nresumeToPipeableStream(node, postponed, options?)\nUsage\nFurther reading\nNote\n\nThis API is specific to Node.js. Environments with Web Streams, like Deno and modern edge runtimes, should use resume instead.\n\nReference \nresumeToPipeableStream(node, postponed, options?) \n\nCall resume to resume rendering a pre-rendered React tree as HTML into a Node.js Stream.\n\nimport { resume } from 'react-dom/server';\n\nimport {getPostponedState} from './storage';\n\n\n\nasync function handler(request, response) {\n\n  const postponed = await getPostponedState(request);\n\n  const {pipe} = resumeToPipeableStream(<App />, postponed, {\n\n    onShellReady: () => {\n\n      pipe(response);\n\n    }\n\n  });\n\n}\n\nSee more examples below.\n\nParameters \nreactNode: The React node you called prerender with. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.\npostponedState: The opaque postpone object returned from a prerender API, loaded from wherever you stored it (e.g. redis, a file, or S3).\noptional options: An object with streaming options.\noptional nonce: A nonce string to allow scripts for script-src Content-Security-Policy.\noptional signal: An abort signal that lets you abort server rendering and render the rest on the client.\noptional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error.\noptional onShellReady: A callback that fires right after the shell has finished. You can call pipe here to start streaming. React will stream the additional content after the shell along with the inline <script> tags that replace the HTML loading fallbacks with the content.\noptional onShellError: A callback that fires if there was an error rendering the shell. It receives the error as an argument. No bytes were emitted from the stream yet, and neither onShellReady nor onAllReady will get called, so you can output a fallback HTML shell or use the prelude.\nReturns \n\nresume returns an object with two methods:\n\npipe outputs the HTML into the provided Writable Node.js Stream. Call pipe in onShellReady if you want to enable streaming, or in onAllReady for crawlers and static generation.\nabort lets you abort server rendering and render the rest on the client.\nCaveats \nresumeToPipeableStream does not accept options for bootstrapScripts, bootstrapScriptContent, or bootstrapModules. Instead, you need to pass these options to the prerender call that generates the postponedState. You can also inject bootstrap content into the writable stream manually.\nresumeToPipeableStream does not accept identifierPrefix since the prefix needs to be the same in both prerender and resumeToPipeableStream.\nSince nonce cannot be provided to prerender, you should only provide nonce to resumeToPipeableStream if you‚Äôre not providing scripts to prerender.\nresumeToPipeableStream re-renders from the root until it finds a component that was not fully pre-rendered. Only fully prerendered Components (the Component and its children finished prerendering) are skipped entirely.\nUsage \nFurther reading \n\nResuming behaves like renderToReadableStream. For more examples, check out the usage section of renderToReadableStream.\nThe usage section of prerender includes examples of how to use prerenderToNodeStream specifically.\n\nPREVIOUS\nresume\nNEXT\nStatic APIs"
  },
  {
    "title": "Static React DOM APIs ‚Äì React",
    "url": "https://react.dev/reference/react-dom/static",
    "html": "API REFERENCE\nStatic React DOM APIs\n\nThe react-dom/static APIs let you generate static HTML for React components. They have limited functionality compared to the streaming APIs. A framework may call them for you. Most of your components don‚Äôt need to import or use them.\n\nStatic APIs for Web Streams \n\nThese methods are only available in the environments with Web Streams, which includes browsers, Deno, and some modern edge runtimes:\n\nprerender renders a React tree to static HTML with a Readable Web Stream.\nExperimental only resumeAndPrerender continues a prerendered React tree to static HTML with a Readable Web Stream.\n\nNode.js also includes these methods for compatibility, but they are not recommended due to worse performance. Use the dedicated Node.js APIs instead.\n\nStatic APIs for Node.js Streams \n\nThese methods are only available in the environments with Node.js Streams:\n\nprerenderToNodeStream renders a React tree to static HTML with a Node.js Stream.\nExperimental only resumeAndPrerenderToNodeStream continues a prerendered React tree to static HTML with a Node.js Stream.\nPREVIOUS\nresumeToPipeableStream\nNEXT\nprerender"
  },
  {
    "title": "prerender ‚Äì React",
    "url": "https://react.dev/reference/react-dom/static/prerender",
    "html": "API REFERENCE\nSTATIC APIS\nprerender\n\nprerender renders a React tree to a static HTML string using a Web Stream.\n\nconst {prelude, postponed} = await prerender(reactNode, options?)\nReference\nprerender(reactNode, options?)\nUsage\nRendering a React tree to a stream of static HTML\nRendering a React tree to a string of static HTML\nWaiting for all data to load\nAborting prerendering\nTroubleshooting\nMy stream doesn‚Äôt start until the entire app is rendered\nNote\n\nThis API depends on Web Streams. For Node.js, use prerenderToNodeStream instead.\n\nReference \nprerender(reactNode, options?) \n\nCall prerender to render your app to static HTML.\n\nimport { prerender } from 'react-dom/static';\n\n\n\nasync function handler(request, response) {\n\n  const {prelude} = await prerender(<App />, {\n\n    bootstrapScripts: ['/main.js']\n\n  });\n\n  return new Response(prelude, {\n\n    headers: { 'content-type': 'text/html' },\n\n  });\n\n}\n\nOn the client, call hydrateRoot to make the server-generated HTML interactive.\n\nSee more examples below.\n\nParameters \n\nreactNode: A React node you want to render to HTML. For example, a JSX node like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.\n\noptional options: An object with static generation options.\n\noptional bootstrapScriptContent: If specified, this string will be placed in an inline <script> tag.\noptional bootstrapScripts: An array of string URLs for the <script> tags to emit on the page. Use this to include the <script> that calls hydrateRoot. Omit it if you don‚Äôt want to run React on the client at all.\noptional bootstrapModules: Like bootstrapScripts, but emits <script type=\"module\"> instead.\noptional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.\noptional namespaceURI: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass 'http://www.w3.org/2000/svg' for SVG or 'http://www.w3.org/1998/Math/MathML' for MathML.\noptional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error. You can also use it to adjust the status code before the shell is emitted.\noptional progressiveChunkSize: The number of bytes in a chunk. Read more about the default heuristic.\noptional signal: An abort signal that lets you abort prerendering and render the rest on the client.\nReturns \n\nprerender returns a Promise:\n\nIf rendering the is successful, the Promise will resolve to an object containing:\nprelude: a Web Stream of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.\npostponed: a JSON-serializeable, opaque object that can be passed to resume if prerender did not finish. Otherwise null indicating that the prelude contains all the content and no resume is necessary.\nIf rendering fails, the Promise will be rejected. Use this to output a fallback shell.\nCaveats \n\nnonce is not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application with CSP it would be inappropriate and insecure to include the nonce value in the prerender itself.\n\nNote\nWhen should I use prerender? \n\nThe static prerender API is used for static server-side generation (SSG). Unlike renderToString, prerender waits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API like renderToReadableStream.\n\nprerender can be aborted and later either continued with resumeAndPrerender or resumed with resume to support partial pre-rendering.\n\nUsage \nRendering a React tree to a stream of static HTML \n\nCall prerender to render your React tree to static HTML into a Readable Web Stream::\n\nimport { prerender } from 'react-dom/static';\n\n\n\nasync function handler(request) {\n\n  const {prelude} = await prerender(<App />, {\n\n    bootstrapScripts: ['/main.js']\n\n  });\n\n  return new Response(prelude, {\n\n    headers: { 'content-type': 'text/html' },\n\n  });\n\n}\n\nAlong with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag.\n\nFor example, it might look like this:\n\nexport default function App() {\n\n  return (\n\n    <html>\n\n      <head>\n\n        <meta charSet=\"utf-8\" />\n\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\n        <link rel=\"stylesheet\" href=\"/styles.css\"></link>\n\n        <title>My app</title>\n\n      </head>\n\n      <body>\n\n        <Router />\n\n      </body>\n\n    </html>\n\n  );\n\n}\n\nReact will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:\n\n<!DOCTYPE html>\n\n<html>\n\n  <!-- ... HTML from your components ... -->\n\n</html>\n\n<script src=\"/main.js\" async=\"\"></script>\n\nOn the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:\n\nimport { hydrateRoot } from 'react-dom/client';\n\nimport App from './App.js';\n\n\n\nhydrateRoot(document, <App />);\n\nThis will attach event listeners to the static server-generated HTML and make it interactive.\n\nDEEP DIVE\nReading CSS and JS asset paths from the build output \nShow Details\nRendering a React tree to a string of static HTML \n\nCall prerender to render your app to a static HTML string:\n\nimport { prerender } from 'react-dom/static';\n\n\n\nasync function renderToString() {\n\n  const {prelude} = await prerender(<App />, {\n\n    bootstrapScripts: ['/main.js']\n\n  });\n\n\n\n  const reader = prelude.getReader();\n\n  let content = '';\n\n  while (true) {\n\n    const {done, value} = await reader.read();\n\n    if (done) {\n\n      return content;\n\n    }\n\n    content += Buffer.from(value).toString('utf8');\n\n  }\n\n}\n\nThis will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot to hydrate that server-generated HTML and make it interactive.\n\nWaiting for all data to load \n\nprerender waits for all data to load before finishing the static HTML generation and resolving. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Sidebar>\n\n        <Friends />\n\n        <Photos />\n\n      </Sidebar>\n\n      <Suspense fallback={<PostsGlimmer />}>\n\n        <Posts />\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nImagine that <Posts /> needs to load some data, which takes some time. Ideally, you‚Äôd want wait for the posts to finish so it‚Äôs included in the HTML. To do this, you can use Suspense to suspend on the data, and prerender will wait for the suspended content to finish before resolving to the static HTML.\n\nNote\n\nOnly Suspense-enabled data sources will activate the Suspense component. They include:\n\nData fetching with Suspense-enabled frameworks like Relay and Next.js\nLazy-loading component code with lazy\nReading the value of a Promise with use\n\nSuspense does not detect when data is fetched inside an Effect or event handler.\n\nThe exact way you would load data in the Posts component above depends on your framework. If you use a Suspense-enabled framework, you‚Äôll find the details in its data fetching documentation.\n\nSuspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.\n\nAborting prerendering \n\nYou can force the prerender to ‚Äúgive up‚Äù after a timeout:\n\nasync function renderToString() {\n\n  const controller = new AbortController();\n\n  setTimeout(() => {\n\n    controller.abort()\n\n  }, 10000);\n\n\n\n  try {\n\n    // the prelude will contain all the HTML that was prerendered\n\n    // before the controller aborted.\n\n    const {prelude} = await prerender(<App />, {\n\n      signal: controller.signal,\n\n    });\n\n    //...\n\nAny Suspense boundaries with incomplete children will be included in the prelude in the fallback state.\n\nThis can be used for partial prerendering together with resume or resumeAndPrerender.\n\nTroubleshooting \nMy stream doesn‚Äôt start until the entire app is rendered \n\nThe prerender response waits for the entire app to finish rendering, including waiting for all Suspense boundaries to resolve, before resolving. It is designed for static site generation (SSG) ahead of time and does not support streaming more content as it loads.\n\nTo stream content as it loads, use a streaming server render API like renderToReadableStream.\n\nPREVIOUS\nStatic APIs\nNEXT\nprerenderToNodeStream"
  },
  {
    "title": "prerenderToNodeStream ‚Äì React",
    "url": "https://react.dev/reference/react-dom/static/prerenderToNodeStream",
    "html": "API REFERENCE\nSTATIC APIS\nprerenderToNodeStream\n\nprerenderToNodeStream renders a React tree to a static HTML string using a Node.js Stream.\n\nconst {prelude, postponed} = await prerenderToNodeStream(reactNode, options?)\nReference\nprerenderToNodeStream(reactNode, options?)\nUsage\nRendering a React tree to a stream of static HTML\nRendering a React tree to a string of static HTML\nWaiting for all data to load\nAborting prerendering\nTroubleshooting\nMy stream doesn‚Äôt start until the entire app is rendered\nNote\n\nThis API is specific to Node.js. Environments with Web Streams, like Deno and modern edge runtimes, should use prerender instead.\n\nReference \nprerenderToNodeStream(reactNode, options?) \n\nCall prerenderToNodeStream to render your app to static HTML.\n\nimport { prerenderToNodeStream } from 'react-dom/static';\n\n\n\n// The route handler syntax depends on your backend framework\n\napp.use('/', async (request, response) => {\n\n  const { prelude } = await prerenderToNodeStream(<App />, {\n\n    bootstrapScripts: ['/main.js'],\n\n  });\n\n\n\n  response.setHeader('Content-Type', 'text/plain');\n\n  prelude.pipe(response);\n\n});\n\nOn the client, call hydrateRoot to make the server-generated HTML interactive.\n\nSee more examples below.\n\nParameters \n\nreactNode: A React node you want to render to HTML. For example, a JSX node like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.\n\noptional options: An object with static generation options.\n\noptional bootstrapScriptContent: If specified, this string will be placed in an inline <script> tag.\noptional bootstrapScripts: An array of string URLs for the <script> tags to emit on the page. Use this to include the <script> that calls hydrateRoot. Omit it if you don‚Äôt want to run React on the client at all.\noptional bootstrapModules: Like bootstrapScripts, but emits <script type=\"module\"> instead.\noptional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot.\noptional namespaceURI: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass 'http://www.w3.org/2000/svg' for SVG or 'http://www.w3.org/1998/Math/MathML' for MathML.\noptional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error. You can also use it to adjust the status code before the shell is emitted.\noptional progressiveChunkSize: The number of bytes in a chunk. Read more about the default heuristic.\noptional signal: An abort signal that lets you abort prerendering and render the rest on the client.\nReturns \n\nprerenderToNodeStream returns a Promise:\n\nIf rendering the is successful, the Promise will resolve to an object containing:\nprelude: a Node.js Stream. of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.\npostponed: a JSON-serializeable, opaque object that can be passed to resumeToPipeableStream if prerenderToNodeStream did not finish. Otherwise null indicating that the prelude contains all the content and no resume is necessary.\nIf rendering fails, the Promise will be rejected. Use this to output a fallback shell.\nCaveats \n\nnonce is not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application with CSP it would be inappropriate and insecure to include the nonce value in the prerender itself.\n\nNote\nWhen should I use prerenderToNodeStream? \n\nThe static prerenderToNodeStream API is used for static server-side generation (SSG). Unlike renderToString, prerenderToNodeStream waits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API like renderToReadableStream.\n\nprerenderToNodeStream can be aborted and resumed later with resumeToPipeableStream to support partial pre-rendering.\n\nUsage \nRendering a React tree to a stream of static HTML \n\nCall prerenderToNodeStream to render your React tree to static HTML into a Node.js Stream:\n\nimport { prerenderToNodeStream } from 'react-dom/static';\n\n\n\n// The route handler syntax depends on your backend framework\n\napp.use('/', async (request, response) => {\n\n  const { prelude } = await prerenderToNodeStream(<App />, {\n\n    bootstrapScripts: ['/main.js'],\n\n  });\n\n\n\n  response.setHeader('Content-Type', 'text/plain');\n\n  prelude.pipe(response);\n\n});\n\nAlong with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag.\n\nFor example, it might look like this:\n\nexport default function App() {\n\n  return (\n\n    <html>\n\n      <head>\n\n        <meta charSet=\"utf-8\" />\n\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\n        <link rel=\"stylesheet\" href=\"/styles.css\"></link>\n\n        <title>My app</title>\n\n      </head>\n\n      <body>\n\n        <Router />\n\n      </body>\n\n    </html>\n\n  );\n\n}\n\nReact will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:\n\n<!DOCTYPE html>\n\n<html>\n\n  <!-- ... HTML from your components ... -->\n\n</html>\n\n<script src=\"/main.js\" async=\"\"></script>\n\nOn the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:\n\nimport { hydrateRoot } from 'react-dom/client';\n\nimport App from './App.js';\n\n\n\nhydrateRoot(document, <App />);\n\nThis will attach event listeners to the static server-generated HTML and make it interactive.\n\nDEEP DIVE\nReading CSS and JS asset paths from the build output \nShow Details\nRendering a React tree to a string of static HTML \n\nCall prerenderToNodeStream to render your app to a static HTML string:\n\nimport { prerenderToNodeStream } from 'react-dom/static';\n\n\n\nasync function renderToString() {\n\n  const {prelude} = await prerenderToNodeStream(<App />, {\n\n    bootstrapScripts: ['/main.js']\n\n  });\n\n\n\n  return new Promise((resolve, reject) => {\n\n    let data = '';\n\n    prelude.on('data', chunk => {\n\n      data += chunk;\n\n    });\n\n    prelude.on('end', () => resolve(data));\n\n    prelude.on('error', reject);\n\n  });\n\n}\n\nThis will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot to hydrate that server-generated HTML and make it interactive.\n\nWaiting for all data to load \n\nprerenderToNodeStream waits for all data to load before finishing the static HTML generation and resolving. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:\n\nfunction ProfilePage() {\n\n  return (\n\n    <ProfileLayout>\n\n      <ProfileCover />\n\n      <Sidebar>\n\n        <Friends />\n\n        <Photos />\n\n      </Sidebar>\n\n      <Suspense fallback={<PostsGlimmer />}>\n\n        <Posts />\n\n      </Suspense>\n\n    </ProfileLayout>\n\n  );\n\n}\n\nImagine that <Posts /> needs to load some data, which takes some time. Ideally, you‚Äôd want wait for the posts to finish so it‚Äôs included in the HTML. To do this, you can use Suspense to suspend on the data, and prerenderToNodeStream will wait for the suspended content to finish before resolving to the static HTML.\n\nNote\n\nOnly Suspense-enabled data sources will activate the Suspense component. They include:\n\nData fetching with Suspense-enabled frameworks like Relay and Next.js\nLazy-loading component code with lazy\nReading the value of a Promise with use\n\nSuspense does not detect when data is fetched inside an Effect or event handler.\n\nThe exact way you would load data in the Posts component above depends on your framework. If you use a Suspense-enabled framework, you‚Äôll find the details in its data fetching documentation.\n\nSuspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.\n\nAborting prerendering \n\nYou can force the prerender to ‚Äúgive up‚Äù after a timeout:\n\nasync function renderToString() {\n\n  const controller = new AbortController();\n\n  setTimeout(() => {\n\n    controller.abort()\n\n  }, 10000);\n\n\n\n  try {\n\n    // the prelude will contain all the HTML that was prerendered\n\n    // before the controller aborted.\n\n    const {prelude} = await prerenderToNodeStream(<App />, {\n\n      signal: controller.signal,\n\n    });\n\n    //...\n\nAny Suspense boundaries with incomplete children will be included in the prelude in the fallback state.\n\nThis can be used for partial prerendering together with resumeToPipeableStream or resumeAndPrerenderToNodeStream.\n\nTroubleshooting \nMy stream doesn‚Äôt start until the entire app is rendered \n\nThe prerenderToNodeStream response waits for the entire app to finish rendering, including waiting for all Suspense boundaries to resolve, before resolving. It is designed for static site generation (SSG) ahead of time and does not support streaming more content as it loads.\n\nTo stream content as it loads, use a streaming server render API like renderToPipeableStream.\n\nPREVIOUS\nprerender\nNEXT\nresumeAndPrerender"
  },
  {
    "title": "resumeAndPrerender ‚Äì React",
    "url": "https://react.dev/reference/react-dom/static/resumeAndPrerender",
    "html": "API REFERENCE\nSTATIC APIS\nresumeAndPrerender\n\nresumeAndPrerender continues a prerendered React tree to a static HTML string using a Web Stream.\n\nconst { prelude,postpone } = await resumeAndPrerender(reactNode, postponedState, options?)\nReference\nresumeAndPrerender(reactNode, postponedState, options?)\nUsage\nFurther reading\nNote\n\nThis API depends on Web Streams. For Node.js, use resumeAndPrerenderToNodeStream instead.\n\nReference \nresumeAndPrerender(reactNode, postponedState, options?) \n\nCall resumeAndPrerender to continue a prerendered React tree to a static HTML string.\n\nimport { resumeAndPrerender } from 'react-dom/static';\n\nimport { getPostponedState } from 'storage';\n\n\n\nasync function handler(request, response) {\n\n  const postponedState = getPostponedState(request);\n\n  const { prelude } = await resumeAndPrerender(<App />, postponedState, {\n\n    bootstrapScripts: ['/main.js']\n\n  });\n\n  return new Response(prelude, {\n\n    headers: { 'content-type': 'text/html' },\n\n  });\n\n}\n\nOn the client, call hydrateRoot to make the server-generated HTML interactive.\n\nSee more examples below.\n\nParameters \nreactNode: The React node you called prerender (or a previous resumeAndPrerender) with. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.\npostponedState: The opaque postpone object returned from a prerender API, loaded from wherever you stored it (e.g. redis, a file, or S3).\noptional options: An object with streaming options.\noptional signal: An abort signal that lets you abort server rendering and render the rest on the client.\noptional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error.\nReturns \n\nprerender returns a Promise:\n\nIf rendering the is successful, the Promise will resolve to an object containing:\nprelude: a Web Stream of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.\npostponed: an JSON-serializeable, opaque object that can be passed to resume or resumeAndPrerender if prerender is aborted.\nIf rendering fails, the Promise will be rejected. Use this to output a fallback shell.\nCaveats \n\nnonce is not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application with CSP it would be inappropriate and insecure to include the nonce value in the prerender itself.\n\nNote\nWhen should I use resumeAndPrerender? \n\nThe static resumeAndPrerender API is used for static server-side generation (SSG). Unlike renderToString, resumeAndPrerender waits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API like renderToReadableStream.\n\nresumeAndPrerender can be aborted and later either continued with another resumeAndPrerender or resumed with resume to support partial pre-rendering.\n\nUsage \nFurther reading \n\nresumeAndPrerender behaves similarly to prerender but can be used to continue a previously started prerendering process that was aborted.\nFor more information about resuming a prerendered tree, see the resume documentation.\n\nPREVIOUS\nprerenderToNodeStream\nNEXT\nresumeAndPrerenderToNodeStream"
  },
  {
    "title": "resumeAndPrerenderToNodeStream ‚Äì React",
    "url": "https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream",
    "html": "API REFERENCE\nSTATIC APIS\nresumeAndPrerenderToNodeStream\n\nresumeAndPrerenderToNodeStream continues a prerendered React tree to a static HTML string using a a Node.js Stream..\n\nconst {prelude, postponed} = await resumeAndPrerenderToNodeStream(reactNode, postponedState, options?)\nReference\nresumeAndPrerenderToNodeStream(reactNode, postponedState, options?)\nUsage\nFurther reading\nNote\n\nThis API is specific to Node.js. Environments with Web Streams, like Deno and modern edge runtimes, should use prerender instead.\n\nReference \nresumeAndPrerenderToNodeStream(reactNode, postponedState, options?) \n\nCall resumeAndPrerenderToNodeStream to continue a prerendered React tree to a static HTML string.\n\nimport { resumeAndPrerenderToNodeStream } from 'react-dom/static';\n\nimport { getPostponedState } from 'storage';\n\n\n\nasync function handler(request, writable) {\n\n  const postponedState = getPostponedState(request);\n\n  const { prelude } = await resumeAndPrerenderToNodeStream(<App />, JSON.parse(postponedState));\n\n  prelude.pipe(writable);\n\n}\n\nOn the client, call hydrateRoot to make the server-generated HTML interactive.\n\nSee more examples below.\n\nParameters \nreactNode: The React node you called prerender (or a previous resumeAndPrerenderToNodeStream) with. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag.\npostponedState: The opaque postpone object returned from a prerender API, loaded from wherever you stored it (e.g. redis, a file, or S3).\noptional options: An object with streaming options.\noptional signal: An abort signal that lets you abort server rendering and render the rest on the client.\noptional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error.\nReturns \n\nresumeAndPrerenderToNodeStream returns a Promise:\n\nIf rendering the is successful, the Promise will resolve to an object containing:\nprelude: a Web Stream of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.\npostponed: an JSON-serializeable, opaque object that can be passed to resumeToNodeStream or resumeAndPrerenderToNodeStream if resumeAndPrerenderToNodeStream is aborted.\nIf rendering fails, the Promise will be rejected. Use this to output a fallback shell.\nCaveats \n\nnonce is not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application with CSP it would be inappropriate and insecure to include the nonce value in the prerender itself.\n\nNote\nWhen should I use resumeAndPrerenderToNodeStream? \n\nThe static resumeAndPrerenderToNodeStream API is used for static server-side generation (SSG). Unlike renderToString, resumeAndPrerenderToNodeStream waits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API like renderToReadableStream.\n\nresumeAndPrerenderToNodeStream can be aborted and later either continued with another resumeAndPrerenderToNodeStream or resumed with resume to support partial pre-rendering.\n\nUsage \nFurther reading \n\nresumeAndPrerenderToNodeStream behaves similarly to prerender but can be used to continue a previously started prerendering process that was aborted.\nFor more information about resuming a prerendered tree, see the resume documentation.\n\nPREVIOUS\nresumeAndPrerender"
  },
  {
    "title": "Not Found ‚Äì React",
    "url": "https://react.dev/reference/react-dom/static/index",
    "html": "LEARN REACT\nNot Found\n\nThis page doesn‚Äôt exist.\n\nIf this is a mistake, let us know, and we will try to fix it!"
  },
  {
    "title": "unmountComponentAtNode ‚Äì React",
    "url": "https://18.react.dev/reference/react-dom/unmountComponentAtNode",
    "html": "API REFERENCE\nAPIS\nunmountComponentAtNode\nDeprecated\n\nThis API will be removed in a future major version of React.\n\nIn React 18, unmountComponentAtNode was replaced by root.unmount().\n\nunmountComponentAtNode removes a mounted React component from the DOM.\n\nunmountComponentAtNode(domNode)\nReference\nunmountComponentAtNode(domNode)\nUsage\nRemoving a React app from a DOM element\nReference \nunmountComponentAtNode(domNode) \n\nCall unmountComponentAtNode to remove a mounted React component from the DOM and clean up its event handlers and state.\n\nimport { unmountComponentAtNode } from 'react-dom';\n\n\n\nconst domNode = document.getElementById('root');\n\nrender(<App />, domNode);\n\n\n\nunmountComponentAtNode(domNode);\n\nSee more examples below.\n\nParameters \ndomNode: A DOM element. React will remove a mounted React component from this element.\nReturns \n\nunmountComponentAtNode returns true if a component was unmounted and false otherwise.\n\nUsage \n\nCall unmountComponentAtNode to remove a mounted React component from a browser DOM node and clean up its event handlers and state.\n\nimport { render, unmountComponentAtNode } from 'react-dom';\n\nimport App from './App.js';\n\n\n\nconst rootNode = document.getElementById('root');\n\nrender(<App />, rootNode);\n\n\n\n// ...\n\nunmountComponentAtNode(rootNode);\nRemoving a React app from a DOM element \n\nOccasionally, you may want to ‚Äúsprinkle‚Äù React on an existing page, or a page that is not fully written in React. In those cases, you may need to ‚Äústop‚Äù the React app, by removing all of the UI, state, and listeners from the DOM node it was rendered to.\n\nIn this example, clicking ‚ÄúRender React App‚Äù will render a React app. Click ‚ÄúUnmount React App‚Äù to destroy it:\n\nindex.js\nindex.html\nApp.js\nReset\nFork\nimport './styles.css';\nimport { render, unmountComponentAtNode } from 'react-dom';\nimport App from './App.js';\n\nconst domNode = document.getElementById('root');\n\ndocument.getElementById('render').addEventListener('click', () => {\n  render(<App />, domNode);\n});\n\ndocument.getElementById('unmount').addEventListener('click', () => {\n  unmountComponentAtNode(domNode);\n});\n\n\nPREVIOUS\nrender\nNEXT\nClient APIs"
  }
]
</file>

<file path="output/trpc/docs.json">
[
  {
    "title": "tRPC server documentation | tRPC",
    "url": "https://trpc.io/docs/server/introduction",
    "html": "üìÑÔ∏è Define Routers\n\nTo begin building your tRPC-based API, you'll first need to define your router. Once you've mastered the fundamentals, you can customize your routers for more advanced use cases.\n\nüìÑÔ∏è Define Procedures\n\nA procedure is a function which is exposed to the client, it can be one of:\n\nüìÑÔ∏è Input & Output Validators\n\ntRPC procedures may define validation logic for their input and/or output, and validators are also used to infer the types of inputs and outputs (using the Standard Schema interface if available, or custom interfaces for supported validators if not). We have first class support for many popular validators, and you can integrate validators which we don't directly support.\n\nüìÑÔ∏è Non-JSON Inputs (FormData, File, Blob)\n\nIn addition to JSON-serializable data, tRPC can use FormData, File, and other Binary types as procedure inputs\n\nüìÑÔ∏è Merging Routers\n\nWriting all API-code in your code in the same file is not a great idea. It's easy to merge routers with other routers.\n\nüìÑÔ∏è Context\n\nYour context holds data that all of your tRPC procedures will have access to, and is a great place to put things like database connections or authentication information.\n\nüìÑÔ∏è Middlewares\n\nYou are able to add middleware(s) to a procedure with the t.procedure.use() method. The middleware(s) will wrap the invocation of the procedure and must pass through its return value.\n\nüóÉÔ∏è Hosting tRPC with Adapters\n\n6 items\n\nüìÑÔ∏è Server Side Calls\n\nYou may need to call your procedure(s) directly from the same server they're hosted in, createCallerFactory() can be used to achieve this. This is useful for server-side calls and for integration testing of your tRPC procedures.\n\nüìÑÔ∏è Authorization\n\nThe createContext function is called for each incoming request, so here you can add contextual information about the calling user from the request object.\n\nüìÑÔ∏è Error Handling\n\nWhenever an error occurs in a procedure, tRPC responds to the client with an object that includes an \"error\" property. This property contains all the information that you need to handle the error in the client.\n\nüìÑÔ∏è Error Formatting\n\nThe error formatting in your router will be inferred all the way to your client (&&nbsp;React&nbsp;components)\n\nüìÑÔ∏è Data Transformers\n\nYou are able to serialize the response data & input args. The transformers need to be added both to the server and the client.\n\nüìÑÔ∏è Metadata\n\nProcedure metadata allows you to add an optional procedure specific meta property which will be available in all middleware function parameters.\n\nüìÑÔ∏è Response Caching\n\nThe below examples uses Vercel's edge caching to serve data to your users as fast as possible.\n\nüìÑÔ∏è Subscriptions\n\nIntroduction\n\nüìÑÔ∏è WebSockets\n\nYou can use WebSockets for all or some of the communication with your server, see wsLink for how to set it up on the client."
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/introduction#__docusaurus_skipToContent_fallback",
    "html": "üìÑÔ∏è Define Routers\n\nTo begin building your tRPC-based API, you'll first need to define your router. Once you've mastered the fundamentals, you can customize your routers for more advanced use cases.\n\nüìÑÔ∏è Define Procedures\n\nA procedure is a function which is exposed to the client, it can be one of:\n\nüìÑÔ∏è Input & Output Validators\n\ntRPC procedures may define validation logic for their input and/or output, and validators are also used to infer the types of inputs and outputs (using the Standard Schema interface if available, or custom interfaces for supported validators if not). We have first class support for many popular validators, and you can integrate validators which we don't directly support.\n\nüìÑÔ∏è Non-JSON Inputs (FormData, File, Blob)\n\nIn addition to JSON-serializable data, tRPC can use FormData, File, and other Binary types as procedure inputs\n\nüìÑÔ∏è Merging Routers\n\nWriting all API-code in your code in the same file is not a great idea. It's easy to merge routers with other routers.\n\nüìÑÔ∏è Context\n\nYour context holds data that all of your tRPC procedures will have access to, and is a great place to put things like database connections or authentication information.\n\nüìÑÔ∏è Middlewares\n\nYou are able to add middleware(s) to a procedure with the t.procedure.use() method. The middleware(s) will wrap the invocation of the procedure and must pass through its return value.\n\nüóÉÔ∏è Hosting tRPC with Adapters\n\n6 items\n\nüìÑÔ∏è Server Side Calls\n\nYou may need to call your procedure(s) directly from the same server they're hosted in, createCallerFactory() can be used to achieve this. This is useful for server-side calls and for integration testing of your tRPC procedures.\n\nüìÑÔ∏è Authorization\n\nThe createContext function is called for each incoming request, so here you can add contextual information about the calling user from the request object.\n\nüìÑÔ∏è Error Handling\n\nWhenever an error occurs in a procedure, tRPC responds to the client with an object that includes an \"error\" property. This property contains all the information that you need to handle the error in the client.\n\nüìÑÔ∏è Error Formatting\n\nThe error formatting in your router will be inferred all the way to your client (&&nbsp;React&nbsp;components)\n\nüìÑÔ∏è Data Transformers\n\nYou are able to serialize the response data & input args. The transformers need to be added both to the server and the client.\n\nüìÑÔ∏è Metadata\n\nProcedure metadata allows you to add an optional procedure specific meta property which will be available in all middleware function parameters.\n\nüìÑÔ∏è Response Caching\n\nThe below examples uses Vercel's edge caching to serve data to your users as fast as possible.\n\nüìÑÔ∏è Subscriptions\n\nIntroduction\n\nüìÑÔ∏è WebSockets\n\nYou can use WebSockets for all or some of the communication with your server, see wsLink for how to set it up on the client."
  },
  {
    "title": "Define Routers | tRPC",
    "url": "https://trpc.io/docs/server/routers",
    "html": "Backend Usage\nDefine Routers\nVersion: 11.x\nDefine Routers\n\nTo begin building your tRPC-based API, you'll first need to define your router. Once you've mastered the fundamentals, you can customize your routers for more advanced use cases.\n\nInitialize tRPC‚Äã\n\nYou should initialize tRPC exactly once per application. Multiple instances of tRPC will cause issues.\n\nserver/trpc.ts\nimport { initTRPC } from '@trpc/server';\n¬†\n// You can use any variable name you like.\n// We use t to keep things simple.\nconst t = initTRPC.create();\n¬†\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\nCopy\n\nYou'll notice we are exporting certain methods of the t variable here rather than t itself. This is to establish a certain set of procedures that we will use idiomatically in our codebase.\n\nDefining a router‚Äã\n\nNext, let's define a router with a procedure to use in our application. We have now created an API \"endpoint\".\n\nIn order for these endpoints to be exposed to the frontend, your Adapter should be configured with your appRouter instance.\n\nserver/_app.ts\nimport { publicProcedure, router } from './trpc';\n¬†\nconst appRouter = router({\n  greeting: publicProcedure.query(() => 'hello tRPC v10!'),\n});\n¬†\n// Export only the type of a router!\n// This prevents us from importing server code on the client.\nexport type AppRouter = typeof appRouter;\nCopy\nAdvanced usage‚Äã\n\nWhen initializing your router, tRPC allows you to:\n\nSetup request contexts\nAssign metadata to procedures\nFormat and handle errors\nTransform data as needed\nCustomize the runtime configuration\n\nYou can use method chaining to customize your t-object on initialization. For example:\n\nconst t = initTRPC.context<Context>().meta<Meta>().create({\n  /* [...] */\n});\nCopy\nRuntime Configuration‚Äã\nexport interface RootConfig<TTypes extends RootTypes> {\n  /**\n   * Use a data transformer\n   * @see https://trpc.io/docs/v11/data-transformers\n   */\n  transformer: TTypes['transformer'];\n  /**\n   * Use custom error formatting\n   * @see https://trpc.io/docs/v11/error-formatting\n   */\n  errorFormatter: ErrorFormatter<TTypes['ctx'], any>;\n  /**\n   * Allow `@trpc/server` to run in non-server environments\n   * @warning **Use with caution**, this should likely mainly be used within testing.\n   * @default false\n   */\n  allowOutsideOfServer: boolean;\n  /**\n   * Is this a server environment?\n   * @warning **Use with caution**, this should likely mainly be used within testing.\n   * @default typeof window === 'undefined' || 'Deno' in window || process.env.NODE_ENV === 'test'\n   */\n  isServer: boolean;\n  /**\n   * Is this development?\n   * Will be used to decide if the API should return stack traces\n   * @default process.env.NODE_ENV !== 'production'\n   */\n  isDev: boolean;\n}\nCopy\nEdit this page"
  },
  {
    "title": "Define Procedures | tRPC",
    "url": "https://trpc.io/docs/server/procedures",
    "html": "Backend Usage\nDefine Procedures\nVersion: 11.x\nDefine Procedures\n\nA procedure is a function which is exposed to the client, it can be one of:\n\na Query - used to fetch data, generally does not change any data\na Mutation - used to send data, often for create/update/delete purposes\na Subscription - you might not need this, and we have dedicated documentation\n\nProcedures in tRPC are very flexible primitives to create backend functions. They use an immutable builder pattern, which means you can create reusable base procedures that share functionality among multiple procedures.\n\nWriting procedures‚Äã\n\nThe t object you create during tRPC setup returns an initial t.procedure which all other procedures are built on:\n\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n¬†\nconst t = initTRPC.context<{ signGuestBook: () => Promise<void> }>().create();\n¬†\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n¬†\nconst appRouter = router({\n  // Queries are the best place to fetch data\n  hello: publicProcedure.query(() => {\n    return {\n      message: 'hello world',\n    };\n  }),\n¬†\n  // Mutations are the best place to do things like updating a database\n  goodbye: publicProcedure.mutation(async (opts) => {\n    await opts.ctx.signGuestBook();\n¬†\n    return {\n      message: 'goodbye!',\n    };\n  }),\n});\nCopy\nReusable \"Base Procedures\"‚Äã\n\nAs a general pattern we recommend you rename and export t.procedure as publicProcedure, which then makes room for you to create other named procedures for specific use cases and export those too. This pattern is called \"base procedures\" and is a key pattern for code and behaviour re-use in tRPC; every application is likely to need it.\n\nIn the below code, we're using reusable base procedures to build common use-cases for our app - we're making a reusable base procedures for logged in users (authedProcedure) & another base procedure that takes an organizationId and validates that a user is part of that organization.\n\nThis is a simplified example; in practice you may want to use some combination of Headers, Context, Middleware, and Metadata, to authenticate and authorize your users.\n\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport { z } from 'zod';\n¬†\ntype Organization = {\n  id: string;\n  name: string;\n};\ntype Membership = {\n  role: 'ADMIN' | 'MEMBER';\n  Organization: Organization;\n};\ntype User = {\n  id: string;\n  memberships: Membership[];\n};\ntype Context = {\n  /**\n   * User is nullable\n   */\n  user: User | null;\n};\n¬†\nconst t = initTRPC.context<Context>().create();\n¬†\nexport const publicProcedure = t.procedure;\n¬†\n// procedure that asserts that the user is logged in\nexport const authedProcedure = t.procedure.use(async function isAuthed(opts) {\n  const { ctx } = opts;\n  // `ctx.user` is nullable\n  if (!ctx.user) {\n            \n(property) user: User | null\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n¬†\n  return opts.next({\n    ctx: {\n      // ‚úÖ user value is known to be non-null now\n      user: ctx.user,\n    },\n  });\n});\n¬†\n// procedure that a user is a member of a specific organization\nexport const organizationProcedure = authedProcedure\n  .input(z.object({ organizationId: z.string() }))\n  .use(function isMemberOfOrganization(opts) {\n    const membership = opts.ctx.user.memberships.find(\n      (m) => m.Organization.id === opts.input.organizationId,\n    );\n    if (!membership) {\n      throw new TRPCError({\n        code: 'FORBIDDEN',\n      });\n    }\n    return opts.next({\n      ctx: {\n        Organization: membership.Organization,\n      },\n    });\n  });\n¬†\nexport const appRouter = t.router({\n  whoami: authedProcedure.query(async (opts) => {\n    // user is non-nullable here\n    const { ctx } = opts;\n            \nconst ctx: {\n    user: User;\n}\n    return ctx.user;\n  }),\n  addMember: organizationProcedure\n    .input(\n      z.object({\n        email: z.string().email(),\n      }),\n    )\n    .mutation((opts) => {\n      // ctx contains the non-nullable user & the organization being queried\n      const { ctx } = opts;\n              \nconst ctx: {\n    user: User;\n    Organization: Organization;\n}\n¬†\n      // input includes the validated email of the user being invited & the validated organizationId\n      const { input } = opts;\n               \nconst input: {\n    organizationId: string;\n    email: string;\n}\n¬†\n      return '...';\n    }),\n});\nCopy\nInferring the options type of a \"Base Procedure\"‚Äã\n\nIn addition to being able to infer the input and output types of a procedure, you can also infer the options type of a specific procedure builder (or base procedure) using inferProcedureBuilderResolverOptions.\n\nThis type helper is useful for declaring a type to a function's parameters. Like for example, separating the procedure's handler (main execution code) from its definition at the router, or for creating a helper function that works with multiple procedures.\n\nasync function getMembersOfOrganization(\n  opts: inferProcedureBuilderResolverOptions<typeof organizationProcedure>,\n) {\n  // input and ctx are now correctly typed!\n  const { ctx, input } = opts;\n¬†\n  return await prisma.user.findMany({\n    where: {\n      membership: {\n        organizationId: ctx.Organization.id,\n      },\n    },\n  });\n}\nexport const appRouter = t.router({\n  listMembers: organizationProcedure.query(async (opts) => {\n    // use helper function!\n    const members = await getMembersOfOrganization(opts);\n¬†\n    return members;\n  }),\n});\nCopy\nSubscriptions‚Äã\n\nFor information on subscriptions, see our subscriptions guide.\n\nEdit this page"
  },
  {
    "title": "Input & Output Validators | tRPC",
    "url": "https://trpc.io/docs/server/validators",
    "html": "Backend Usage\nInput & Output Validators\nVersion: 11.x\nInput & Output Validators\n\ntRPC procedures may define validation logic for their input and/or output, and validators are also used to infer the types of inputs and outputs (using the Standard Schema interface if available, or custom interfaces for supported validators if not). We have first class support for many popular validators, and you can integrate validators which we don't directly support.\n\nInput Validators‚Äã\n\nBy defining an input validator, tRPC can check that a procedure call is correct and return a validation error if not.\n\nTo set up an input validator, use the procedure.input() method:\n\n// Our examples use Zod by default, but usage with other libraries is identical\nimport { z } from 'zod';\n¬†\nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\n¬†\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(\n      z.object({\n        name: z.string(),\n      }),\n    )\n    .query((opts) => {\n      const name = opts.input.name;\n             \nconst name: string\n      return {\n        greeting: `Hello ${opts.input.name}`,\n      };\n    }),\n});\nCopy\nInput Merging‚Äã\n\n.input() can be stacked to build more complex types, which is particularly useful when you want to utilise some common input to a collection of procedures in a middleware.\n\nconst baseProcedure = t.procedure\n  .input(z.object({ townName: z.string() }))\n  .use((opts) => {\n    const input = opts.input;\n           \nconst input: {\n    townName: string;\n}\n¬†\n    console.log(`Handling request with user from: ${input.townName}`);\n¬†\n    return opts.next();\n  });\n¬†\nexport const appRouter = t.router({\n  hello: baseProcedure\n    .input(\n      z.object({\n        name: z.string(),\n      }),\n    )\n    .query((opts) => {\n      const input = opts.input;\n             \nconst input: {\n    townName: string;\n    name: string;\n}\n      return {\n        greeting: `Hello ${input.name}, my friend from ${input.townName}`,\n      };\n    }),\n});\nCopy\nOutput Validators‚Äã\n\nValidating outputs is not always as important as defining inputs, since tRPC gives you automatic type-safety by inferring the return type of your procedures. Some reasons to define an output validator include:\n\nChecking that data returned from untrusted sources is correct\nEnsure that you are not returning more data to the client than necessary\nINFO\n\nIf output validation fails, the server will respond with an INTERNAL_SERVER_ERROR.\n\nimport { z } from 'zod';\n¬†\nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\n¬†\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .output(\n      z.object({\n        greeting: z.string(),\n      }),\n    )\n    .query((opts) => {\n      return {\n        gre,\n¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†\ngreeting\n      };\n    }),\n});\nCopy\nOutput validation of subscriptions‚Äã\n\nSince subscriptions are async iterators, you can use the same validation techniques as above.\n\nHave a look at the subscriptions guide for more information.\n\nThe most basic validator: a function‚Äã\n\nYou can define a validator without any 3rd party dependencies, with a function.\n\nINFO\n\nWe don't recommend making a custom validator unless you have a specific need, but it's important to understand that there's no magic here - it's just typescript!\n\nIn most cases we recommend you use a validation library\n\nimport { initTRPC } from '@trpc/server';\n¬†\nexport const t = initTRPC.create();\n¬†\nconst publicProcedure = t.procedure;\n¬†\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input((value): string => {\n      if (typeof value === 'string') {\n        return value;\n      }\n      throw new Error('Input is not a string');\n    })\n    .output((value): string => {\n      if (typeof value === 'string') {\n        return value;\n      }\n      throw new Error('Output is not a string');\n    })\n    .query((opts) => {\n      const { input } = opts;\n               \nconst input: string\n      return `hello ${input}`;\n    }),\n});\n¬†\nexport type AppRouter = typeof appRouter;\nCopy\nLibrary integrations‚Äã\n\ntRPC works out of the box with a number of popular validation and parsing libraries, including any library conforming to Standard Schema. The below are some examples of usage with validators which we officially maintain support for.\n\nWith Zod‚Äã\n\nZod is our default recommendation, it has a strong ecosystem which makes it a great choice to use in multiple parts of your codebase. If you have no opinion of your own and want a powerful library which won't limit future needs, Zod is a great choice.\n\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n¬†\nexport const t = initTRPC.create();\n¬†\nconst publicProcedure = t.procedure;\n¬†\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(\n      z.object({\n        name: z.string(),\n      }),\n    )\n    .output(\n      z.object({\n        greeting: z.string(),\n      }),\n    )\n    .query(({ input }) => {\n               \n(parameter) input: {\n    name: string;\n}\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\n¬†\nexport type AppRouter = typeof appRouter;\nCopy\nWith Yup‚Äã\nimport { initTRPC } from '@trpc/server';\nimport * as yup from 'yup';\n¬†\nexport const t = initTRPC.create();\n¬†\nconst publicProcedure = t.procedure;\n¬†\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(\n      yup.object({\n        name: yup.string().required(),\n      }),\n    )\n    .output(\n      yup.object({\n        greeting: yup.string().required(),\n      }),\n    )\n    .query(({ input }) => {\n               \n(parameter) input: {\n    name: string;\n}\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\n¬†\nexport type AppRouter = typeof appRouter;\nCopy\nWith Superstruct‚Äã\nimport { initTRPC } from '@trpc/server';\nimport { object, string } from 'superstruct';\n¬†\nexport const t = initTRPC.create();\n¬†\nconst publicProcedure = t.procedure;\n¬†\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(object({ name: string() }))\n    .output(object({ greeting: string() }))\n    .query(({ input }) => {\n               \n(parameter) input: {\n    name: string;\n}\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\n¬†\nexport type AppRouter = typeof appRouter;\nCopy\nWith scale-ts‚Äã\nimport { initTRPC } from '@trpc/server';\nimport * as $ from 'scale-codec';\n¬†\nexport const t = initTRPC.create();\n¬†\nconst publicProcedure = t.procedure;\n¬†\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input($.object($.field('name', $.str)))\n    .output($.object($.field('greeting', $.str)))\n    .query(({ input }) => {\n               \n(parameter) input: {\n    readonly name: string;\n}\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\n¬†\nexport type AppRouter = typeof appRouter;\nCopy\nWith Typia‚Äã\nimport { initTRPC } from '@trpc/server';\nimport typia from 'typia';\nimport { v4 } from 'uuid';\nimport { IBbsArticle } from '../structures/IBbsArticle';\nconst t = initTRPC.create();\nconst publicProcedure = t.procedure;\nexport const appRouter = t.router({\n  store: publicProcedure\n    .input(typia.createAssert<IBbsArticle.IStore>())\n    .output(typia.createAssert<IBbsArticle>())\n    .query(({ input }) => {\n      return {\n        id: v4(),\n        writer: input.writer,\n        title: input.title,\n        body: input.body,\n        created_at: new Date().toString(),\n      };\n    }),\n});\nexport type AppRouter = typeof appRouter;\nCopy\nWith ArkType‚Äã\nimport { initTRPC } from '@trpc/server';\nimport { type } from 'arktype';\nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\nexport const appRouter = t.router({\n  hello: publicProcedure.input(type({ name: 'string' })).query((opts) => {\n    return {\n      greeting: `hello ${opts.input.name}`,\n    };\n  }),\n});\nexport type AppRouter = typeof appRouter;\nCopy\nWith effect‚Äã\nimport { initTRPC } from '@trpc/server';\nimport { Schema } from 'effect';\nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(Schema.standardSchemaV1(Schema.Struct({ name: Schema.String })))\n    .output(Schema.standardSchemaV1(Schema.Struct({ greeting: Schema.String })))\n    .query(({ input }) => {\n      //      ^?\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\nexport type AppRouter = typeof appRouter;\nCopy\nWith Valibot‚Äã\nimport { initTRPC } from '@trpc/server';\nimport * as v from 'valibot';\n¬†\nexport const t = initTRPC.create();\n¬†\nconst publicProcedure = t.procedure;\n¬†\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(v.object({ name: v.string() }))\n    .output(v.object({ greeting: v.string() }))\n    .query(({ input }) => {\n               \n(parameter) input: {\n    name: string;\n}\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\n¬†\nexport type AppRouter = typeof appRouter;\nCopy\nWith @robolex/sure‚Äã\n\nYou're able to define your own Error types and error throwing function if necessary. As a convenience @robolex/sure provides sure/src/err.ts:\n\n// sure/src/err.ts\nexport const err = (schema) => (input) => {\n  const [good, result] = schema(input);\n  if (good) return result;\n  throw result;\n};\nCopy\nimport { err, object, string } from '@robolex/sure';\nimport { initTRPC } from '@trpc/server';\nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(\n      err(\n        object({\n          name: string,\n        }),\n      ),\n    )\n    .output(\n      err(\n        object({\n          greeting: string,\n        }),\n      ),\n    )\n    .query(({ input }) => {\n      //      ^?\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\nexport type AppRouter = typeof appRouter;\nCopy\nWith TypeBox‚Äã\nimport { Type } from '@sinclair/typebox';\nimport { initTRPC } from '@trpc/server';\nimport { wrap } from '@typeschema/typebox';\nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(wrap(Type.Object({ name: Type.String() })))\n    .output(wrap(Type.Object({ greeting: Type.String() })))\n    .query(({ input }) => {\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\nexport type AppRouter = typeof appRouter;\nCopy\nContributing your own Validator Library‚Äã\n\nIf you work on a validator library which supports tRPC usage, please feel free to open a PR for this page with equivalent usage to the other examples here, and a link to your docs.\n\nIntegration with tRPC in most cases is as simple as meeting one of several existing type interfaces. Conforming to Standard Schema is recommended, but in some cases we may accept a PR to add a new supported interface. Feel free to open an issue for discussion. You can check the existing supported interfaces and functions for parsing/validation in code.\n\nEdit this page"
  },
  {
    "title": "Non-JSON Content Types | tRPC",
    "url": "https://trpc.io/docs/server/non-json-content-types",
    "html": "Backend Usage\nNon-JSON Inputs (FormData, File, Blob)\nVersion: 11.x\nNon-JSON Content Types\n\nIn addition to JSON-serializable data, tRPC can use FormData, File, and other Binary types as procedure inputs\n\nClient Setup‚Äã\nINFO\n\nWhile tRPC natively supports several non-json serializable types, your client may need a little link configuration to support them depending on your setup.\n\nhttpLink supports non-json content types out the box, if you're only using this then your existing setup should work immediately\n\nimport { httpLink } from '@trpc/client';\ntrpc.createClient({\n  links: [\n    httpLink({\n      url: 'http://localhost:2022',\n    }),\n  ],\n});\nCopy\n\nHowever, not all links support these new content types, if you're using httpBatchLink or httpBatchStreamLink you will need to include a splitLink and check which link to use depending on the content\n\nimport {\n  httpBatchLink,\n  httpLink,\n  isNonJsonSerializable,\n  splitLink,\n} from '@trpc/client';\ntrpc.createClient({\n  links: [\n    splitLink({\n      condition: (op) => isNonJsonSerializable(op.input),\n      true: httpLink({\n        url,\n      }),\n      false: httpBatchLink({\n        url,\n      }),\n    }),\n  ],\n});\nCopy\n\nIf you are using transformer in your tRPC server, typescript requires that your tRPC client link defines transformer as well.\nUse this example as base:\n\nimport {\n  httpBatchLink,\n  httpLink,\n  isNonJsonSerializable,\n  splitLink,\n} from '@trpc/client';\nimport superjson from 'superjson';\ntrpc.createClient({\n  links: [\n    splitLink({\n      condition: (op) => isNonJsonSerializable(op.input),\n      true: httpLink({\n        url,\n        transformer: {\n          // request - convert data before sending to the tRPC server\n          serialize: (data) => data,\n          // response - convert the tRPC response before using it in client\n          deserialize: superjson.deserialize, // or your other transformer\n        },\n      }),\n      false: httpBatchLink({\n        url,\n        transformers: superjson, // or your other transformer\n      }),\n    }),\n  ],\n});\nCopy\nServer Usage‚Äã\nINFO\n\nWhen a request is handled by tRPC, it takes care of parsing the request body based on the Content-Type header of the request.\nIf you encounter errors like Failed to parse body as XXX, make sure that your server (e.g., Express, Next.js) isn't parsing the request body before tRPC handles it.\n\n// Example in express\n// incorrect\nconst app = express();\napp.use(express.json()); // this try to parse body before tRPC.\napp.post('/express/hello', (req,res) => {/* ... */ }); // normal express route handler\napp.use('/trpc', trpcExpress.createExpressMiddleware({ /* ... */}))// tRPC fails to parse body\n// correct\nconst app = express();\napp.use('/express', express.json()); // do it only in \"/express/*\" path\napp.post('/express/hello', (req,res) => {/* ... */ });\napp.use('/trpc', trpcExpress.createExpressMiddleware({ /* ... */}))// tRPC can parse body\nCopy\nFormData Input‚Äã\n\nFormData is natively supported, and for more advanced usage you could also combine this with a library like zod-form-data to validate inputs in a type-safe way.\n\nimport { z } from 'zod';\n¬†\nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\n¬†\nexport const appRouter = t.router({\n  hello: publicProcedure.input(z.instanceof(FormData)).mutation((opts) => {\n    const data = opts.input;\n           \nconst data: FormData\n    return {\n      greeting: `Hello ${data.get('name')}`,\n    };\n  }),\n});\nCopy\n\nFor a more advanced code sample you can see our example project here\n\nFile and other Binary Type Inputs‚Äã\n\ntRPC converts many octet content types to a ReadableStream which can be consumed in a procedure. Currently these are Blob Uint8Array and File.\n\nimport { octetInputParser } from '@trpc/server/http';\n¬†\nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\n¬†\nexport const appRouter = t.router({\n  upload: publicProcedure.input(octetInputParser).mutation((opts) => {\n    const data = opts.input;\n           \nconst data: ReadableStream<any>\n    return {\n      valid: true,\n    };\n  }),\n});\nCopy\nEdit this page"
  },
  {
    "title": "Merging Routers | tRPC",
    "url": "https://trpc.io/docs/server/merging-routers",
    "html": "Backend Usage\nMerging Routers\nVersion: 11.x\nMerging Routers\n\nWriting all API-code in your code in the same file is not a great idea. It's easy to merge routers with other routers.\n\nDefining an inline sub-router‚Äã\n\nWhen you define an inline sub-router, you can represent your router as a plain object.\n\nIn the below example, nested1 and nested2 are equal:\n\nserver/_app.ts\nimport * as trpc from '@trpc/server';\nimport { publicProcedure, router } from './trpc';\n¬†\nconst appRouter = router({\n  // Shorthand plain object for creating a sub-router\n  nested1: {\n    proc: publicProcedure.query(() => '...'),\n  },\n  // Equivalent of:\n  nested2: router({\n    proc : publicProcedure.query(() => '...'),\n  }),\n});\nCopy\nMerging with child routers‚Äã\nserver.ts\n// @filename: trpc.ts\nimport { initTRPC } from '@trpc/server';\nconst t = initTRPC.create();\n¬†\n¬†\n¬†\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n¬†\n// @filename: routers/_app.ts\nimport { router } from '../trpc';\nimport { z } from 'zod';\n¬†\nimport { userRouter } from './user';\nimport { postRouter } from './post';\n¬†\nconst appRouter = router({\n  user: userRouter, // put procedures under \"user\" namespace\n  post: postRouter, // put procedures under \"post\" namespace\n});\n¬†\n// You can then access the merged route with\n// http://localhost:3000/trpc/<NAMESPACE>.<PROCEDURE>\n¬†\nexport type AppRouter = typeof appRouter;\n¬†\n¬†\n// @filename: routers/post.ts\nimport { router, publicProcedure } from '../trpc';\nimport { z } from 'zod';\nexport const postRouter = router({\n  create: publicProcedure\n    .input(\n      z.object({\n        title: z.string(),\n      }),\n    )\n    .mutation((opts) => {\n      const { input } = opts;\n               \nconst input: {\n    title: string;\n}\n      // [...]\n    }),\n  list: publicProcedure.query(() => {\n    // ...\n    return [];\n  }),\n});\n¬†\n// @filename: routers/user.ts\nimport { router, publicProcedure } from '../trpc';\nimport { z } from 'zod';\nexport const userRouter = router({\n  list: publicProcedure.query(() => {\n    // [..]\n    return [];\n  }),\n});\n¬†\nCopy\nMerging with t.mergeRouters‚Äã\n\nIf you prefer having all procedures flat in one single namespace, you can instead use t.mergeRouters\n\nserver.ts\n// @filename: trpc.ts\nimport { initTRPC } from '@trpc/server';\nconst t = initTRPC.create();\n¬†\n¬†\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\nexport const mergeRouters = t.mergeRouters;\n¬†\n// @filename: routers/_app.ts\nimport { router, publicProcedure, mergeRouters } from '../trpc';\nimport { z } from 'zod';\n¬†\nimport { userRouter } from './user';\nimport { postRouter } from './post';\n¬†\nconst appRouter = mergeRouters(userRouter, postRouter)\n¬†\nexport type AppRouter = typeof appRouter;\n¬†\n// @filename: routers/post.ts\nimport { router, publicProcedure } from '../trpc';\nimport { z } from 'zod';\nexport const postRouter = router({\n  postCreate: publicProcedure\n    .input(\n      z.object({\n        title: z.string(),\n      }),\n    )\n    .mutation((opts) => {\n      const { input } = opts;\n               \nconst input: {\n    title: string;\n}\n      // [...]\n    }),\n  postList: publicProcedure.query(() => {\n    // ...\n    return [];\n  }),\n});\n¬†\n¬†\n// @filename: routers/user.ts\nimport { router, publicProcedure } from '../trpc';\nimport { z } from 'zod';\nexport const userRouter = router({\n  userList: publicProcedure.query(() => {\n    // [..]\n    return [];\n  }),\n});\n¬†\nCopy\nDynamically load routers‚Äã\n\nYou can use the lazy function to dynamically load your routers. This can be useful to reduce cold starts of your application.\n\nThere's no difference in how you use the router after it's been lazy loaded vs. how you use a normal router.\n\nExample code of lazy loading a router:\n\n// @filename: routers/_app.ts\nimport { lazy } from '@trpc/server';\nimport { router } from '../trpc';\n¬†\nexport const appRouter = router({\n  // Option 1: Short-hand lazy load the greeting router if you have exactly 1 export and it is the router\n  greeting: lazy(() => import('./greeting.js')),\n  // Option 2: Alternative way to lazy load if you have more than 1 export\n  user: lazy(() => import('./user.js').then((m) => m.userRouter)),\n});\nexport type AppRouter = typeof appRouter;\n¬†\n// ----------------------------------------------------\n// @filename: routers/greeting.ts\nimport { router, publicProcedure } from '../trpc';\nexport const greetingRouter = router({\n  hello: publicProcedure.query(() => 'world'),\n});\n¬†\n// ----------------------------------------------------\n// @filename: routers/user.ts\nimport { router, publicProcedure } from '../trpc';\n¬†\nexport const userRouter = router({\n  list: publicProcedure.query(() => ['John', 'Jane', 'Jim']),\n});\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/context",
    "html": "Backend Usage\nContext\nVersion: 11.x\nContext\n\nYour context holds data that all of your tRPC procedures will have access to, and is a great place to put things like database connections or authentication information.\n\nSetting up the context is done in 2 steps, defining the type during initialization and then creating the runtime context for each request.\n\nDefining the context type‚Äã\n\nWhen initializing tRPC using initTRPC, you should pipe .context<TContext>() to the initTRPC builder function before calling .create(). The type TContext can either be inferred from a function's return type or be explicitly defined.\n\nThis will make sure your context is properly typed in your procedures and middlewares.\n\nimport { initTRPC } from '@trpc/server';\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getSession } from 'next-auth/react';\n¬†\nexport const createContext = async (opts: CreateNextContextOptions) => {\n  const session = await getSession({ req: opts.req });\n¬†\n  return {\n    session,\n  };\n};\n¬†\nexport type Context = Awaited<ReturnType<typeof createContext>>;\nconst t = initTRPC.context<Context>().create();\n¬†\nt.procedure.use((opts) => {\n  opts.ctx;\n       \n(property) ctx: {\n    session: Session | null;\n}\n¬†\n  return opts.next();\n});\nCopy\nCreating the context‚Äã\n\nThe createContext() function must be passed to the handler that is mounting your appRouter, which may be via HTTP, a server-side call or our server-side helpers.\n\ncreateContext() is called for each invocation of tRPC, so batched requests will share a context.\n\n// 1. HTTP request\nimport { createHTTPHandler } from '@trpc/server/adapters/standalone';\nimport { createContext } from './context';\nimport { appRouter } from './router';\nconst handler = createHTTPHandler({\n  router: appRouter,\n  createContext,\n});\nCopy\n// 2. Server-side call\nimport { createContext } from './context';\nimport { createCaller } from './router';\nconst caller = createCaller(await createContext());\nCopy\n// 3. servers-side helpers\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport { createContext } from './context';\nimport { appRouter } from './router';\nconst helpers = createServerSideHelpers({\n  router: appRouter,\n  ctx: await createContext(),\n});\nCopy\nExample code‚Äã\n// -------------------------------------------------\n// @filename: context.ts\n// -------------------------------------------------\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getSession } from 'next-auth/react';\n¬†\n/**\n * Creates context for an incoming request\n * @see https://trpc.io/docs/v11/context\n */\nexport async function createContext(opts: CreateNextContextOptions) {\n  const session = await getSession({ req: opts.req });\n¬†\n  return {\n    session,\n  };\n}\n¬†\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n¬†\n// -------------------------------------------------\n// @filename: trpc.ts\n// -------------------------------------------------\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport { Context } from './context';\n¬†\nconst t = initTRPC.context<Context>().create();\n¬†\n¬†\nexport const router = t.router;\n¬†\n/**\n * Unprotected procedure\n */\nexport const publicProcedure = t.procedure;\n¬†\n/**\n * Protected procedure\n */\nexport const protectedProcedure = t.procedure.use(function isAuthed(opts) {\n  if (!opts.ctx.session?.user?.email) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n    });\n  }\n  return opts.next({\n    ctx: {\n      // Infers the `session` as non-nullable\n      session: opts.ctx.session,\n    },\n  });\n});\nCopy\nInner and outer context‚Äã\n\nIn some scenarios it could make sense to split up your context into \"inner\" and \"outer\" functions.\n\nInner context is where you define context which doesn‚Äôt depend on the request, e.g. your database connection. You can use this function for integration testing or server-side helpers, where you don‚Äôt have a request object. Whatever is defined here will always be available in your procedures.\n\nOuter context is where you define context which depends on the request, e.g. for the user's session. Whatever is defined here is only available for procedures that are called via HTTP.\n\nExample for inner & outer context‚Äã\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getSessionFromCookie, type Session } from './auth';\n/**\n * Defines your inner context shape.\n * Add fields here that the inner context brings.\n */\ninterface CreateInnerContextOptions extends Partial<CreateNextContextOptions> {\n  session: Session | null;\n}\n/**\n * Inner context. Will always be available in your procedures, in contrast to the outer context.\n *\n * Also useful for:\n * - testing, so you don't have to mock Next.js' `req`/`res`\n * - tRPC's `createServerSideHelpers` where we don't have `req`/`res`\n *\n * @see https://trpc.io/docs/v11/context#inner-and-outer-context\n */\nexport async function createContextInner(opts?: CreateInnerContextOptions) {\n  return {\n    prisma,\n    session: opts.session,\n  };\n}\n/**\n * Outer context. Used in the routers and will e.g. bring `req` & `res` to the context as \"not `undefined`\".\n *\n * @see https://trpc.io/docs/v11/context#inner-and-outer-context\n */\nexport async function createContext(opts: CreateNextContextOptions) {\n  const session = getSessionFromCookie(opts.req);\n  const contextInner = await createContextInner({ session });\n  return {\n    ...contextInner,\n    req: opts.req,\n    res: opts.res,\n  };\n}\nexport type Context = Awaited<ReturnType<typeof createContextInner>>;\n// The usage in your router is the same as the example above.\nCopy\n\nIt is important to infer your Context from the inner context, as only what is defined there is really always available in your procedures.\n\nIf you don't want to check req or res for undefined in your procedures all the time, you could build a small reusable procedure for that:\n\nexport const apiProcedure = publicProcedure.use((opts) => {\n  if (!opts.ctx.req || !opts.ctx.res) {\n    throw new Error('You are missing `req` or `res` in your call.');\n  }\n  return opts.next({\n    ctx: {\n      // We overwrite the context with the truthy `req` & `res`, which will also overwrite the types used in your procedure.\n      req: opts.ctx.req,\n      res: opts.ctx.res,\n    },\n  });\n});\nCopy\nLimiting Batch Size‚Äã\n\nYou can use the context to limit the number of requests that can be batched together.\n\nimport { TRPCError } from '@trpc/server';\nimport type { CreateHTTPContextOptions } from '@trpc/server/adapters/standalone';\n¬†\nconst MAX_BATCH_SIZE = 10;\n¬†\n// Create a context that checks batch size\nexport async function createContext(opts: CreateHTTPContextOptions) {\n  if (opts.info.calls.length > MAX_BATCH_SIZE) {\n    throw new TRPCError({\n      code: 'TOO_MANY_REQUESTS',\n      message: `Batch size limit of ${MAX_BATCH_SIZE} exceeded`,\n    });\n  }\n  return {};\n}\nCopy\n\nThis context will throw a TOO_MANY_REQUESTS error if a client tries to batch more than 10 requests together. You can adjust the MAX_BATCH_SIZE constant to match your needs.\n\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/middlewares",
    "html": "Backend Usage\nMiddlewares\nVersion: 11.x\nMiddlewares\n\nYou are able to add middleware(s) to a procedure with the t.procedure.use() method. The middleware(s) will wrap the invocation of the procedure and must pass through its return value.\n\nAuthorization‚Äã\n\nIn the example below, any call to a adminProcedure will ensure that the user is an \"admin\" before executing.\n\nimport { TRPCError, initTRPC } from '@trpc/server';\n¬†\ninterface Context {\n  user?: {\n    id: string;\n    isAdmin: boolean;\n    // [..]\n  };\n}\n¬†\nconst t = initTRPC.context<Context>().create();\nexport const publicProcedure = t.procedure;\nexport const router = t.router;\n¬†\nexport const adminProcedure = publicProcedure.use(async (opts) => {\n  const { ctx } = opts;\n  if (!ctx.user?.isAdmin) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n  return opts.next({\n    ctx: {\n      user: ctx.user,\n    },\n  });\n});\nCopy\nimport { adminProcedure, publicProcedure, router } from './trpc';\n¬†\nconst adminRouter = router({\n  secretPlace: adminProcedure.query(() => 'a key'),\n});\n¬†\nexport const appRouter = router({\n  foo: publicProcedure.query(() => 'bar'),\n  admin: adminRouter,\n});\nCopy\nTIP\n\nSee Error Handling to learn more about the TRPCError thrown in the above example.\n\nLogging‚Äã\n\nIn the example below timings for queries are logged automatically.\n\nexport const loggedProcedure = publicProcedure.use(async (opts) => {\n  const start = Date.now();\n¬†\n  const result = await opts.next();\n¬†\n  const durationMs = Date.now() - start;\n  const meta = { path: opts.path, type: opts.type, durationMs };\n¬†\n  result.ok\n    ? console.log('OK request timing:', meta)\n    : console.error('Non-OK request timing', meta);\n¬†\n  return result;\n});\nCopy\nimport { loggedProcedure, router } from './trpc';\n¬†\nexport const appRouter = router({\n  foo: loggedProcedure.query(() => 'bar'),\n  abc: loggedProcedure.query(() => 'def'),\n});\nCopy\nContext Extension‚Äã\n\n\"Context Extension\" enables middlewares to dynamically add and override keys on a base procedure's context in a typesafe manner.\n\nBelow we have an example of a middleware that changes properties of a context, the changes are then available to all chained consumers, such as other middlewares and procedures:\n\ntype Context = {\n  // user is nullable\n  user?: {\n    id: string;\n  };\n};\n¬†\nconst protectedProcedure = publicProcedure.use(async function isAuthed(opts) {\n  const { ctx } = opts;\n  // `ctx.user` is nullable\n  if (!ctx.user) {\n            \n(property) user: {\n    id: string;\n} | undefined\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n¬†\n  return opts.next({\n    ctx: {\n      // ‚úÖ user value is known to be non-null now\n      user: ctx.user,\n       \n(property) user: {\n    id: string;\n}\n    },\n  });\n});\n¬†\nprotectedProcedure.query((opts) => {\n  const { ctx } = opts;\n  return ctx.user;\n         \nconst ctx: {\n    user: {\n        id: string;\n    };\n}\n});\nCopy\nUsing .concat() to create reusable middlewares and plugins‚Äã\nTIP\nCreating middlewares using t.middleware has the limitation that the Context type is tied to the Context type of the tRPC instance.\nCreating middlewares with experimental_standaloneMiddleware() has the limitation that you cannot define input parsers and similar tied to your module.\n\ntRPC has an API called .concat() which allows you to independently define a partial procedure that can be used with any tRPC instance that matches the context and metadata of the plugin.\n\nThis helper primarily targets creating plugins and libraries with tRPC.\n\n// ------------------------------------------------\n// üß©üß©üß© a library creating a reusable plugin üß©üß©üß©\n// @filename: myPlugin.ts\n¬†\nimport { initTRPC, TRPCError } from '@trpc/server';\n¬†\nexport function createMyPlugin() {\n  // When creating a plugin for tRPC, you use the same API as creating any other tRPC-app\n  // this is the plugin's root `t`-object\n  const t = initTRPC\n    .context<{\n      // the procedure using the plugin will need to extend this context\n    }>()\n    .meta<{\n      // the base `initTRPC`-object of the application using this needs to extend this meta\n    }>()\n    .create();\n¬†\n  return {\n    // you can also add `.input()` if you want your plugin to do input validation\n    pluginProc: t.procedure.use((opts) => {\n      return opts.next({\n        ctx: {\n          fromPlugin: 'hello from myPlugin' as const,\n        },\n      });\n    }),\n  };\n}\n// ------------------------------------\n// üöÄüöÄüöÄ the app using the plugin üöÄüöÄüöÄ\n// @filename: app.ts\nimport { createMyPlugin } from './myPlugin';\nimport { initTRPC, TRPCError } from '@trpc/server';\n¬†\n¬†\n// the app's root `t`-object\nconst t = initTRPC\n  .context<{\n    // ...\n  }>()\n  .create();\n¬†\n¬†\nexport const publicProcedure = t.procedure;\nexport const router = t.router;\n¬†\n// initialize the plugin (a real-world example would likely take options here)\nconst plugin = createMyPlugin();\n¬†\n// create a base procedure using the plugin\nconst procedureWithPlugin = publicProcedure\n  .concat(\n    plugin.pluginProc,\n  )\n  .use(opts => {\n    const { ctx } = opts;\n            \nconst ctx: {\n    fromPlugin: \"hello from myPlugin\";\n}\n    return opts.next()\n  })\n¬†\n¬†\nexport const appRouter = router({\n  hello: procedureWithPlugin.query(opts => {\n    return opts.ctx.fromPlugin;\n  })\n})\nCopy\nExtending middlewares‚Äã\nINFO\n\nWe have prefixed this as unstable_ as it's a new API, but you're safe to use it! Read more.\n\nWe have a powerful feature called .pipe() which allows you to extend middlewares in a typesafe manner.\n\nBelow we have an example of a middleware that extends a base middleware(foo). Like the context extension example above, piping middlewares will change properties of the context, and procedures will receive the new context value.\n\nconst fooMiddleware = t.middleware((opts) => {\n  return opts.next({\n    ctx: {\n      foo: 'foo' as const,\n    },\n  });\n});\n¬†\nconst barMiddleware = fooMiddleware.unstable_pipe((opts) => {\n  const { ctx } = opts;\n  ctx.foo;\n      \n(property) foo: \"foo\"\n  return opts.next({\n    ctx: {\n      bar: 'bar' as const,\n    },\n  });\n});\n¬†\nconst barProcedure = publicProcedure.use(barMiddleware);\nbarProcedure.query((opts) => {\n  const { ctx } = opts;\n  return ctx.bar;\n         \nconst ctx: {\n    foo: \"foo\";\n    bar: \"bar\";\n}\n});\nCopy\n\nBeware that the order in which you pipe your middlewares matter and that the context must overlap. An example of a forbidden pipe is shown below. Here, the fooMiddleware overrides the ctx.a while barMiddleware still expects the root context from the initialization in initTRPC - so piping fooMiddleware with barMiddleware would not work, while piping barMiddleware with fooMiddleware does work.\n\nimport { initTRPC } from '@trpc/server';\n¬†\nconst t = initTRPC\n  .context<{\n    a: {\n      b: 'a';\n    };\n  }>()\n  .create();\n¬†\nconst fooMiddleware = t.middleware((opts) => {\n  const { ctx } = opts;\n  ctx.a; // üëà fooMiddleware expects `ctx.a` to be an object\n     \n(property) a: {\n    b: \"a\";\n}\n  return opts.next({\n    ctx: {\n      a: 'a' as const, // üëà `ctx.a` is no longer an object\n    },\n  });\n});\n¬†\nconst barMiddleware = t.middleware((opts) => {\n  const { ctx } = opts;\n  ctx.a; // üëà barMiddleware expects `ctx.a` to be an object\n     \n(property) a: {\n    b: \"a\";\n}\n  return opts.next({\n    ctx: {\n      foo: 'foo' as const,\n    },\n  });\n});\n¬†\n// ‚ùå `ctx.a` does not overlap from `fooMiddleware` to `barMiddleware`\nfooMiddleware.unstable_pipe(barMiddleware);\n¬†\n// ‚úÖ `ctx.a` overlaps from `barMiddleware` and `fooMiddleware`\nbarMiddleware.unstable_pipe(fooMiddleware);\nCopy\nExperimental: standalone middlewares‚Äã\nINFO\n\nThis has been deprecated in favor of .concat()\n\ntRPC has an experimental API called experimental_standaloneMiddleware which allows you to independently define a middleware that can be used with any tRPC instance. Creating middlewares using t.middleware has the limitation that the Context type is tied to the Context type of the tRPC instance. This means that you cannot use the same middleware with multiple tRPC instances that have different Context types.\n\nUsing experimental_standaloneMiddleware you can create a middleware that explicitly defines its requirements, i.e. the Context, Input and Meta types:\n\nimport {\n  experimental_standaloneMiddleware,\n  initTRPC,\n  TRPCError,\n} from '@trpc/server';\nimport * as z from 'zod';\n¬†\nconst projectAccessMiddleware = experimental_standaloneMiddleware<{\n  ctx: { allowedProjects: string[] }; // defaults to 'object' if not defined\n  input: { projectId: string }; // defaults to 'unknown' if not defined\n  // 'meta', not defined here, defaults to 'object | undefined'\n}>().create((opts) => {\n  if (!opts.ctx.allowedProjects.includes(opts.input.projectId)) {\n    throw new TRPCError({\n      code: 'FORBIDDEN',\n      message: 'Not allowed',\n    });\n  }\n¬†\n  return opts.next();\n});\n¬†\nconst t1 = initTRPC\n  .context<{\n    allowedProjects: string[];\n  }>()\n  .create();\n¬†\n// ‚úÖ `ctx.allowedProjects` satisfies \"string[]\" and `input.projectId` satisfies \"string\"\nconst accessControlledProcedure = t1.procedure\n  .input(z.object({ projectId: z.string() }))\n  .use(projectAccessMiddleware);\n¬†\n// ‚ùå `ctx.allowedProjects` satisfies \"string[]\" but `input.projectId` does not satisfy \"string\"\nconst accessControlledProcedure2 = t1.procedure\n  .input(z.object({ projectId: z.number() }))\n  .use(projectAccessMiddleware);\n¬†\n// ‚ùå `ctx.allowedProjects` does not satisfy \"string[]\" even though `input.projectId` satisfies \"string\"\nconst t2 = initTRPC\n  .context<{\n    allowedProjects: number[];\n  }>()\n  .create();\n¬†\nconst accessControlledProcedure3 = t2.procedure\n  .input(z.object({ projectId: z.string() }))\n  .use(projectAccessMiddleware);\nCopy\n\nHere is an example with multiple standalone middlewares:\n\nimport { experimental_standaloneMiddleware, initTRPC } from '@trpc/server';\nimport * as z from 'zod';\n¬†\nconst t = initTRPC.create();\nconst schemaA = z.object({ valueA: z.string() });\nconst schemaB = z.object({ valueB: z.string() });\n¬†\nconst valueAUppercaserMiddleware = experimental_standaloneMiddleware<{\n  input: z.infer<typeof schemaA>;\n}>().create((opts) => {\n  return opts.next({\n    ctx: { valueAUppercase: opts.input.valueA.toUpperCase() },\n  });\n});\n¬†\nconst valueBUppercaserMiddleware = experimental_standaloneMiddleware<{\n  input: z.infer<typeof schemaB>;\n}>().create((opts) => {\n  return opts.next({\n    ctx: { valueBUppercase: opts.input.valueB.toUpperCase() },\n  });\n});\n¬†\nconst combinedInputThatSatisfiesBothMiddlewares = z.object({\n  valueA: z.string(),\n  valueB: z.string(),\n  extraProp: z.string(),\n});\n¬†\nt.procedure\n  .input(combinedInputThatSatisfiesBothMiddlewares)\n  .use(valueAUppercaserMiddleware)\n  .use(valueBUppercaserMiddleware)\n  .query(\n    ({\n      input: { valueA, valueB, extraProp },\n      ctx: { valueAUppercase, valueBUppercase },\n    }) =>\n      `valueA: ${valueA}, valueB: ${valueB}, extraProp: ${extraProp}, valueAUppercase: ${valueAUppercase}, valueBUppercase: ${valueBUppercase}`,\n  );\nCopy\nEdit this page"
  },
  {
    "title": "Adapters | tRPC",
    "url": "https://trpc.io/docs/server/adapters",
    "html": "Backend Usage\nHosting tRPC with Adapters\nVersion: 11.x\nAdapters\n\ntRPC is not a server on its own, and must therefore be served using other hosts, such as a simple Node.js HTTP Server, Express, or even Next.js. Most tRPC features are the same no matter which backend you choose. Adapters act as the glue between the host system and your tRPC API.\n\nAdapters typically follow some common conventions, allowing you to set up context creation via createContext, and globally handle errors via onError, but importantly allow you to choose an appropriate host for your application.\n\nWe support many modes of hosting an API, which you will find documented here.\n\nFor serverful APIs, you might want our Standalone adapter, or use the Express or Fastify adapters to hook into your existing APIs\nYou might want a serverless solution and choose AWS Lambda, or Fetch for edge runtimes\nYou might have a full-stack framework and want a full integration like Next.js, or you could use the Fetch adapter with Next.js, Astro, Remix, or SolidStart\nTIP\n\nFor local development or serverful infrastructure, the simplest Adapter to use is the Standalone Adapter, which can be used to run a standard Node.js HTTP Server. We recommend this when you need to get started quickly and have no existing HTTP Server to integrate with. Swapping out later is trivial if your needs change.\n\nEdit this page"
  },
  {
    "title": "Server Side Calls | tRPC",
    "url": "https://trpc.io/docs/server/server-side-calls",
    "html": "Backend Usage\nServer Side Calls\nVersion: 11.x\nServer Side Calls\n\nYou may need to call your procedure(s) directly from the same server they're hosted in, createCallerFactory() can be used to achieve this. This is useful for server-side calls and for integration testing of your tRPC procedures.\n\nINFO\n\ncreateCaller should not be used to call procedures from within other procedures. This creates overhead by (potentially) creating context again, executing all middlewares, and validating the input - all of which were already done by the current procedure. Instead, you should extract the shared logic into a separate function and call that from within the procedures, like so:\n\nCreate caller‚Äã\n\nWith the t.createCallerFactory-function you can create a server-side caller of any router. You first call createCallerFactory with an argument of the router you want to call, then this returns a function where you can pass in a Context for the following procedure calls.\n\nBasic example‚Äã\n\nWe create the router with a query to list posts and a mutation to add posts, and then we a call each method.\n\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n¬†\ntype Context = {\n  foo: string;\n};\n¬†\nconst t = initTRPC.context<Context>().create();\n¬†\nconst publicProcedure = t.procedure;\nconst { createCallerFactory, router } = t;\n¬†\ninterface Post {\n  id: string;\n  title: string;\n}\nconst posts: Post[] = [\n  {\n    id: '1',\n    title: 'Hello world',\n  },\n];\nconst appRouter = router({\n  post: router({\n    add: publicProcedure\n      .input(\n        z.object({\n          title: z.string().min(2),\n        }),\n      )\n      .mutation((opts) => {\n        const post: Post = {\n          ...opts.input,\n          id: `${Math.random()}`,\n        };\n        posts.push(post);\n        return post;\n      }),\n    list: publicProcedure.query(() => posts),\n  }),\n});\n¬†\n// 1. create a caller-function for your router\nconst createCaller = createCallerFactory(appRouter);\n¬†\n// 2. create a caller using your `Context`\nconst caller = createCaller({\n  foo: 'bar',\n});\n¬†\n// 3. use the caller to add and list posts\nconst addedPost = await caller.post.add({\n  title: 'How to make server-side call in tRPC',\n});\n¬†\nconst postList = await caller.post.list();\n         \nconst postList: Post[]\nCopy\nExample usage in an integration test‚Äã\n\nTaken from https://github.com/trpc/examples-next-prisma-starter/blob/main/src/server/routers/post.test.ts\n\nimport { inferProcedureInput } from '@trpc/server';\nimport { createContextInner } from '../context';\nimport { AppRouter, createCaller } from './_app';\ntest('add and get post', async () => {\n  const ctx = await createContextInner({});\n  const caller = createCaller(ctx);\n  const input: inferProcedureInput<AppRouter['post']['add']> = {\n    text: 'hello test',\n    title: 'hello test',\n  };\n  const post = await caller.post.add(input);\n  const byId = await caller.post.byId({ id: post.id });\n  expect(byId).toMatchObject(input);\n});\nCopy\nrouter.createCaller()‚Äã\n\nWith the router.createCaller({}) function (first argument is Context) we retrieve an instance of RouterCaller.\n\nInput query example‚Äã\n\nWe create the router with an input query, and then we call the asynchronous greeting procedure to get the result.\n\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n¬†\nconst t = initTRPC.create();\n¬†\nconst router = t.router({\n  // Create procedure at path 'greeting'\n  greeting: t.procedure\n    .input(z.object({ name: z.string() }))\n    .query((opts) => `Hello ${opts.input.name}`),\n});\n¬†\nconst caller = router.createCaller({});\nconst result = await caller.greeting({ name: 'tRPC' });\n        \nconst result: string\nCopy\nMutation example‚Äã\n\nWe create the router with a mutation, and then we call the asynchronous post procedure to get the result.\n\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n¬†\nconst posts = ['One', 'Two', 'Three'];\n¬†\nconst t = initTRPC.create();\nconst router = t.router({\n  post: t.router({\n    add: t.procedure.input(z.string()).mutation((opts) => {\n      posts.push(opts.input);\n      return posts;\n    }),\n  }),\n});\n¬†\nconst caller = router.createCaller({});\nconst result = await caller.post.add('Four');\n        \nconst result: string[]\nCopy\nContext with middleware example‚Äã\n\nWe create a middleware to check the context before executing the secret procedure. Below are two examples: the former fails because the context doesn't fit the middleware logic, and the latter works correctly.\n\n\n\nINFO\n\nMiddlewares are performed before any procedure(s) are called.\n\n\n\nimport { initTRPC, TRPCError } from '@trpc/server';\n¬†\ntype Context = {\n  user?: {\n    id: string;\n  };\n};\nconst t = initTRPC.context<Context>().create();\n¬†\nconst protectedProcedure = t.procedure.use((opts) => {\n  const { ctx } = opts;\n  if (!ctx.user) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'You are not authorized',\n    });\n  }\n¬†\n  return opts.next({\n    ctx: {\n      // Infers that the `user` is non-nullable\n      user: ctx.user,\n    },\n  });\n});\n¬†\nconst router = t.router({\n  secret: protectedProcedure.query((opts) => opts.ctx.user),\n});\n¬†\n{\n  // ‚ùå this will return an error because there isn't the right context param\n  const caller = router.createCaller({});\n¬†\n  const result = await caller.secret();\n}\n¬†\n{\n  // ‚úÖ this will work because user property is present inside context param\n  const authorizedCaller = router.createCaller({\n    user: {\n      id: 'KATT',\n    },\n  });\n  const result = await authorizedCaller.secret();\n          \nconst result: {\n    id: string;\n}\n}\nCopy\nExample for a Next.js API endpoint‚Äã\nTIP\n\nThis example shows how to use the caller in a Next.js API endpoint. tRPC creates API endpoints for you already, so this file is only meant to show how to call a procedure from another, custom endpoint.\n\nimport { TRPCError } from '@trpc/server';\nimport { getHTTPStatusCodeFromError } from '@trpc/server/http';\nimport { appRouter } from '~/server/routers/_app';\nimport type { NextApiRequest, NextApiResponse } from 'next';\n¬†\ntype ResponseData = {\n  data?: {\n    postTitle: string;\n  };\n  error?: {\n    message: string;\n  };\n};\n¬†\nexport default async (\n  req: NextApiRequest,\n  res: NextApiResponse<ResponseData>,\n) => {\n  /** We want to simulate an error, so we pick a post ID that does not exist in the database. */\n  const postId = `this-id-does-not-exist-${Math.random()}`;\n¬†\n  const caller = appRouter.createCaller({});\n¬†\n  try {\n    // the server-side call\n    const postResult = await caller.post.byId({ id: postId });\n¬†\n    res.status(200).json({ data: { postTitle: postResult.title } });\n  } catch (cause) {\n    // If this a tRPC error, we can extract additional information.\n    if (cause instanceof TRPCError) {\n      // We can get the specific HTTP status code coming from tRPC (e.g. 404 for `NOT_FOUND`).\n      const httpStatusCode = getHTTPStatusCodeFromError(cause);\n¬†\n      res.status(httpStatusCode).json({ error: { message: cause.message } });\n      return;\n    }\n¬†\n    // This is not a tRPC error, so we don't have specific information.\n    res.status(500).json({\n      error: { message: `Error while accessing post with ID ${postId}` },\n    });\n  }\n};\nCopy\nError handling‚Äã\n\nThe createFactoryCaller and the createCaller function can take an error handler through the onError option. This can be used to throw errors that are not wrapped in a TRPCError, or respond to errors in some other way. Any handler passed to createCallerFactory will be called before the handler passed to createCaller. The handler is called with the same arguments as an error formatter would be, except for the shape field:\n\n{\n  ctx: unknown; // The request context\n  error: TRPCError; // The TRPCError that was thrown\n  path: string | undefined; // The path of the procedure that threw the error\n  input: unknown; // The input that was passed to the procedure\n  type: 'query' | 'mutation' | 'subscription' | 'unknown'; // The type of the procedure that threw the error\n}\nCopy\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n¬†\nconst t = initTRPC\n  .context<{\n    foo?: 'bar';\n  }>()\n  .create();\n¬†\nconst router = t.router({\n  greeting: t.procedure.input(z.object({ name: z.string() })).query((opts) => {\n    if (opts.input.name === 'invalid') {\n      throw new Error('Invalid name');\n    }\n¬†\n    return `Hello ${opts.input.name}`;\n  }),\n});\n¬†\nconst caller = router.createCaller(\n  {\n    /* context */\n  },\n  {\n    onError: (opts) => {\n      console.error('An error occurred:', opts.error);\n    },\n  },\n);\n¬†\n// The following will log \"An error occurred: Error: Invalid name\", and then throw a plain error\n//  with the message \"This is a custom error\"\nawait caller.greeting({ name: 'invalid' });\nCopy\nEdit this page"
  },
  {
    "title": "Authorization | tRPC",
    "url": "https://trpc.io/docs/server/authorization",
    "html": "Backend Usage\nAuthorization\nVersion: 11.x\nAuthorization\n\nThe createContext function is called for each incoming request, so here you can add contextual information about the calling user from the request object.\n\nCreate context from request headers‚Äã\nserver/context.ts\nimport * as trpcNext from '@trpc/server/adapters/next';\nimport { decodeAndVerifyJwtToken } from './somewhere/in/your/app/utils';\nexport async function createContext({\n  req,\n  res,\n}: trpcNext.CreateNextContextOptions) {\n  // Create your context based on the request object\n  // Will be available as `ctx` in all your resolvers\n  // This is just an example of something you might want to do in your ctx fn\n  async function getUserFromHeader() {\n    if (req.headers.authorization) {\n      const user = await decodeAndVerifyJwtToken(\n        req.headers.authorization.split(' ')[1],\n      );\n      return user;\n    }\n    return null;\n  }\n  const user = await getUserFromHeader();\n  return {\n    user,\n  };\n}\nexport type Context = Awaited<ReturnType<typeof createContext>>;\nCopy\nOption 1: Authorize using resolver‚Äã\nserver/routers/_app.ts\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport type { Context } from '../context';\nexport const t = initTRPC.context<Context>().create();\nconst appRouter = t.router({\n  // open for anyone\n  hello: t.procedure\n    .input(z.string().nullish())\n    .query((opts) => `hello ${opts.input ?? opts.ctx.user?.name ?? 'world'}`),\n  // checked in resolver\n  secret: t.procedure.query((opts) => {\n    if (!opts.ctx.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n    return {\n      secret: 'sauce',\n    };\n  }),\n});\nCopy\nOption 2: Authorize using middleware‚Äã\nserver/routers/_app.ts\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport type { Context } from '../context';\nexport const t = initTRPC.context<Context>().create();\n// you can reuse this for any procedure\nexport const protectedProcedure = t.procedure.use(\n  async function isAuthed(opts) {\n    const { ctx } = opts;\n    // `ctx.user` is nullable\n    if (!ctx.user) {\n      //     ^?\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n    return opts.next({\n      ctx: {\n        // ‚úÖ user value is known to be non-null now\n        user: ctx.user,\n        // ^?\n      },\n    });\n  },\n);\nt.router({\n  // this is accessible for everyone\n  hello: t.procedure\n    .input(z.string().nullish())\n    .query((opts) => `hello ${opts.input ?? opts.ctx.user?.name ?? 'world'}`),\n  admin: t.router({\n    // this is accessible only to admins\n    secret: protectedProcedure.query((opts) => {\n      return {\n        secret: 'sauce',\n      };\n    }),\n  }),\n});\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/error-handling",
    "html": "Backend Usage\nError Handling\nVersion: 11.x\nError Handling\n\nWhenever an error occurs in a procedure, tRPC responds to the client with an object that includes an \"error\" property. This property contains all the information that you need to handle the error in the client.\n\nHere's an example error response caused by a bad request input:\n\n{\n  \"id\": null,\n  \"error\": {\n    \"message\": \"\\\"password\\\" must be at least 4 characters\",\n    \"code\": -32600,\n    \"data\": {\n      \"code\": \"BAD_REQUEST\",\n      \"httpStatus\": 400,\n      \"stack\": \"...\",\n      \"path\": \"user.changepassword\"\n    }\n  }\n}\nCopy\n\nNote: the returned stack trace is only available in the development environment.\n\nError codes‚Äã\n\ntRPC defines a list of error codes that each represent a different type of error and response with a different HTTP code.\n\nCode\tDescription\tHTTP code\nBAD_REQUEST\tThe server cannot or will not process the request due to something that is perceived to be a client error.\t400\nUNAUTHORIZED\tThe client request has not been completed because it lacks valid authentication credentials for the requested resource.\t401\nPAYMENT_REQUIRED\tThe client request requires payment to access the requested resource.\t402\nFORBIDDEN\tThe server was unauthorized to access a required data source, such as a REST API.\t403\nNOT_FOUND\tThe server cannot find the requested resource.\t404\nMETHOD_NOT_SUPPORTED\tThe server knows the request method, but the target resource doesn't support this method.\t405\nTIMEOUT\tThe server would like to shut down this unused connection.\t408\nCONFLICT\tThe server request resource conflict with the current state of the target resource.\t409\nPRECONDITION_FAILED\tAccess to the target resource has been denied.\t412\nPAYLOAD_TOO_LARGE\tRequest entity is larger than limits defined by server.\t413\nUNSUPPORTED_MEDIA_TYPE\tThe server refuses to accept the request because the payload format is in an unsupported format.\t415\nUNPROCESSABLE_CONTENT\tThe server understands the request method, and the request entity is correct, but the server was unable to process it.\t422\nPRECONDITION_REQUIRED\tThe server cannot process the request because a required precondition header (such as If-Match) is missing. When a precondition header does not match the server-side state, the response should be 412 Precondition Failed.\t428\nTOO_MANY_REQUESTS\tThe rate limit has been exceeded or too many requests are being sent to the server.\t429\nCLIENT_CLOSED_REQUEST\tAccess to the resource has been denied.\t499\nINTERNAL_SERVER_ERROR\tAn unspecified error occurred.\t500\nNOT_IMPLEMENTED\tThe server does not support the functionality required to fulfill the request.\t501\nBAD_GATEWAY\tThe server received an invalid response from the upstream server.\t502\nSERVICE_UNAVAILABLE\tThe server is not ready to handle the request.\t503\nGATEWAY_TIMEOUT\tThe server did not get a response in time from the upstream server that it needed in order to complete the request.\t504\n\ntRPC exposes a helper function, getHTTPStatusCodeFromError, to help you extract the HTTP code from the error:\n\nimport { getHTTPStatusCodeFromError } from '@trpc/server/http';\n¬†\n// Example error you might get if your input validation fails\nconst error: TRPCError = {\n  name: 'TRPCError',\n  code: 'BAD_REQUEST',\n  message: '\"password\" must be at least 4 characters',\n};\n¬†\nif (error instanceof TRPCError) {\n  const httpCode = getHTTPStatusCodeFromError(error);\n  console.log(httpCode); // 400\n}\nCopy\nTIP\n\nThere's a full example of how this could be used in a Next.js API endpoint in the Server Side Calls docs.\n\nThrowing errors‚Äã\n\ntRPC provides an error subclass, TRPCError, which you can use to represent an error that occurred inside a procedure.\n\nFor example, throwing this error:\n\nserver.ts\nimport { initTRPC, TRPCError } from '@trpc/server';\nconst t = initTRPC.create();\nconst appRouter = t.router({\n  hello: t.procedure.query(() => {\n    throw new TRPCError({\n      code: 'INTERNAL_SERVER_ERROR',\n      message: 'An unexpected error occurred, please try again later.',\n      // optional: pass the original error to retain stack trace\n      cause: theError,\n    });\n  }),\n});\n// [...]\nCopy\n\nResults to the following response:\n\n{\n  \"id\": null,\n  \"error\": {\n    \"message\": \"An unexpected error occurred, please try again later.\",\n    \"code\": -32603,\n    \"data\": {\n      \"code\": \"INTERNAL_SERVER_ERROR\",\n      \"httpStatus\": 500,\n      \"stack\": \"...\",\n      \"path\": \"hello\"\n    }\n  }\n}\nCopy\nHandling errors‚Äã\n\nAll errors that occur in a procedure go through the onError method before being sent to the client. Here you can handle errors (To change errors see error formatting).\n\npages/api/trpc/[trpc].ts\nexport default trpcNext.createNextApiHandler({\n  // ...\n  onError(opts) {\n    const { error, type, path, input, ctx, req } = opts;\n    console.error('Error:', error);\n    if (error.code === 'INTERNAL_SERVER_ERROR') {\n      // send to bug reporting\n    }\n  },\n});\nCopy\n\nThe onError parameter is an object that contains all information about the error and the context it occurs in:\n\n{\n  error: TRPCError; // the original error\n  type: 'query' | 'mutation' | 'subscription' | 'unknown';\n  path: string | undefined; // path of the procedure that was triggered\n  input: unknown;\n  ctx: Context | undefined;\n  req: BaseRequest; // request object\n}\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/error-formatting",
    "html": "Backend Usage\nError Formatting\nVersion: 11.x\nError Formatting\n\nThe error formatting in your router will be inferred all the way to your client (&¬†React¬†components)\n\nUsage example highlighted‚Äã\nAdding custom formatting‚Äã\nserver.ts\nimport { initTRPC } from '@trpc/server';\nexport const t = initTRPC.context<Context>().create({\n  errorFormatter(opts) {\n    const { shape, error } = opts;\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.code === 'BAD_REQUEST' && error.cause instanceof ZodError\n            ? error.cause.flatten()\n            : null,\n      },\n    };\n  },\n});\nCopy\nUsage in React‚Äã\ncomponents/MyComponent.tsx\nexport function MyComponent() {\n  const mutation = trpc.addPost.useMutation();\n  useEffect(() => {\n    mutation.mutate({ title: 'example' });\n  }, []);\n  if (mutation.error?.data?.zodError) {\n    // zodError will be inferred\n    return (\n      <pre>Error: {JSON.stringify(mutation.error.data.zodError, null, 2)}</pre>\n    );\n  }\n  return <>[...]</>;\n}\nCopy\nAll properties sent to errorFormatter()‚Äã\n\nSince v8.x tRPC is compliant with JSON-RPC 2.0\n\n{\n  error: TRPCError;\n  type: ProcedureType | 'unknown';\n  path: string | undefined;\n  input: unknown;\n  ctx: undefined | TContext;\n  shape: DefaultErrorShape; // the default error shape\n}\nCopy\n\nDefaultErrorShape:\n\ntype DefaultErrorData = {\n  code: TRPC_ERROR_CODE_KEY;\n  httpStatus: number;\n  /**\n   * Path to the procedure that threw the error\n   */\n  path?: string;\n  /**\n   * Stack trace of the error (only in development)\n   */\n  stack?: string;\n};\ninterface DefaultErrorShape {\n  message: string;\n  code: TRPC_ERROR_CODE_NUMBER;\n  data: DefaultErrorData;\n}\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/data-transformers",
    "html": "Backend Usage\nData Transformers\nVersion: 11.x\nData Transformers\n\nYou are able to serialize the response data & input args. The transformers need to be added both to the server and the client.\n\nUsing superjson‚Äã\n\nSuperJSON allows us to transparently use, e.g., standard Date/Map/Sets over the wire between the server and client. That is, you can return any of these types from your API-resolver and use them in the client without having to recreate the objects from JSON.\n\nHow to‚Äã\n1. Install‚Äã\nyarn add superjson\nCopy\n2. Add to your initTRPC‚Äã\nrouters/router/_app.ts\nimport { initTRPC } from '@trpc/server';\nimport superjson from 'superjson';\nexport const t = initTRPC.create({\n  transformer: superjson,\n});\nCopy\n3. Add to httpLink(), wsLink(), etc‚Äã\n\nTypeScript will guide you to where you need to add transformer as soon as you've added it on the initTRPC-object\n\ncreateTRPCClient():\n\nsrc/app/_trpc/client.ts\nimport { createTRPCClient } from '@trpc/client';\nimport type { AppRouter } from '~/server/routers/_app';\nimport superjson from 'superjson';\nexport const client = createTRPCClient<AppRouter>({\n  links: [\n    httpLink({\n      url: 'http://localhost:3000',\n      transformer: superjson,\n    }),\n  ],\n});\nCopy\nUsing devalue‚Äã\n\nDevalue works like superjson, but focus in performance and compact payloads, but at the cost of a less human readable body.\n\nHow to‚Äã\n1. Install‚Äã\nyarn add superjson devalue\nCopy\n2. Add to utils/trpc.ts‚Äã\n\nHere we use parse and stringify as they mitigate XSS.\n\nutils/trpc.ts\nimport { parse, stringify } from 'devalue';\n// [...]\nexport const transformer = {\n  deserialize: (object: any) => parse(object),\n  serialize: (object: any) => stringify(object),\n};\nCopy\n3. Add to your initTRPC‚Äã\nserver/routers/_app.ts\nimport { initTRPC } from '@trpc/server';\nimport { transformer } from '../../utils/trpc';\nexport const t = initTRPC.create({\n  transformer,\n});\nCopy\n4. Add to httpLink(), wsLink(), etc‚Äã\n\nTypeScript will guide you to where you need to add transformer as soon as you've added it on the initTRPC-object\n\ncreateTRPCClient():\n\nsrc/app/_trpc/client.ts\nimport { createTRPCClient } from '@trpc/client';\nimport type { AppRouter } from '~/server/routers/_app';\nimport { transformer } from '../../utils/trpc';\nexport const client = createTRPCClient<AppRouter>({\n  links: [\n    httpLink({\n      url: 'http://localhost:3000',\n      transformer,\n    }),\n  ],\n});\nCopy\nDifferent transformers for upload and download‚Äã\n\nIf a transformer should only be used for one direction or different transformers should be used for upload and download (e.g., for performance reasons), you can provide individual transformers for upload and download. Make sure you use the same combined transformer everywhere.\n\nDataTransformer interface‚Äã\nexport interface DataTransformer {\n  serialize(object: any): any;\n  deserialize(object: any): any;\n}\ninterface InputDataTransformer extends DataTransformer {\n  /**\n   * This function runs **on the client** before sending the data to the server.\n   */\n  serialize(object: any): any;\n  /**\n   * This function runs **on the server** to transform the data before it is passed to the resolver\n   */\n  deserialize(object: any): any;\n}\ninterface OutputDataTransformer extends DataTransformer {\n  /**\n   * This function runs **on the server** before sending the data to the client.\n   */\n  serialize(object: any): any;\n  /**\n   * This function runs **only on the client** to transform the data sent from the server.\n   */\n  deserialize(object: any): any;\n}\nexport interface CombinedDataTransformer {\n  /**\n   * Specify how the data sent from the client to the server should be transformed.\n   */\n  input: InputDataTransformer;\n  /**\n   * Specify how the data sent from the server to the client should be transformed.\n   */\n  output: OutputDataTransformer;\n}\nCopy\nEdit this page"
  },
  {
    "title": "Metadata | tRPC",
    "url": "https://trpc.io/docs/server/metadata",
    "html": "Backend Usage\nMetadata\nVersion: 11.x\nMetadata\n\nProcedure metadata allows you to add an optional procedure specific meta property which will be available in all middleware function parameters.\n\nTIP\n\nUse metadata together with trpc-openapi if you want to expose REST-compatible endpoints for your application.\n\nCreate router with typed metadata‚Äã\nimport { initTRPC } from '@trpc/server';\n// [...]\ninterface Meta {\n  authRequired: boolean;\n}\nexport const t = initTRPC.context<Context>().meta<Meta>().create();\nexport const appRouter = t.router({\n  // [...]\n});\nCopy\nExample with per route authentication settings‚Äã\nserver.ts\nimport { initTRPC } from '@trpc/server';\n// [...]\ninterface Meta {\n  authRequired: boolean;\n}\nexport const t = initTRPC.context<Context>().meta<Meta>().create();\nexport const authedProcedure = t.procedure.use(async (opts) => {\n  const { meta, next, ctx } = opts;\n  // only check authorization if enabled\n  if (meta?.authRequired && !ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n  return next();\n});\nexport const appRouter = t.router({\n  hello: authedProcedure.meta({ authRequired: false }).query(() => {\n    return {\n      greeting: 'hello world',\n    };\n  }),\n  protectedHello: authedProcedure.meta({ authRequired: true }).query(() => {\n    return {\n      greeting: 'hello-world',\n    };\n  }),\n});\nCopy\nDefault meta, chaining, and shallow merging‚Äã\n\nYou can set default values for your meta type, and if you chain meta on top of a base procedure it will be shallow merged.\n\nimport { initTRPC } from '@trpc/server';\ninterface Meta {\n  authRequired: boolean;\n  role?: 'user' | 'admin'\n}\nexport const t = initTRPC\n  .context<Context>()\n  .meta<Meta>()\n  .create({\n    // Set a default value\n    defaultMeta: { authRequired: false }\n  });\nconst publicProcedure = t.procedure\n// ^ Default Meta: { authRequired: false }\nconst authProcedure = publicProcedure\n  .use(authMiddleware)\n  .meta({\n    authRequired: true;\n    role: 'user'\n  });\n// ^ Meta: { authRequired: true, role: 'user' }\nconst adminProcedure = authProcedure\n  .meta({\n    role: 'admin'\n  });\n// ^ Meta: { authRequired: true, role: 'admin' }\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/caching",
    "html": "Backend Usage\nResponse Caching\nVersion: 11.x\nResponse Caching\n\nThe below examples uses Vercel's edge caching to serve data to your users as fast as possible.\n\nINFO\n\nAlways be careful with caching - especially if you handle personal information.\n\n¬†\nSince batching is enabled by default, it's recommended to set your cache headers in the responseMeta function and make sure that there are not any concurrent calls that may include personal data - or to omit cache headers completely if there is an auth header or cookie.\n\n¬†\nYou can also use a splitLink to split your public requests and those that should be private and uncached.\n\nApp Caching‚Äã\n\nIf you turn on SSR in your app, you might discover that your app loads slowly on, for instance, Vercel, but you can actually statically render your whole app without using SSG; read this Twitter thread for more insights.\n\nExample code‚Äã\nutils/trpc.tsx\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport type { AppRouter } from '../server/routers/_app';\nexport const trpc = createTRPCNext<AppRouter>({\n  config(config) {\n    if (typeof window !== 'undefined') {\n      return {\n        links: [\n          httpBatchLink({\n            url: '/api/trpc',\n          }),\n        ],\n      };\n    }\n    const url = process.env.VERCEL_URL\n      ? `https://${process.env.VERCEL_URL}/api/trpc`\n      : 'http://localhost:3000/api/trpc';\n    return {\n      links: {\n        http: httpBatchLink({\n          url,\n        }),\n      },\n    };\n  },\n  ssr: true,\n  responseMeta(opts) {\n    const { clientErrors } = opts;\n    if (clientErrors.length) {\n      // propagate http first error from API calls\n      return {\n        status: clientErrors[0].data?.httpStatus ?? 500,\n      };\n    }\n    // cache request for 1 day + revalidate once every second\n    const ONE_DAY_IN_SECONDS = 60 * 60 * 24;\n    return {\n      headers: new Headers([\n        [\n          'cache-control',\n          `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,\n        ],\n      ]),\n    };\n  },\n});\nCopy\nAPI Response caching‚Äã\n\nSince all queries are normal HTTP GETs, we can use normal HTTP headers to cache responses, make the responses snappy, give your database a rest, and easily scale your API to gazillions of users.\n\nUsing responseMeta to cache responses‚Äã\n\nAssuming you're deploying your API somewhere that can handle stale-while-revalidate cache headers like Vercel.\n\nserver.ts\nimport { initTRPC } from '@trpc/server';\nimport * as trpcNext from '@trpc/server/adapters/next';\nexport const createContext = async ({\n  req,\n  res,\n}: trpcNext.CreateNextContextOptions) => {\n  return {\n    req,\n    res,\n    prisma,\n  };\n};\ntype Context = Awaited<ReturnType<typeof createContext>>;\nexport const t = initTRPC.context<Context>().create();\nconst waitFor = async (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\nexport const appRouter = t.router({\n  public: t.router({\n    slowQueryCached: t.procedure.query(async (opts) => {\n      await waitFor(5000); // wait for 5s\n      return {\n        lastUpdated: new Date().toJSON(),\n      };\n    }),\n  }),\n});\n// Exporting type _type_ AppRouter only exposes types that can be used for inference\n// https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export\nexport type AppRouter = typeof appRouter;\n// export API handler\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  responseMeta(opts) {\n    const { ctx, paths, errors, type } = opts;\n    // assuming you have all your public routes with the keyword `public` in them\n    const allPublic = paths && paths.every((path) => path.includes('public'));\n    // checking that no procedures errored\n    const allOk = errors.length === 0;\n    // checking we're doing a query request\n    const isQuery = type === 'query';\n    if (ctx?.res && allPublic && allOk && isQuery) {\n      // cache request for 1 day + revalidate once every second\n      const ONE_DAY_IN_SECONDS = 60 * 60 * 24;\n      return {\n        headers: new Headers([\n          [\n            'cache-control',\n            `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,\n          ],\n        ]),\n      };\n    }\n    return {};\n  },\n});\nCopy\nEdit this page"
  },
  {
    "title": "Subscriptions | tRPC",
    "url": "https://trpc.io/docs/server/subscriptions",
    "html": "Backend Usage\nSubscriptions\nVersion: 11.x\nSubscriptions\nIntroduction‚Äã\n\nSubscriptions are a type of real-time event stream between the client and server. Use subscriptions when you need to push real-time updates to the client.\n\nWith tRPC's subscriptions, the client establishes and maintains a persistent connection to the server plus automatically attempts to reconnect and recover gracefully if disconnected with the help of tracked() events.\n\nWebSockets or Server-sent Events?‚Äã\n\nYou can either use WebSockets or Server-sent Events (SSE) to setup real-time subscriptions in tRPC.\n\nFor WebSockets, see the WebSockets page\nFor SSE, see the httpSubscriptionLink\n\nIf you are unsure which one to use, we recommend using SSE for subscriptions as it's easier to setup and don't require setting up a WebSocket server.\n\nReference projects‚Äã\nType\tExample Type\tLink\nWebSockets\tBare-minimum Node.js WebSockets example\t/examples/standalone-server\nSSE\tFull-stack SSE implementation\tgithub.com/trpc/examples-next-sse-chat\nWebSockets\tFull-stack WebSockets implementation\tgithub.com/trpc/examples-next-prisma-websockets-starter\nBasic example‚Äã\nTIP\n\nFor a full example, see our full-stack SSE example.\n\nserver.ts\nimport { initTRPC } from '@trpc/server';\nconst t = initTRPC.create();\nconst ee = new EventEmitter();\nexport const appRouter = router({\n  onPostAdd: publicProcedure.subscription(async function* (opts) {\n    // listen for new events\n    for await (const [data] of on(ee, 'add', {\n      // Passing the AbortSignal from the request automatically cancels the event emitter when the request is aborted\n      signal: opts.signal,\n    })) {\n      const post = data as Post;\n      yield post;\n    }\n  }),\n});\nCopy\nAutomatic tracking of id using tracked() (recommended)‚Äã\n\nIf you yield an event using our tracked()-helper and include an id, the client will automatically reconnect when it gets disconnected and send the last known ID.\n\nYou can send an initial lastEventId when initializing the subscription and it will be automatically updated as the browser receives data.\n\nFor SSE, this is part of the EventSource-spec and will be propagated through lastEventId in your .input().\nFor WebSockets, our wsLink will automatically send the last known ID and update it as the browser receives data.\nTIP\n\nIf you're fetching data based on the lastEventId, and capturing all events is critical, make sure you setup the event listener before fetching events from your database as is done in our full-stack SSE example, this can prevent newly emitted events being ignored while yield'ing the original batch based on lastEventId.\n\nimport EventEmitter, { on } from 'events';\nimport type { Post } from '@prisma/client';\nimport { tracked } from '@trpc/server';\nimport { z } from 'zod';\nimport { publicProcedure, router } from '../trpc';\nconst ee = new EventEmitter();\nexport const subRouter = router({\n  onPostAdd: publicProcedure\n    .input(\n      z\n        .object({\n          // lastEventId is the last event id that the client has received\n          // On the first call, it will be whatever was passed in the initial setup\n          // If the client reconnects, it will be the last event id that the client received\n          lastEventId: z.string().nullish(),\n        })\n        .optional(),\n    )\n    .subscription(async function* (opts) {\n      // We start by subscribing to the ee so that we don't miss any new events while fetching\n      const iterable = ee.toIterable('add', {\n        // Passing the AbortSignal from the request automatically cancels the event emitter when the request is aborted\n        signal: opts.signal,\n      });\n      if (opts.input.lastEventId) {\n        // [...] get the posts since the last event id and yield them\n        // const items = await db.post.findMany({ ... })\n        // for (const item of items) {\n        //   yield tracked(item.id, item);\n        // }\n      }\n      // listen for new events\n      for await (const [data] of on(ee, 'add', {\n        signal: opts.signal,\n      })) {\n        const post = data as Post;\n        // tracking the post id ensures the client can reconnect at any time and get the latest events this id\n        yield tracked(post.id, post);\n      }\n    }),\n});\nCopy\nPull data in a loop‚Äã\n\nThis recipe is useful when you want to periodically check for new data from a source like a database and push it to the client.\n\nserver.ts\nimport type { Post } from '@prisma/client';\nimport { tracked } from '@trpc/server';\nimport { z } from 'zod';\nimport { publicProcedure, router } from '../trpc';\nexport const subRouter = router({\n  onPostAdd: publicProcedure\n    .input(\n      z.object({\n        // lastEventId is the last event id that the client has received\n        // On the first call, it will be whatever was passed in the initial setup\n        // If the client reconnects, it will be the last event id that the client received\n        // The id is the createdAt of the post\n        lastEventId: z.coerce.date().nullish(),\n      }),\n    )\n    .subscription(async function* (opts) {\n      // `opts.signal` is an AbortSignal that will be aborted when the client disconnects.\n      let lastEventId = opts.input?.lastEventId ?? null;\n      // We use a `while` loop that checks `!opts.signal.aborted`\n      while (!opts.signal!.aborted) {\n        const posts = await db.post.findMany({\n          // If we have a `lastEventId`, we only fetch posts created after it.\n          where: lastEventId\n            ? {\n                createdAt: {\n                  gt: lastEventId,\n                },\n              }\n            : undefined,\n          orderBy: {\n            createdAt: 'asc',\n          },\n        });\n        for (const post of posts) {\n          // `tracked` is a helper that sends an `id` with each event.\n          // This allows the client to resume from the last received event upon reconnection.\n          yield tracked(post.createdAt.toJSON(), post);\n          lastEventId = post.createdAt;\n        }\n        // Wait for a bit before polling again to avoid hammering the database.\n        await sleep(1_000);\n      }\n    }),\n});\nCopy\nStopping a subscription from the server‚Äã\n\nIf you need to stop a subscription from the server, simply return in the generator function.\n\nimport { publicProcedure, router } from '../trpc';\nexport const subRouter = router({\n  onPostAdd: publicProcedure\n    .input(\n      z.object({\n        lastEventId: z.string().coerce.number().min(0).optional(),\n      }),\n    )\n    .subscription(async function* (opts) {\n      let index = opts.input.lastEventId ?? 0;\n      while (!opts.signal!.aborted) {\n        const idx = index++;\n        if (idx > 100) {\n          // With this, the subscription will stop and the client will disconnect\n          return;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 10));\n      }\n    }\n  }),\n});\nCopy\n\nOn the client, you just .unsubscribe() the subscription.\n\nCleanup of side effects‚Äã\n\nIf you need to clean up any side-effects of your subscription you can use the try...finally pattern, as trpc invokes the .return() of the Generator Instance when the subscription stops for any reason.\n\nimport EventEmitter, { on } from 'events';\nimport type { Post } from '@prisma/client';\nimport { z } from 'zod';\nimport { publicProcedure, router } from '../trpc';\nconst ee = new EventEmitter();\nexport const subRouter = router({\n  onPostAdd: publicProcedure.subscription(async function* (opts) {\n    let timeout;\n    try {\n      for await (const [data] of on(ee, 'add', {\n        signal: opts.signal,\n      })) {\n        timeout = setTimeout(() => console.log('Pretend like this is useful'));\n        const post = data as Post;\n        yield post;\n      }\n    } finally {\n      if (timeout) clearTimeout(timeout);\n    }\n  }),\n});\nCopy\nError handling‚Äã\n\nThrowing an error in a generator function propagates to trpc's onError() on the backend.\n\nIf the error thrown is a 5xx error, the client will automatically attempt to reconnect based on the last event id that is tracked using tracked(). For other errors, the subscription will be cancelled and propagate to the onError() callback.\n\nOutput validation‚Äã\n\nSince subscriptions are async iterators, you have to go through the iterator to validate the output.\n\nExample with zod‚Äã\nzAsyncIterable.ts\nimport type { TrackedEnvelope } from '@trpc/server';\nimport { isTrackedEnvelope, tracked } from '@trpc/server';\nimport { z } from 'zod';\nfunction isAsyncIterable<TValue, TReturn = unknown>(\n  value: unknown,\n): value is AsyncIterable<TValue, TReturn> {\n  return !!value && typeof value === 'object' && Symbol.asyncIterator in value;\n}\nconst trackedEnvelopeSchema =\n  z.custom<TrackedEnvelope<unknown>>(isTrackedEnvelope);\n/**\n * A Zod schema helper designed specifically for validating async iterables. This schema ensures that:\n * 1. The value being validated is an async iterable.\n * 2. Each item yielded by the async iterable conforms to a specified type.\n * 3. The return value of the async iterable, if any, also conforms to a specified type.\n */\nexport function zAsyncIterable<\n  TYieldIn,\n  TYieldOut,\n  TReturnIn = void,\n  TReturnOut = void,\n  Tracked extends boolean = false,\n>(opts: {\n  /**\n   * Validate the value yielded by the async generator\n   */\n  yield: z.ZodType<TYieldIn, any, TYieldOut>;\n  /**\n   * Validate the return value of the async generator\n   * @remark not applicable for subscriptions\n   */\n  return?: z.ZodType<TReturnIn, any, TReturnOut>;\n  /**\n   * Whether if the yielded values are tracked\n   * @remark only applicable for subscriptions\n   */\n  tracked?: Tracked;\n}) {\n  return z\n    .custom<\n      AsyncIterable<\n        Tracked extends true ? TrackedEnvelope<TYieldIn> : TYieldIn,\n        TReturnIn\n      >\n    >((val) => isAsyncIterable(val))\n    .transform(async function* (iter) {\n      const iterator = iter[Symbol.asyncIterator]();\n      try {\n        let next;\n        while ((next = await iterator.next()) && !next.done) {\n          if (opts.tracked) {\n            const [id, data] = trackedEnvelopeSchema.parse(next.value);\n            yield tracked(id, await opts.yield.parseAsync(data));\n            continue;\n          }\n          yield opts.yield.parseAsync(next.value);\n        }\n        if (opts.return) {\n          return await opts.return.parseAsync(next.value);\n        }\n        return;\n      } finally {\n        await iterator.return?.();\n      }\n    }) as z.ZodType<\n    AsyncIterable<\n      Tracked extends true ? TrackedEnvelope<TYieldIn> : TYieldIn,\n      TReturnIn,\n      unknown\n    >,\n    any,\n    AsyncIterable<\n      Tracked extends true ? TrackedEnvelope<TYieldOut> : TYieldOut,\n      TReturnOut,\n      unknown\n    >\n  >;\n}\nCopy\n\nNow you can use this helper to validate the output of your subscription procedures:\n\n_app.ts\nimport { publicProcedure, router } from '../trpc';\nimport { zAsyncIterable } from './zAsyncIterable';\nexport const appRouter = router({\n  mySubscription: publicProcedure\n    .input(\n      z.object({\n        lastEventId: z.coerce.number().min(0).optional(),\n      }),\n    )\n    .output(\n      zAsyncIterable({\n        yield: z.object({\n          count: z.number(),\n        }),\n        tracked: true,\n      }),\n    )\n    .subscription(async function* (opts) {\n      let index = opts.input.lastEventId ?? 0;\n      while (true) {\n        index++;\n        yield tracked(index, {\n          count: index,\n        });\n        await new Promise((resolve) => setTimeout(resolve, 1000));\n      }\n    }),\n});\nCopy\nEdit this page"
  },
  {
    "title": "WebSockets | tRPC",
    "url": "https://trpc.io/docs/server/websockets",
    "html": "Backend Usage\nWebSockets\nVersion: 11.x\nWebSockets\n\nYou can use WebSockets for all or some of the communication with your server, see wsLink for how to set it up on the client.\n\nTIP\n\nThe document here outlines the specific details of using WebSockets. For general usage of subscriptions, see our subscriptions guide.\n\nCreating a WebSocket-server‚Äã\nyarn add ws\nCopy\nserver/wsServer.ts\nimport { applyWSSHandler } from '@trpc/server/adapters/ws';\nimport ws from 'ws';\nimport { appRouter } from './routers/app';\nimport { createContext } from './trpc';\nconst wss = new ws.Server({\n  port: 3001,\n});\nconst handler = applyWSSHandler({\n  wss,\n  router: appRouter,\n  createContext,\n  // Enable heartbeat messages to keep connection open (disabled by default)\n  keepAlive: {\n    enabled: true,\n    // server ping message interval in milliseconds\n    pingMs: 30000,\n    // connection is terminated if pong message is not received in this many milliseconds\n    pongWaitMs: 5000,\n  },\n});\nwss.on('connection', (ws) => {\n  console.log(`‚ûï‚ûï Connection (${wss.clients.size})`);\n  ws.once('close', () => {\n    console.log(`‚ûñ‚ûñ Connection (${wss.clients.size})`);\n  });\n});\nconsole.log('‚úÖ WebSocket Server listening on ws://localhost:3001');\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM');\n  handler.broadcastReconnectNotification();\n  wss.close();\n});\nCopy\nSetting TRPCClient to use WebSockets‚Äã\nTIP\n\nYou can use Links to route queries and/or mutations to HTTP transport and subscriptions over WebSockets.\n\nclient.ts\nimport { createTRPCClient, createWSClient, wsLink } from '@trpc/client';\nimport type { AppRouter } from '../path/to/server/trpc';\n// create persistent WebSocket connection\nconst wsClient = createWSClient({\n  url: `ws://localhost:3001`,\n});\n// configure TRPCClient to use WebSockets transport\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    wsLink({\n      client: wsClient,\n    }),\n  ],\n});\nCopy\nAuthentication / connection params‚Äã\nTIP\n\nIf you're doing a web application, you can ignore this section as the cookies are sent as part of the request.\n\nIn order to authenticate with WebSockets, you can define connectionParams to createWSClient. This will be sent as the first message when the client establishes a WebSocket connection.\n\nserver/context.ts\nimport type { CreateWSSContextFnOptions } from '@trpc/server/adapters/ws';\n¬†\nexport const createContext = async (opts: CreateWSSContextFnOptions) => {\n  const token = opts.info.connectionParams?.token;\n         \nconst token: string | undefined\n¬†\n  // [... authenticate]\n¬†\n  return {};\n};\n¬†\nexport type Context = Awaited<ReturnType<typeof createContext>>;\nCopy\nclient/trpc.ts\nimport { createTRPCClient, createWSClient, wsLink } from '@trpc/client';\nimport type { AppRouter } from '~/server/routers/_app';\nconst wsClient = createWSClient({\n  url: `ws://localhost:3000`,\n  connectionParams: async () => {\n    return {\n      token: 'supersecret',\n    };\n  },\n});\nexport const trpc = createTRPCClient<AppRouter>({\n  links: [wsLink({ client: wsClient, transformer: superjson })],\n});\nCopy\nAutomatic tracking of id using tracked() (recommended)‚Äã\n\nIf you yield an event using our tracked()-helper and include an id, the client will automatically reconnect when it gets disconnected and send the last known ID when reconnecting as part of the lastEventId-input.\n\nYou can send an initial lastEventId when initializing the subscription and it will be automatically updated as the browser receives data.\n\nINFO\n\nIf you're fetching data based on the lastEventId, and capturing all events is critical, you may want to use ReadableStream's or a similar pattern as an intermediary as is done in our full-stack SSE example to prevent newly emitted events being ignored while yield'ing the original batch based on lastEventId.\n\nimport EventEmitter, { on } from 'events';\nimport { tracked } from '@trpc/server';\nimport { z } from 'zod';\nimport { publicProcedure, router } from '../trpc';\nconst ee = new EventEmitter();\nexport const subRouter = router({\n  onPostAdd: publicProcedure\n    .input(\n      z\n        .object({\n          // lastEventId is the last event id that the client has received\n          // On the first call, it will be whatever was passed in the initial setup\n          // If the client reconnects, it will be the last event id that the client received\n          lastEventId: z.string().nullish(),\n        })\n        .optional(),\n    )\n    .subscription(async function* (opts) {\n      if (opts.input.lastEventId) {\n        // [...] get the posts since the last event id and yield them\n      }\n      // listen for new events\n      for await (const [data] of on(ee, 'add', {\n        // Passing the AbortSignal from the request automatically cancels the event emitter when the subscription is aborted\n        signal: opts.signal,\n      })) {\n        const post = data as Post;\n        // tracking the post id ensures the client can reconnect at any time and get the latest events this id\n        yield tracked(post.id, post);\n      }\n    }),\n});\nCopy\nWebSockets RPC Specification‚Äã\n\nYou can read more details by drilling into the TypeScript definitions:\n\n/packages/server/src/unstable-core-do-not-import/rpc/envelopes.ts\n/packages/server/src/unstable-core-do-not-import/rpc/codes.ts.\nquery / mutation‚Äã\nRequest‚Äã\n{\n  id: number | string;\n  jsonrpc?: '2.0'; // optional\n  method: 'query' | 'mutation';\n  params: {\n    path: string;\n    input?: unknown; // <-- pass input of procedure, serialized by transformer\n  };\n}\nCopy\nResponse‚Äã\n\n... below, or an error.\n\n{\n  id: number | string;\n  jsonrpc?: '2.0'; // only defined if included in request\n  result: {\n    type: 'data'; // always 'data' for mutation / queries\n    data: TOutput; // output from procedure\n  }\n}\nCopy\nsubscription / subscription.stop‚Äã\nStart a subscription‚Äã\n{\n  id: number | string;\n  jsonrpc?: '2.0';\n  method: 'subscription';\n  params: {\n    path: string;\n    input?: unknown; // <-- pass input of procedure, serialized by transformer\n  };\n}\nCopy\nTo cancel a subscription, call subscription.stop‚Äã\n{\n  id: number | string; // <-- id of your created subscription\n  jsonrpc?: '2.0';\n  method: 'subscription.stop';\n}\nCopy\nSubscription response shape‚Äã\n\n... below, or an error.\n\n{\n  id: number | string;\n  jsonrpc?: '2.0';\n  result: (\n    | {\n        type: 'data';\n        data: TData; // subscription emitted data\n      }\n    | {\n        type: 'started'; // subscription started\n      }\n    | {\n        type: 'stopped'; // subscription stopped\n      }\n  )\n}\nCopy\nConnection params‚Äã\n\nIf the connection is initialized with ?connectionParams=1, the first message has to be connection params.\n\n{\n  data: Record<string, string> | null;\n  method: 'connectionParams';\n}\nCopy\nErrors‚Äã\n\nSee https://www.jsonrpc.org/specification#error_object or Error Formatting.\n\nNotifications from Server to Client‚Äã\n{ id: null, type: 'reconnect' }‚Äã\n\nTells clients to reconnect before shutting down the server. Invoked by wssHandler.broadcastReconnectNotification().\n\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/adapters/standalone",
    "html": "Backend Usage\nHosting tRPC with Adapters\nStandalone\nVersion: 11.x\nStandalone Adapter\n\ntRPC's Standalone Adapter is the simplest way to get a new project working. It's ideal for local development, and for server-based production environments. In essence it's just a wrapper around the standard Node.js HTTP Server with the normal options related to tRPC.\n\nIf you have an existing API deployment like Express, Fastify, or Next.js, which you want to integrate tRPC into, you should have a look at their respective adapters. Likewise if you have a preference to host on serverless or edge compute, we have adapters like AWS Lambda and Fetch which may fit your needs.\n\nIt's also not uncommon, where the deployed adapter is hard to run on local machines, to have 2 entry-points in your application. You could use the Standalone Adapter for local development, and a different adapter when deployed.\n\nExample app‚Äã\nDescription\tLinks\nStandalone tRPC Server\t\nStackBlitz\nSource\n\nStandalone tRPC Server with CORS handling\t\nStackBlitz\nSource\nSetting up a Standalone tRPC Server‚Äã\n1. Implement your App Router‚Äã\n\nImplement your tRPC router. For example:\n\nappRouter.ts\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\nexport const t = initTRPC.create();\nexport const appRouter = t.router({\n  getUser: t.procedure.input(z.string()).query((opts) => {\n    return { id: opts.input, name: 'Bilbo' };\n  }),\n  createUser: t.procedure\n    .input(z.object({ name: z.string().min(5) }))\n    .mutation(async (opts) => {\n      // use your ORM of choice\n      return await UserModel.create({\n        data: opts.input,\n      });\n    }),\n});\n// export type definition of API\nexport type AppRouter = typeof appRouter;\nCopy\n\nFor more information you can look at the quickstart guide\n\n2. Use the Standalone adapter‚Äã\n\nThe Standalone adapter runs a simple Node.js HTTP server.\n\nserver.ts\nimport { initTRPC } from '@trpc/server';\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\nimport { appRouter } from './appRouter.ts';\ncreateHTTPServer({\n  router: appRouter,\n  createContext() {\n    console.log('context 3');\n    return {};\n  },\n  // basePath: '/trpc/', // optional, defaults to '/'\n}).listen(2022);\nCopy\nHandling CORS & OPTIONS‚Äã\n\nBy default the standalone server will not respond to HTTP OPTIONS requests, or set any CORS headers.\n\nIf you're not hosting in an environment which can handle this for you, like during local development, you may need to handle it.\n\n1. Install cors‚Äã\n\nYou can add support yourself with the popular cors package\n\nyarn add cors\nyarn add -D @types/cors\nCopy\n\nFor full information on how to configure this package, check the docs\n\n2. Configure the Standalone server‚Äã\n\nThis example just throws open CORS to any request, which is useful for development, but you can and should configure it more strictly in a production environment.\n\nserver.ts\nimport { initTRPC } from '@trpc/server';\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\nimport cors from 'cors';\ncreateHTTPServer({\n  middleware: cors(),\n  router: appRouter,\n  createContext() {\n    console.log('context 3');\n    return {};\n  },\n}).listen(3333);\nCopy\n\nThe middleware option will accept any function which resembles a connect/node.js middleware, so it can be used for more than cors handling if you wish. It is, however, intended to be a simple escape hatch and as such won't on its own allow you to compose multiple middlewares together. If you want to do this then you could:\n\nUse an alternate adapter with more comprehensive middleware support, like the Express adapter\nUse a solution to compose middlewares such as connect\nExtend the Standalone createHTTPHandler with a custom http server (see below)\nAdding a handler to an Custom HTTP server‚Äã\n\ncreateHTTPServer is returning an instance of Node's built-in http.Server(https://nodejs.org/api/http.html#class-httpserver), which means that you have an access to all it's properties and APIs. However, if createHTTPServer isn't enough for your usecase, you can also use the standalone adapter's createHTTPHandler function to create your own HTTP server. For instance:\n\nserver.ts\nimport { createServer } from 'http';\nimport { initTRPC } from '@trpc/server';\nimport { createHTTPHandler } from '@trpc/server/adapters/standalone';\nconst handler = createHTTPHandler({\n  router: appRouter,\n  createContext() {\n    return {};\n  },\n});\ncreateServer((req, res) => {\n  /**\n   * Handle the request however you like,\n   * just call the tRPC handler when you're ready\n   */\n  handler(req, res);\n}).listen(3001);\nCopy\nCustom base path to handle requests under‚Äã\n\nThe Standalone adapter also supports a basePath option, which will slice the basePath from the beginning of the request path.\n\nserver.ts\nimport { createServer } from 'http';\nimport { initTRPC } from '@trpc/server';\nimport { createHTTPHandler } from '@trpc/server/adapters/standalone';\nconst handler = createHTTPHandler({\n  router: appRouter,\n  basePath: '/trpc/',\n});\ncreateServer((req, res) => {\n  if (req.url?.startsWith('/trpc/')) {\n    return handler(req, res);\n  }\n  // [... insert your custom logic here ...]\n  res.statusCode = 404;\n  res.end('Not Found');\n}).listen(3001);\nCopy\nHTTP2‚Äã\n\nThe Standalone adapter also supports HTTP/2.\n\nserver.ts\nimport http2 from 'http2';\nimport { createHTTP2Handler } from '@trpc/server/adapters/standalone';\nimport { appRouter } from './_app.ts';\nimport { createContext } from './context.ts';\nconst handler = createHTTP2Handler({\n  router: appRouter,\n  createContext,\n  // basePath: '/trpc/', // optional, defaults to '/'\n});\nconst server = http2.createSecureServer(\n  {\n    key: '...',\n    cert: '...',\n  },\n  (req, res) => {\n    /**\n     * Handle the request however you like,\n     * just call the tRPC handler when you're ready\n     */\n    handler(req, res);\n  },\n);\nserver.listen(3001);\nCopy\ncontext.ts\nimport { CreateHTTP2ContextOptions } from '@trpc/server/adapters/standalone';\n¬†\nexport async function createContext(opts: CreateHTTP2ContextOptions) {\n  opts.req;\n       \n(property) req: http2.Http2ServerRequest\n  opts.res;\n       \n(property) res: http2.Http2ServerResponse\n¬†\n  opts.info;\n        \n(property) info: TRPCRequestInfo\n  return {};\n}\n¬†\nexport type Context = Awaited<ReturnType<typeof createContext>>;\nCopy\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/adapters/express",
    "html": "Backend Usage\nHosting tRPC with Adapters\nExpress\nVersion: 11.x\nExpress Adapter\nExample app‚Äã\nDescription\tLinks\nExpress server & procedure calls with Node.js.\t\nCodeSandbox\nSource\nHow to add tRPC to existing Express project‚Äã\n1. Install deps‚Äã\nyarn add @trpc/server zod\nCopy\n\nZod isn't a required dependency, but it's used in the sample router below.\n\n2. Create a tRPC router‚Äã\n\nImplement your tRPC router. A sample router is given below:\n\nserver.ts\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\nexport const t = initTRPC.create();\nexport const appRouter = t.router({\n  getUser: t.procedure.input(z.string()).query((opts) => {\n    opts.input; // string\n    return { id: opts.input, name: 'Bilbo' };\n  }),\n  createUser: t.procedure\n    .input(z.object({ name: z.string().min(5) }))\n    .mutation(async (opts) => {\n      // use your ORM of choice\n      return await UserModel.create({\n        data: opts.input,\n      });\n    }),\n});\n// export type definition of API\nexport type AppRouter = typeof appRouter;\nCopy\n\nIf your router file starts getting too big, split your router into several subrouters each implemented in its own file. Then merge them into a single root appRouter.\n\n3. Use the Express adapter‚Äã\n\ntRPC includes an adapter for Express out of the box. This adapter lets you convert your tRPC router into an Express middleware.\n\nserver.ts\nimport { initTRPC } from '@trpc/server';\nimport * as trpcExpress from '@trpc/server/adapters/express';\nimport express from 'express';\n// created for each request\nconst createContext = ({\n  req,\n  res,\n}: trpcExpress.CreateExpressContextOptions) => ({}); // no context\ntype Context = Awaited<ReturnType<typeof createContext>>;\nconst t = initTRPC.context<Context>().create();\nconst appRouter = t.router({\n  // [...]\n});\nconst app = express();\napp.use(\n  '/trpc',\n  trpcExpress.createExpressMiddleware({\n    router: appRouter,\n    createContext,\n  }),\n);\napp.listen(4000);\nCopy\n\nYour endpoints are now available via HTTP!\n\nEndpoint\tHTTP URI\ngetUser\tGET http://localhost:4000/trpc/getUser?input=INPUT\n\nwhere INPUT is a URI-encoded JSON string.\ncreateUser\tPOST http://localhost:4000/trpc/createUser\n\nwith req.body of type {name: string}\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/adapters/fastify",
    "html": "Backend Usage\nHosting tRPC with Adapters\nFastify\nVersion: 11.x\nFastify Adapter\nExample app‚Äã\n\nThe best way to start with the Fastify adapter is to take a look at the example application.\n\nDescription\tLinks\n\nFastify server with WebSocket\nSimple tRPC client in node\n\t\nCodeSandbox\nSource\nHow to use tRPC with Fastify‚Äã\nInstall dependencies‚Äã\nyarn add @trpc/server fastify zod\nCopy\n\nZod isn't a required dependency, but it's used in the sample router below.\n\nCreate the router‚Äã\n\nFirst of all you need a router to handle your queries, mutations and subscriptions.\n\nA sample router is given below, save it in a file named router.ts.\n\nrouter.ts\n\nIf your router file starts getting too big, split your router into several subrouters each implemented in its own file. Then merge them into a single root appRouter.\n\nCreate the context‚Äã\n\nThen you need a context that will be created for each request.\n\nA sample context is given below, save it in a file named context.ts:\n\ncontext.ts\nCreate Fastify server‚Äã\n\ntRPC includes an adapter for Fastify out of the box. This adapter lets you convert your tRPC router into a Fastify plugin. In order to prevent errors during large batch requests, make sure to set the maxParamLength Fastify option to a suitable value, as shown.\n\nTIP\n\nDue to limitations in Fastify's plugin system and type inference, there might be some issues getting for example onError typed correctly. You can add a satisfies FastifyTRPCPluginOptions<AppRouter>['trpcOptions'] to help TypeScript out and get the correct types.\n\nserver.ts\nimport {\n  fastifyTRPCPlugin,\n  FastifyTRPCPluginOptions,\n} from '@trpc/server/adapters/fastify';\nimport fastify from 'fastify';\nimport { createContext } from './context';\nimport { appRouter, type AppRouter } from './router';\nconst server = fastify({\n  maxParamLength: 5000,\n});\nserver.register(fastifyTRPCPlugin, {\n  prefix: '/trpc',\n  trpcOptions: {\n    router: appRouter,\n    createContext,\n    onError({ path, error }) {\n      // report to error monitoring\n      console.error(`Error in tRPC handler on path '${path}':`, error);\n    },\n  } satisfies FastifyTRPCPluginOptions<AppRouter>['trpcOptions'],\n});\n(async () => {\n  try {\n    await server.listen({ port: 3000 });\n  } catch (err) {\n    server.log.error(err);\n    process.exit(1);\n  }\n})();\nCopy\n\nYour endpoints are now available via HTTP!\n\nEndpoint\tHTTP URI\ngetUser\tGET http://localhost:3000/trpc/getUserById?input=INPUT\n\nwhere INPUT is a URI-encoded JSON string.\ncreateUser\tPOST http://localhost:3000/trpc/createUser\n\nwith req.body of type User\nEnable WebSockets‚Äã\n\nThe Fastify adapter supports WebSockets via the @fastify/websocket plugin. All you have to do in addition to the above steps is install the dependency, add some subscriptions to your router and activate the useWSS option in the plugin. The minimum Fastify version required for @fastify/websocket is 3.11.0.\n\nInstall dependencies‚Äã\nyarn add @fastify/websocket\nCopy\nImport and register @fastify/websocket‚Äã\nimport ws from '@fastify/websocket';\nserver.register(ws);\nCopy\nAdd some subscriptions‚Äã\n\nEdit the router.ts file created in the previous steps and add the following code:\n\nrouter.ts\nimport { initTRPC } from '@trpc/server';\nimport { observable } from '@trpc/server/observable';\nconst t = initTRPC.create();\nexport const appRouter = t.router({\n  randomNumber: t.procedure.subscription(async function* () {\n    while (true) {\n      yield { randomNumber: Math.random() };\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n    }\n  }),\n});\nCopy\nActivate the useWSS option‚Äã\nserver.ts\nserver.register(fastifyTRPCPlugin, {\n  useWSS: true,\n  // Enable heartbeat messages to keep connection open (disabled by default)\n  keepAlive: {\n    enabled: true,\n    // server ping message interval in milliseconds\n    pingMs: 30000,\n    // connection is terminated if pong message is not received in this many milliseconds\n    pongWaitMs: 5000,\n  },\n  // ...\n});\nCopy\n\nIt's alright, you can subscribe to the topic randomNumber and you should receive a random number every second üöÄ.\n\nFastify plugin options‚Äã\nname\ttype\toptional\tdefault\tdescription\nprefix\tstring\ttrue\t\"/trpc\"\t\nuseWSS\tboolean\ttrue\tfalse\t\ntrpcOptions\tNodeHTTPHandlerOptions\tfalse\tn/a\t\nEdit this page"
  },
  {
    "title": "tRPC",
    "url": "https://trpc.io/docs/server/adapters/nextjs",
    "html": "Backend Usage\nHosting tRPC with Adapters\nNext.js\nVersion: 11.x\nNext.js Adapter\nTIP\n\ntRPC's support for Next.js is far more expansive than just an adapter. This page covers a brief summary of how to set up the adapter, but complete documentation is available here\n\nExample app‚Äã\nDescription\tLinks\nNext.js Minimal Starter\t\nCodeSandbox\nSource\nNext.js example‚Äã\n\nServing your tRPC router in a Next.js project is straight-forward. Just create an API handler in pages/api/trpc/[trpc].ts as shown below:\n\npages/api/trpc/[trpc].ts\nimport { createNextApiHandler } from '@trpc/server/adapters/next';\nimport { createContext } from '../../../server/trpc/context';\nimport { appRouter } from '../../../server/trpc/router/_app';\n// @link https://nextjs.org/docs/api-routes/introduction\nexport default createNextApiHandler({\n  router: appRouter,\n  createContext,\n});\nCopy\nHandling CORS, and other Advanced usage‚Äã\n\nWhile you can usually just \"set and forget\" the API Handler as shown above, sometimes you might want to modify it further.\n\nThe API handler created by createNextApiHandler and equivalents in other frameworks is just a function that takes req and res objects. This means you can also modify those objects before passing them to the handler, for example to enable CORS.\n\npages/api/trpc/[trpc].ts\nimport { createNextApiHandler } from '@trpc/server/adapters/next';\nimport { createContext } from '../../../server/trpc/context';\nimport { appRouter } from '../../../server/trpc/router/_app';\n// create the API handler, but don't return it yet\nconst nextApiHandler = createNextApiHandler({\n  router: appRouter,\n  createContext,\n});\n// @link https://nextjs.org/docs/api-routes/introduction\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse,\n) {\n  // We can use the response object to enable CORS\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  res.setHeader('Access-Control-Request-Method', '*');\n  res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');\n  res.setHeader('Access-Control-Allow-Headers', '*');\n  // If you need to make authenticated CORS calls then\n  // remove what is above and uncomment the below code\n  // Allow-Origin has to be set to the requesting domain that you want to send the credentials back to\n  // res.setHeader('Access-Control-Allow-Origin', 'http://example:6006');\n  // res.setHeader('Access-Control-Request-Method', '*');\n  // res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');\n  // res.setHeader('Access-Control-Allow-Headers', 'content-type');\n  // res.setHeader('Referrer-Policy', 'no-referrer');\n  // res.setHeader('Access-Control-Allow-Credentials', 'true');\n  if (req.method === 'OPTIONS') {\n    res.writeHead(200);\n    return res.end();\n  }\n  // finally pass the request on to the tRPC handler\n  return nextApiHandler(req, res);\n}\nCopy\nRoute Handlers‚Äã\n\nIf you're trying out the Next.js App Router and want to use route handlers, you can do so by using the fetch adapter, as they build on web standard Request and Response objects:\n\napp/api/trpc/[trpc]/route.ts\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { appRouter } from '~/server/api/router';\nfunction handler(req: Request) {\n  return fetchRequestHandler({\n    endpoint: '/api/trpc',\n    req,\n    router: appRouter,\n    createContext: () => ({ ... })\n  });\n}\nexport { handler as GET, handler as POST };\nCopy\nEdit this page"
  },
  {
    "title": "AWS Lambda + API Gateway Adapter | tRPC",
    "url": "https://trpc.io/docs/server/adapters/aws-lambda",
    "html": "Backend Usage\nHosting tRPC with Adapters\nAWS Lambda + API Gateway\nVersion: 11.x\nAWS Lambda + API Gateway Adapter\nAWS Lambda adapter‚Äã\n\nThe AWS Lambda adapter is supported for API Gateway REST API(v1) and HTTP API(v2), and Lambda Function URL use cases.\n\nhttpBatchLink requires the router to work on a single API Gateway Resource (as shown in the example). If you'd like to have a Resource per procedure, you can use the httpLink instead (more info).\n\nExample app‚Äã\nDescription\tLinks\nAPI Gateway with NodeJS client.\t\nSource\nHow to add tRPC‚Äã\n1. Install deps‚Äã\nyarn add @trpc/server\nCopy\n2. Create a tRPC router‚Äã\n\nImplement your tRPC router. A sample router is given below:\n\nserver.ts\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\nexport const t = initTRPC.create();\nconst appRouter = t.router({\n  getUser: t.procedure.input(z.string()).query((opts) => {\n    opts.input; // string\n    return { id: opts.input, name: 'Bilbo' };\n  }),\n});\n// export type definition of API\nexport type AppRouter = typeof appRouter;\nCopy\n3. Use the Amazon API Gateway adapter‚Äã\n\ntRPC includes an adapter for API Gateway out of the box. This adapter lets you run your routes through the API Gateway handler.\n\nserver.ts\nimport { CreateAWSLambdaContextOptions, awsLambdaRequestHandler } from '@trpc/server/adapters/aws-lambda';\nconst appRouter = /* ... */;\n// created for each request\nconst createContext = ({\n  event,\n  context,\n}: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2>) => ({}) // no context\ntype Context = Awaited<ReturnType<typeof createContext>>;\nexport const handler = awsLambdaRequestHandler({\n  router: appRouter,\n  createContext,\n})\nCopy\n\nBuild & deploy your code, now use your API Gateway URL to call your function.\n\nEndpoint\tHTTP URI\ngetUser\tGET https://<execution-api-link>/getUser?input=INPUT\n\nwhere INPUT is a URI-encoded JSON string.\nA word about payload format version‚Äã\n\nAPI Gateway has two different event data formats when it invokes a Lambda. For REST APIs they should be version \"1.0\"(APIGatewayProxyEvent), but you can choose which for HTTP APIs by stating either version \"1.0\" or \"2.0\".\n\nVersion 1.0: APIGatewayProxyEvent\nVersion 2.0: APIGatewayProxyEventV2\n\nTo infer what version you might have, supply the context as following:\n\nfunction createContext({\n  event,\n  context,\n}: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>) {\n  ...\n}\n// CreateAWSLambdaContextOptions<APIGatewayProxyEvent> or CreateAWSLambdaContextOptions<APIGatewayProxyEventV2>\nCopy\n\nRead more here about payload format version\n\nAWS Lambda Response Streaming Adapter‚Äã\n\nAWS Lambda supports streaming responses to clients.\n\nResponse streaming is only supported for Lambda Function URLs. You can not use API Gateway to stream responses. Read more here about response streaming.\n\nExample app‚Äã\nDescription\tLinks\nLambda Function URL with NodeJS client.\t\nSource\nResponse Streaming‚Äã\n\nThe signature of a streaming handler is different from the default handler. The streaming handler additonally receives a writable stream parameter, responseStream, besides the default node handler parameters, event and context. To indicate that Lambda should stream your responses, you must wrap your function handler with the awslambda.streamifyResponse() decorator.\n\nNote that the awslambda namespace is automatically provided by the Lambda execution environment. You can import the types from @types/aws-lambda to augment the global namespace with the awslambda namespace.\n\nserver.ts\nimport { awsLambdaStreamingRequestHandler } from '@trpc/server/adapters/aws-lambda';\nimport type { StreamifyHandler } from 'aws-lambda';\nconst appRouter = router({\n  iterable: publicProcedure.query(async function* () {\n    for (let i = 0; i < 10; i++) {\n      await new Promise((resolve) => setTimeout(resolve, 500));\n      yield i;\n    }\n  }),\n});\nexport const handler = awslambda.streamifyResponse(\n  awsLambdaStreamingRequestHandler({\n    router: appRouter,\n    /* ... */\n  }),\n);\nCopy\nEdit this page"
  },
  {
    "title": "Fetch / Edge Runtimes Adapter | tRPC",
    "url": "https://trpc.io/docs/server/adapters/fetch",
    "html": "Backend Usage\nHosting tRPC with Adapters\nFetch / Edge Runtimes\nVersion: 11.x\nFetch / Edge Runtimes Adapter\n\nYou can create a tRPC server within any edge runtime that follow the WinterCG, specifically the Minimum Common Web Platform API specification.\n\nSome of these runtimes includes, but not limited to:\n\nCloudflare Workers\nDeno Deploy\nVercel Edge Runtime (& Next.js Edge Runtime)\n\nThis also makes it easy to integrate into frameworks that uses the web platform APIs to represent requests and responses, such as:\n\nAstro (SSR mode)\nRemix\nSolidStart\nExample apps‚Äã\nDescription\tLinks\nCloudflare Workers example\t\n\nSource\n\n\nDeno Deploy example\t\n\nSource\n\n\nNext.js Edge Runtime example\t\n\nSource\n\n\nVercel Edge Runtime example\t\n\nSource\n\nHow to use tRPC server with an edge runtime‚Äã\n\ntRPC provides a fetch adapter that uses the native Request and Response APIs as input and output. The tRPC-specific code is the same across all runtimes, the only difference being how the response is returned.\n\ntRPC includes an adapter for the native Fetch API out of the box. This adapter lets you convert your tRPC router into a Request handler that returns Response objects.\n\nRequired Web APIs‚Äã\n\ntRPC server uses the following Fetch APIs:\n\nRequest, Response\nfetch\nHeaders\nURL\n\nIf your runtime supports these APIs, you can use tRPC server.\n\nTIP\n\nFun fact: that also means you can use a tRPC server in your browser!\n\nCommon setup‚Äã\nInstall dependencies‚Äã\nTIP\n\nYou can skip this step if you use Deno Deploy.\n\nnpm\nyarn\npnpm\nbun\ndeno\nnpm install @trpc/server @trpc/client zod\n\nZod isn't a required dependency, but it's used in the sample router below.\n\nCreate the router‚Äã\n\nFirst of all you need a router to handle your queries, mutations and subscriptions.\n\nA sample router is given below, save it in a file named router.ts.\n\nrouter.ts\n\nIf your router file starts getting too big, split your router into several subrouters each implemented in its own file. Then merge them into a single root appRouter.\n\nCreate the context‚Äã\n\nThen you need a context that will be created for each request.\n\nA sample context is given below, save it in a file named context.ts:\n\ncontext.ts\nRuntimes-specific setup‚Äã\nAstro‚Äã\nsrc/pages/trpc/[trpc].ts\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport type { APIRoute } from 'astro';\nimport { createContext } from '../../server/context';\nimport { appRouter } from '../../server/router';\nexport const ALL: APIRoute = (opts) => {\n  return fetchRequestHandler({\n    endpoint: '/trpc',\n    req: opts.request,\n    router: appRouter,\n    createContext,\n  });\n};\nCopy\nCloudflare Worker‚Äã\nNOTE\n\nYou need the Wrangler CLI to run Cloudflare Workers.\n\nCreate Cloudflare Worker‚Äã\nserver.ts\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { createContext } from './context';\nimport { appRouter } from './router';\nexport default {\n  async fetch(request: Request): Promise<Response> {\n    return fetchRequestHandler({\n      endpoint: '/trpc',\n      req: request,\n      router: appRouter,\n      createContext,\n    });\n  },\n};\nCopy\n\nRun wrangler dev server.ts and your endpoints will be available via HTTP!\n\nEndpoint\tHTTP URI\ngetUser\tGET http://localhost:8787/trpc/getUserById?input=INPUT\n\nwhere INPUT is a URI-encoded JSON string.\ncreateUser\tPOST http://localhost:8787/trpc/createUser\n\nwith req.body of type User\nDeno Oak‚Äã\nNOTE\n\nThis assumes you have Deno installed and setup. Refer to their getting started guide for more information.\n\nUpdate the imports in router.ts‚Äã\nrouter.ts\nimport { initTRPC } from 'npm:@trpc/server';\nimport { z } from 'npm:zod';\nimport { Context } from './context.ts';\nCopy\nUpdate the imports in context.ts‚Äã\ncontext.ts\nimport { FetchCreateContextFnOptions } from 'npm:@trpc/server/adapters/fetch';\nCopy\nUse fetchRequestHandler with Oak in app.ts‚Äã\napp.ts\nimport { Application, Router } from 'https://deno.land/x/oak/mod.ts';\nimport { fetchRequestHandler } from 'npm:@trpc/server/adapters/fetch';\nimport { createContext } from './context.ts';\nimport { appRouter } from './router.ts';\nconst app = new Application();\nconst router = new Router();\nrouter.all('/trpc/(.*)', async (ctx) => {\n  const res = await fetchRequestHandler({\n    endpoint: '/trpc',\n    req: new Request(ctx.request.url, {\n      headers: ctx.request.headers,\n      body:\n        ctx.request.method !== 'GET' && ctx.request.method !== 'HEAD'\n          ? ctx.request.body({ type: 'stream' }).value\n          : void 0,\n      method: ctx.request.method,\n    }),\n    router: appRouter,\n    createContext,\n  });\n  ctx.response.status = res.status;\n  ctx.response.headers = res.headers;\n  ctx.response.body = res.body;\n});\napp.use(router.routes());\napp.use(router.allowedMethods());\nawait app.listen({ port: 3000 });\nCopy\nDeno Deploy‚Äã\nNOTE\n\nThis assumes you have Deno installed and setup. Refer to their getting started guide for more information.\n\nTIP\n\nSee our example Deno Deploy app for a working example.\n\nUpdate the imports in router.ts‚Äã\nrouter.ts\nimport { initTRPC } from 'npm:@trpc/server';\nimport { z } from 'npm:zod';\nimport { Context } from './context.ts';\nCopy\nUpdate the imports in context.ts‚Äã\ncontext.ts\nimport { FetchCreateContextFnOptions } from 'npm:@trpc/server/adapters/fetch';\nCopy\nCreate Deno Deploy Function‚Äã\nserver.ts\nimport { fetchRequestHandler } from 'npm:@trpc/server/adapters/fetch';\nimport { createContext } from './context.ts';\nimport { appRouter } from './router.ts';\nfunction handler(request) {\n  return fetchRequestHandler({\n    endpoint: '/trpc',\n    req: request,\n    router: appRouter,\n    createContext,\n  });\n}\nDeno.serve(handler);\nCopy\n\nRun deno run --allow-net=:8000 --allow-env ./server.ts and your endpoints will be available via HTTP!\n\nEndpoint\tHTTP URI\ngetUser\tGET http://localhost:8000/trpc/getUserById?input=INPUT\n\nwhere INPUT is a URI-encoded JSON string.\ncreateUser\tPOST http://localhost:8000/trpc/createUser\n\nwith req.body of type User\nNext.js Edge Runtime‚Äã\n\nSee a full example here.\n\nRemix‚Äã\napp/routes/trpc.$trpc.ts\nimport type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node';\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { createContext } from '~/server/context';\nimport { appRouter } from '~/server/router';\nexport const loader = async (args: LoaderFunctionArgs) => {\n  return handleRequest(args);\n};\nexport const action = async (args: ActionFunctionArgs) => {\n  return handleRequest(args);\n};\nfunction handleRequest(args: LoaderFunctionArgs | ActionFunctionArgs) {\n  return fetchRequestHandler({\n    endpoint: '/trpc',\n    req: args.request,\n    router: appRouter,\n    createContext,\n  });\n}\nCopy\nSolidStart‚Äã\nsrc/routes/api/trpc/[trpc].ts\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport type { APIEvent } from 'solid-start';\nimport { createContext } from '../../server/context';\nimport { appRouter } from '../../server/router';\nconst handler = (event: APIEvent) =>\n  fetchRequestHandler({\n    endpoint: '/api/trpc',\n    req: event.request,\n    router: appRouter,\n    createContext,\n  });\nexport { handler as GET, handler as POST };\nCopy\nVercel Edge Runtime‚Äã\nNOTE\n\nSee the official Vercel Edge Runtime documentation for more information.\n\nTIP\n\nSee our example Vercel Edge Runtime app for a working example.\n\nInstall dependencies‚Äã\nnpm\nyarn\npnpm\nbun\nnpm install -g edge-runtime\nCopy\nCreate Edge Runtime Function‚Äã\nserver.ts\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { createContext } from './context';\nimport { appRouter } from './router';\naddEventListener('fetch', (event) => {\n  return event.respondWith(\n    fetchRequestHandler({\n      endpoint: '/trpc',\n      req: event.request,\n      router: appRouter,\n      createContext,\n    }),\n  );\n});\nCopy\n\nRun edge-runtime --listen server.ts --port 3000 and your endpoints will be available via HTTP!\n\nEndpoint\tHTTP URI\ngetUser\tGET http://localhost:3000/trpc/getUserById?input=INPUT\n\nwhere INPUT is a URI-encoded JSON string.\ncreateUser\tPOST http://localhost:3000/trpc/createUser\n\nwith req.body of type User\nEdit this page"
  }
]
</file>

</files>
